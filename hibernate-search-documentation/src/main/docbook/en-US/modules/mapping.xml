<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Hibernate, Relational Persistence for Idiomatic Java
  ~
  ~  Copyright (c) 2010, Red Hat, Inc. and/or its affiliates or third-party contributors as
  ~  indicated by the @author tags or express copyright attribution
  ~  statements applied by the authors.  All third-party contributions are
  ~  distributed under license by Red Hat, Inc.
  ~
  ~  This copyrighted material is made available to anyone wishing to use, modify,
  ~  copy, or redistribute it subject to the terms and conditions of the GNU
  ~  Lesser General Public License, as published by the Free Software Foundation.
  ~
  ~  This program is distributed in the hope that it will be useful,
  ~  but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~  for more details.
  ~
  ~  You should have received a copy of the GNU Lesser General Public License
  ~  along with this distribution; if not, write to:
  ~  Free Software Foundation, Inc.
  ~  51 Franklin Street, Fifth Floor
  ~  Boston, MA  02110-1301  USA
  -->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "../hsearch.ent">
%BOOK_ENTITIES;
]>
<chapter id="search-mapping" revision="3">
  <title>Mapping entities to the index structure</title>

  <section id="search-mapping-entity" revision="3">
    <title>Mapping an entity</title>

    <para>In <xref linkend="getting-started" /> you have already learned that
    all the metadata information needed to index entities is described through
    annotations. There is no need for xml mapping files. You can still use
    Hibernate mapping files for the basic Hibernate configuration, but the
    Hibernate Search specific configuration has to be expressed via
    annotations.</para>

    <note>
      <para>There is no XML configuration available for Hibernate Search but
      we provide a powerful programmatic mapping API that elegantly replaces
      this kind of deployment form (see <xref
      linkend="hsearch-mapping-programmaticapi" /> for more
      information).</para>

      <para>If you want to contribute the XML mapping implementation, see
      <ulink
      url="https://hibernate.onjira.com/browse/HSEARCH-210">HSEARCH-210</ulink>.</para>
    </note>

    <section id="basic-mapping">
      <title>Basic mapping</title>

      <para>Lets start with the most commonly used annotations for mapping an
      entity.</para>

      <section id="indexed-annotation">
        <title>@Indexed</title>

        <para>Foremost we must declare a persistent class as indexable. This
        is done by annotating the class with <literal>@Indexed</literal> (all
        entities not annotated with <literal>@Indexed</literal> will be
        ignored by the indexing process):</para>

        <example>
          <title>Making a class indexable with
          <classname>@Indexed</classname></title>

          <programlisting>@Entity
<emphasis role="bold">@Indexed</emphasis>
public class Essay {
    ...
}</programlisting>
        </example>

        <para>You can optionially specify the <literal>index</literal>
        attribute of the @Indexed annotation to change the default name of the
        index. For more information see <xref
        linkend="search-configuration-directory" />.</para>
      </section>

      <section id="field-annotation">
        <title>@Field</title>

        <para>For each property (or attribute) of your entity, you have the
        ability to describe how it will be indexed. The default (no annotation
        present) means that the property is ignored by the indexing process.
        <literal>@Field</literal> does declare a property as indexed and
        allows to configure several aspects of the indexing process by setting
        one or more of the following attributes:</para>

        <itemizedlist>
          <listitem>
            <para><literal>name</literal> : describe under which name, the
            property should be stored in the Lucene Document. The default
            value is the property name (following the JavaBeans
            convention)</para>
          </listitem>

          <listitem>
            <para><literal>store</literal> : describe whether or not the
            property is stored in the Lucene index. You can store the value
            <literal>Store.YES</literal> (consuming more space in the index
            but allowing projection, see <xref linkend="projections" />),
            store it in a compressed way <literal>Store.COMPRESS</literal>
            (this does consume more CPU), or avoid any storage
            <literal>Store.NO</literal> (this is the default value). When a
            property is stored, you can retrieve its original value from the
            Lucene Document. This is not related to whether the element is
            indexed or not.</para>
          </listitem>

          <listitem>
            <para>index: describe whether the property is indexed or not. The
            different values are <literal>Index.NO</literal> (no indexing, ie
            cannot be found by a query), <literal>Index.YES</literal> (the
            element gets indexed and is searchable). The default value is
            <literal>Index.YES</literal>. <literal>Index.NO</literal> can be
            useful for cases where a property does is not required to be
            searchable, but should be available for projection.</para>

            <tip>
              <para><literal>Index.NO</literal> in combination with
              <literal>Analyze.YES</literal> or <literal>Norms.YES</literal>
              is not useful, since <literal>analyze</literal> and
              <literal>norms</literal> require the property to be
              indexed</para>
            </tip>
          </listitem>

          <listitem>
            <para>analyze: determines whether the property is analyzed
            (<literal>Analyze.YES</literal>) or not
            (<literal>Analyze.NO</literal>). The default value is
            <literal>Analyze.YES</literal>.<tip>
                <para>Whether or not you want to analyze a property depends on
                whether you wish to search the element as is, or by the words
                it contains. It make sense to analyze a text field, but
                probably not a date field.</para>
              </tip><tip>
                <para>Fields used for sorting <emphasis>must not</emphasis> be
                analyzed.</para>
              </tip></para>
          </listitem>

          <listitem>
            <para>norms: describes whether index time boosting information
            should be stored (<literal>Norms.YES</literal>) or not
            (<literal>Norms.NO</literal>). Not storing it can save a
            considerable amount of memory, but there won't be any index time
            boosting information available. The default value is
            <literal>Norms.YES</literal>.</para>
          </listitem>

          <listitem>
            <para>termVector: describes collections of term-frequency pairs.
            This attribute enables the storing of the term vectors within the
            documents during indexing. The default value is
            <literal>TermVector.NO</literal>.</para>

            <para>The different values of this attribute are:</para>

            <informaltable align="left" width="">
              <tgroup cols="2">
                <thead>
                  <row>
                    <entry align="center">Value</entry>

                    <entry align="center">Definition</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry align="left">TermVector.YES</entry>

                    <entry>Store the term vectors of each document. This
                    produces two synchronized arrays, one contains document
                    terms and the other contains the term's frequency.</entry>
                  </row>

                  <row>
                    <entry align="left">TermVector.NO</entry>

                    <entry>Do not store term vectors.</entry>
                  </row>

                  <row>
                    <entry align="left">TermVector.WITH_OFFSETS</entry>

                    <entry>Store the term vector and token offset information.
                    This is the same as TermVector.YES plus it contains the
                    starting and ending offset position information for the
                    terms.</entry>
                  </row>

                  <row>
                    <entry align="left">TermVector.WITH_POSITIONS</entry>

                    <entry>Store the term vector and token position
                    information. This is the same as TermVector.YES plus it
                    contains the ordinal positions of each occurrence of a
                    term in a document.</entry>
                  </row>

                  <row>
                    <entry
                    align="left">TermVector.WITH_POSITION_OFFSETS</entry>

                    <entry>Store the term vector, token position and offset
                    information. This is a combination of the YES,
                    WITH_OFFSETS and WITH_POSITIONS.</entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </listitem>

          <listitem>
            <para><literal>indexNullAs</literal> : Per default null values are
            ignored and not indexed. However, using
            <parameter>indexNullAs</parameter> you can specify a string which
            will be inserted as token for the <constant>null</constant> value.
            Per default this value is set to
            <constant>Field.DO_NOT_INDEX_NULL</constant> indicating that
            <constant>null</constant> values should not be indexed. You can
            set this value to <constant>Field.DEFAULT_NULL_TOKEN </constant>to
            indicate that a default <constant>null</constant> token should be
            used. This default <constant>null</constant> token can be
            specified in the configuration using
            <literal>hibernate.search.default_null_token</literal>. If this
            property is not set and you specify
            <constant>Field.DEFAULT_NULL_TOKEN</constant> the string "_null_"
            will be used as default. <note>
                <para>When the <parameter>indexNullAs</parameter> parameter is
                used it is important to use the same token in the search query
                (see <xref linkend="search-query" />) to search for
                <constant>null</constant> values. It is also advisable to use
                this feature only with un-analyzed fields
                (<literal><literal>analyze=</literal>Analyze.NO</literal>).</para>
              </note><warning>
                <para>When implementing a custom
                <classname>FieldBridge</classname> or
                <classname>TwoWayFieldBridge</classname> it is up to the
                developer to handle the indexing of null values (see JavaDocs
                of
                <methodname>LuceneOptions.indexNullAs()</methodname>).</para>
              </warning></para>
          </listitem>
        </itemizedlist>
      </section>

      <section id="numeric-field-annotation">
        <title>@NumericField</title>

        <para>There is a companion annotation to <classname>@Field</classname>
        called <classname>@NumericField</classname> that can be specified in
        the same scope as <classname>@Field</classname> or
        <classname>@DocumentId</classname>. It can be specified for Integer,
        Long, Float and Double properties. At index time the value will be
        indexed using a <ulink url="http://en.wikipedia.org/wiki/Trie">Trie
        structure</ulink>. When a property is indexed as numeric field, it
        enables efficient range query and sorting, orders of magnitude faster
        than doing the same query on standard <classname>@Field
        </classname>properties. The <classname>@NumericField</classname>
        annotation accept the following parameters: <informaltable
            align="left" width="">
            <tgroup cols="2">
              <thead>
                <row>
                  <entry align="center">Value</entry>

                  <entry align="center">Definition</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry align="left">forField</entry>

                  <entry>(Optional) Specify the name of of the related @Field
                  that will be indexed as numeric. It's only mandatory when
                  the property contains more than a @Field declaration</entry>
                </row>

                <row>
                  <entry align="left">precisionStep</entry>

                  <entry>(Optional) Change the way that the Trie structure is
                  stored in the index. Smaller precisionSteps lead to more
                  disk space usage and faster range and sort queries. Larger
                  values lead to less space used and range query performance
                  more close to the range query in normal @Fields. Default
                  value is 4.</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
          <classname>@NumericField</classname> supports only <classname>Double</classname>,
          <classname>Long</classname>, <classname>Integer</classname> and
          <classname>Float</classname>. It is not possible to take any advantage
          from a similar functionality in Lucene for the other numeric types, so
          remaining types should use the string encoding via the default or
          custom <classname>TwoWayFieldBridge</classname>.</para>

        <para>It is possible to use a custom <classname>NumericFieldBridge</classname>
        assuming you can deal with the approximation during type transformation:</para>

        <example id="example-custom-numericfieldbridge">
        <title>Defining a custom <classname>NumericFieldBridge</classname></title>
        <programlisting language="JAVA" role="JAVA">
public class BigDecimalNumericFieldBridge extends NumericFieldBridge {
   private static final BigDecimal storeFactor = BigDecimal.valueOf(100);

   @Override
   public void set(String name, Object value, Document document, LuceneOptions luceneOptions) {
      if ( value != null ) {
         BigDecimal decimalValue = (BigDecimal) value;
         Long indexedValue = Long.valueOf( decimalValue.multiply( storeFactor ).longValue() );
         luceneOptions.addNumericFieldToDocument( name, indexedValue, document );
      }
   }

    @Override
    public Object get(String name, Document document) {
        String fromLucene = document.get( name );
        BigDecimal storedBigDecimal = new BigDecimal( fromLucene );
        return storedBigDecimal.divide( storeFactor );
    }

}
</programlisting></example>

        <note>
          <para>Lucene marks the numeric field API still as experimental and
          warns for incompatible changes in coming releases. Using Hibernate
          Search will hopefully shield you from any underlying API changes,
          but that is not guaranteed.</para>
        </note>
      </section>

      <section id="id-annotation">
        <title>@Id</title>

        <para>Finally, the id property of an entity is a special property used
        by Hibernate Search to ensure index unicity of a given entity. By
        design, an id has to be stored and must not be tokenized. To mark a
        property as index id, use the <literal>@DocumentId</literal>
        annotation. If you are using JPA and you have specified
        <classname>@Id</classname> you can omit
        <classname>@DocumentId</classname>. The chosen entity id will also be
        used as document id.</para>

        <example id="example-annotated-entity">
          <title>Specifying indexed properties</title>

          <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public class Essay {
    ...

    @Id
    <emphasis role="bold">@DocumentId</emphasis>
    public Long getId() { return id; }

    <emphasis role="bold">@Field(name="Abstract", store=Store.YES)</emphasis>
    public String getSummary() { return summary; }

    @Lob
    <emphasis role="bold">@Field</emphasis>
    public String getText() { return text; }

    <emphasis role="bold">@Field 
    @NumericField( precisionStep = 6)</emphasis>
    public float getGrade() { return grade; }
}</programlisting>
        </example>

        <para><xref linkend="example-annotated-entity" /> defines an index
        with four fields: <literal>id</literal> , <literal>Abstract</literal>,
        <literal>text</literal> and <literal>grade</literal> . Note that by
        default the field name is decapitalized, following the JavaBean
        specification. The <literal>grade</literal> field is annotated as
        Numeric with a slightly larger precisionStep than the default.</para>
      </section>
    </section>

    <section>
      <title>Mapping properties multiple times</title>

      <para>Sometimes one has to map a property multiple times per index, with
      slightly different indexing strategies. For example, sorting a query by
      field requires the field to be un-analyzed. If one wants to search by
      words in this property and still sort it, one need to index it twice -
      once analyzed and once un-analyzed. @Fields allows to achieve this
      goal.</para>

      <example id="example-fields-annotation">
        <title>Using @Fields to map a property multiple times</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed(index = "Book" )
public class Book {
    <emphasis role="bold">@Fields( {</emphasis>
            @Field,
            @Field(name = "summary_forSort", analyze = Analyze.NO, store = Store.YES)
            <emphasis role="bold">} )</emphasis>
    public String getSummary() {
        return summary;
    }

    ...
}</programlisting>
      </example>

      <para>In <xref linkend="example-fields-annotation" /> the field
      <literal>summary</literal> is indexed twice, once as
      <literal>summary</literal> in a tokenized way, and once as
      <literal>summary_forSort</literal> in an untokenized way. @Field
      supports 2 attributes useful when @Fields is used:</para>

      <itemizedlist>
        <listitem>
          <para>analyzer: defines a @Analyzer annotation per field rather than
          per property</para>
        </listitem>

        <listitem>
          <para>bridge: defines a @FieldBridge annotation per field rather
          than per property</para>
        </listitem>
      </itemizedlist>

      <para>See below for more information about analyzers and field
      bridges.</para>
    </section>

    <section id="search-mapping-associated">
      <title>Embedded and associated objects</title>

      <para>Associated objects as well as embedded objects can be indexed as
      part of the root entity index. This is useful if you expect to search a
      given entity based on properties of associated objects. In <xref
      linkend="example-indexing-associations" />t the aim is to return places
      where the associated city is Atlanta (In the Lucene query parser
      language, it would translate into <code>address.city:Atlanta</code>).
      The place fields will be indexed in the <literal>Place</literal> index.
      The <literal>Place</literal> index documents will also contain the
      fields <literal>address.id</literal>, <literal>address.street</literal>,
      and <literal>address.city</literal> which you will be able to
      query.</para>

      <example id="example-indexing-associations">
        <title>Indexing associations</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public class Place {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field
    private String name;

    @OneToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )
    <emphasis role="bold">@IndexedEmbedded</emphasis>
    private Address address;
    ....
}

@Entity
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String street;

    @Field
    private String city;

    <emphasis role="bold">@ContainedIn</emphasis>
    @OneToMany(mappedBy="address")
    private Set&lt;Place&gt; places;
    ...
}</programlisting>
      </example>

      <para>Be careful. Because the data is denormalized in the Lucene index
      when using the <classname>@IndexedEmbedded</classname> technique,
      Hibernate Search needs to be aware of any change in the
      <classname>Place</classname> object and any change in the
      <classname>Address</classname> object to keep the index up to date. To
      make sure the <literal><classname>Place</classname></literal> Lucene
      document is updated when it's <classname>Address</classname> changes,
      you need to mark the other side of the bidirectional relationship with
      <classname>@ContainedIn</classname>.</para>

      <tip>
        <para><literal>@ContainedIn</literal> is useful on both associations
        pointing to entities and on embedded (collection of) objects.</para>
      </tip>

      <para>Let's make <xref linkend="example-indexing-associations" /> a bit
      more complex by nesting @IndexedEmbedded as seen in <xref
      linkend="example-nested-index-embedded" />.</para>

      <example id="example-nested-index-embedded">
        <title>Nested usage of <classname>@IndexedEmbedded</classname> and
        <classname>@ContainedIn</classname></title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public class Place {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field
    private String name;

    @OneToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )
    <emphasis role="bold">@IndexedEmbedded</emphasis>
    private Address address;
    ....
}

@Entity
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String street;

    @Field
    private String city;

    <emphasis role="bold">@IndexedEmbedded(depth = 1, prefix = "ownedBy_")</emphasis>
    private Owner ownedBy;

    <emphasis role="bold">@ContainedIn</emphasis>
    @OneToMany(mappedBy="address")
    private Set&lt;Place&gt; places;
    ...
}

@Embeddable
public class Owner {
    @Field
    private String name;
   ...
}</programlisting>
      </example>

      <para>As you can see, any <literal>@*ToMany, @*ToOne</literal> and
      <literal>@Embedded</literal> attribute can be annotated with
      <literal>@IndexedEmbedded</literal>. The attributes of the associated
      class will then be added to the main entity index. In <xref
      linkend="example-nested-index-embedded" /> the index will contain the
      following fields</para>

      <itemizedlist>
        <listitem>
          <para>id</para>
        </listitem>

        <listitem>
          <para>name</para>
        </listitem>

        <listitem>
          <para>address.street</para>
        </listitem>

        <listitem>
          <para>address.city</para>
        </listitem>

        <listitem>
          <para>address.ownedBy_name</para>
        </listitem>
      </itemizedlist>

      <para>The default prefix is <literal>propertyName.</literal>, following
      the traditional object navigation convention. You can override it using
      the <literal>prefix</literal> attribute as it is shown on the
      <literal>ownedBy</literal> property.</para>

      <note>
        <para>The prefix cannot be set to the empty string.</para>
      </note>

      <para>The<literal> depth</literal> property is necessary when the object
      graph contains a cyclic dependency of classes (not instances). For
      example, if <classname>Owner</classname> points to
      <classname>Place</classname>. Hibernate Search will stop including
      Indexed embedded attributes after reaching the expected depth (or the
      object graph boundaries are reached). A class having a self reference is
      an example of cyclic dependency. In our example, because
      <literal>depth</literal> is set to 1, any
      <literal>@IndexedEmbedded</literal> attribute in Owner (if any) will be
      ignored.</para>

      <para>Using <literal>@IndexedEmbedded</literal> for object associations
      allows you to express queries (using Lucene's query syntax) such
      as:</para>

      <itemizedlist>
        <listitem>
          <para>Return places where name contains JBoss and where address city
          is Atlanta. In Lucene query this would be</para>

          <programlisting>+name:jboss +address.city:atlanta  </programlisting>
        </listitem>

        <listitem>
          <para>Return places where name contains JBoss and where owner's name
          contain Joe. In Lucene query this would be</para>

          <programlisting>+name:jboss +address.orderBy_name:joe  </programlisting>
        </listitem>
      </itemizedlist>

      <para>In a way it mimics the relational join operation in a more
      efficient way (at the cost of data duplication). Remember that, out of
      the box, Lucene indexes have no notion of association, the join
      operation is simply non-existent. It might help to keep the relational
      model normalized while benefiting from the full text index speed and
      feature richness.</para>

      <para><note>
          <para>An associated object can itself (but does not have to) be
          <literal>@Indexed</literal></para>
        </note></para>

      <para>When @IndexedEmbedded points to an entity, the association has to
      be directional and the other side has to be annotated
      <literal>@ContainedIn</literal> (as seen in the previous example). If
      not, Hibernate Search has no way to update the root index when the
      associated entity is updated (in our example, a <literal>Place</literal>
      index document has to be updated when the associated
      <classname>Address</classname> instance is updated).</para>

      <para>Sometimes, the object type annotated by
      <classname>@IndexedEmbedded</classname> is not the object type targeted
      by Hibernate and Hibernate Search. This is especially the case when
      interfaces are used in lieu of their implementation. For this reason you
      can override the object type targeted by Hibernate Search using the
      <methodname>targetElement</methodname> parameter.</para>

      <example>
        <title>Using the <literal>targetElement</literal> property of
        <classname>@IndexedEmbedded</classname></title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public class Address {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field
    private String street;

    @IndexedEmbedded(depth = 1, prefix = "ownedBy_", <emphasis role="bold">targetElement = Owner.class</emphasis>)
    @Target(Owner.class)
    private Person ownedBy;


    ...
}

@Embeddable
public class Owner implements Person { ... }</programlisting>
      </example>
    </section>
  </section>

  <section>
    <title>Boosting</title>

    <para>Lucene has the notion of <emphasis>boosting</emphasis> which allows
    you to give certain documents or fields more or less importance than
    others. Lucene differentiates between index and search time boosting. The
    following sections show you how you can achieve index time boosting using
    Hibernate Search.</para>

    <section id="section-boost-annotation">
      <title>Static index time boosting</title>

      <para>To define a static boost value for an indexed class or property
      you can use the <classname>@Boost</classname> annotation. You can use
      this annotation within @Field or specify it directly on method or class
      level.</para>

      <example id="example-boost">
        <title>Different ways of using @Boost</title>

        <programlisting>@Entity
@Indexed
<emphasis role="bold">@Boost(1.7f)</emphasis>
public class Essay {
    ...

    @Id
    @DocumentId
    public Long getId() { return id; }

    @Field(name="Abstract", store=Store.YES, boost=<emphasis role="bold">@Boost(2f)</emphasis>)
    <emphasis role="bold">@Boost(1.5f)</emphasis>
    public String getSummary() { return summary; }

    @Lob
    @Field(boost=<emphasis role="bold">@Boost(1.2f)</emphasis>)
    public String getText() { return text; }

    @Field
    public String getISBN() { return isbn; }

}        </programlisting>
      </example>

      <para>In <xref linkend="example-boost" />,
      <classname>Essay</classname>'s probability to reach the top of the
      search list will be multiplied by 1.7. The
      <methodname>summary</methodname> field will be 3.0 (2 * 1.5, because
      <methodname>@Field.boost</methodname> and <classname>@Boost</classname>
      on a property are cumulative) more important than the
      <methodname>isbn</methodname> field. The <methodname>text</methodname>
      field will be 1.2 times more important than the
      <methodname>isbn</methodname> field. Note that this explanation is wrong
      in strictest terms, but it is simple and close enough to reality for all
      practical purposes. Please check the Lucene documentation or the
      excellent <citetitle>Lucene In Action </citetitle> from Otis Gospodnetic
      and Erik Hatcher.</para>
    </section>

    <section>
      <title id="section-dynamic-boost">Dynamic index time boosting</title>

      <para>The <literal>@Boost </literal>annotation used in <xref
      linkend="section-boost-annotation" /> defines a static boost factor
      which is independent of the state of of the indexed entity at runtime.
      However, there are usecases in which the boost factor may depend on the
      actual state of the entity. In this case you can use the
      <literal>@DynamicBoost </literal>annotation together with an
      accompanying custom <classname>BoostStrategy</classname>.</para>

      <example id="example-dynamic-boosting">
        <title>Dynamic boost example</title>

        <programlisting language="JAVA" role="JAVA">public enum PersonType {
    NORMAL,
    VIP
}

@Entity
@Indexed
<emphasis role="bold">@DynamicBoost(impl = VIPBoostStrategy.class)</emphasis>
public class Person {
    private PersonType type;   
    
    // ....
}

public class VIPBoostStrategy implements BoostStrategy {
    <emphasis role="bold">public float defineBoost(Object value)</emphasis> {
        Person person = ( Person ) value;
        if ( person.getType().equals( PersonType.VIP ) ) {
            return 2.0f;
        }
        else {
            return 1.0f;
        }
    }
}</programlisting>
      </example>

      <para>In <xref linkend="example-dynamic-boosting" /> a dynamic boost is
      defined on class level specifying
      <classname>VIPBoostStrategy</classname> as implementation of the
      <classname>BoostStrategy</classname> interface to be used at indexing
      time. You can place the <literal>@DynamicBoost</literal> either at class
      or field level. Depending on the placement of the annotation either the
      whole entity is passed to the <methodname>defineBoost</methodname>
      method or just the annotated field/property value. It's up to you to
      cast the passed object to the correct type. In the example all indexed
      values of a VIP person would be double as important as the values of a
      normal person.<note>
          <para>The specified <classname>BoostStrategy</classname>
          implementation must define a public no-arg constructor.</para>
        </note>Of course you can mix and match <literal>@Boost</literal> and
      <literal>@DynamicBoost</literal> annotations in your entity. All defined
      boost factors are cumulative.</para>
    </section>
  </section>

  <section>
    <title>Analysis</title>

    <para><literal>Analysis</literal> is the process of converting text into
    single terms (words) and can be considered as one of the key features of a
    fulltext search engine. Lucene uses the concept of
    <classname>Analyzer</classname>s to control this process. In the following
    section we cover the multiple ways Hibernate Search offers to configure
    the analyzers.</para>

    <section id="analyzer">
      <title>Default analyzer and analyzer by class</title>

      <para>The default analyzer class used to index tokenized fields is
      configurable through the <literal>hibernate.search.analyzer</literal>
      property. The default value for this property is
      <classname>org.apache.lucene.analysis.standard.StandardAnalyzer</classname>.</para>

      <para>You can also define the analyzer class per entity, property and
      even per @Field (useful when multiple fields are indexed from a single
      property).</para>

      <example>
        <title>Different ways of using @Analyzer</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
<emphasis role="bold">@Analyzer(impl = EntityAnalyzer.class)</emphasis>
public class MyEntity {
    @Id
    @GeneratedValue
    @DocumentId
    private Integer id;

    @Field
    private String name;

    @Field
    <emphasis role="bold">@Analyzer(impl = PropertyAnalyzer.class)</emphasis>
    private String summary;

    @Field(<emphasis><emphasis role="bold">analyzer = @Analyzer(impl = FieldAnalyzer.class</emphasis></emphasis>)
    private String body;

    ...
}</programlisting>
      </example>

      <para>In this example, <classname>EntityAnalyzer</classname> is used to
      index all tokenized properties (eg. <literal>name</literal>), except
      <literal>summary</literal> and <literal>body</literal> which are indexed
      with <classname>PropertyAnalyzer</classname> and
      <classname>FieldAnalyzer</classname> respectively.</para>

      <caution>
        <para>Mixing different analyzers in the same entity is most of the
        time a bad practice. It makes query building more complex and results
        less predictable (for the novice), especially if you are using a
        QueryParser (which uses the same analyzer for the whole query). As a
        rule of thumb, for any given field the same analyzer should be used
        for indexing and querying.</para>
      </caution>
    </section>

    <section>
      <title>Named analyzers</title>

      <para>Analyzers can become quite complex to deal with. For this reason
      introduces Hibernate Search the notion of analyzer definitions. An
      analyzer definition can be reused by many
      <classname>@Analyzer</classname> declarations and is composed of:</para>

      <itemizedlist>
        <listitem>
          <para>a name: the unique string used to refer to the
          definition</para>
        </listitem>

        <listitem>
          <para>a list of char filters: each char filter is responsible to
          pre-process input characters before the tokenization. Char filters
          can add, change or remove characters; one common usage is for
          characters normalization</para>
        </listitem>

        <listitem>
          <para>a tokenizer: responsible for tokenizing the input stream into
          individual words</para>
        </listitem>

        <listitem>
          <para>a list of filters: each filter is responsible to remove,
          modify or sometimes even add words into the stream provided by the
          tokenizer</para>
        </listitem>
      </itemizedlist>

      <para>This separation of tasks - a list of char filters, and a tokenizer
      followed by a list of filters - allows for easy reuse of each individual
      component and let you build your customized analyzer in a very flexible
      way (just like Lego). Generally speaking the char filters do some
      pre-processing in the character input, then the
      <classname>Tokenizer</classname> starts the tokenizing process by
      turning the character input into tokens which are then further processed
      by the <classname>TokenFilter</classname>s. Hibernate Search supports
      this infrastructure by utilizing the Solr analyzer framework.</para>

      <note>
        <para>Some of the analyzers and filters will require additional
        dependencies. For example to use the snowball stemmer you have to also
        include the <literal>lucene-snowball</literal> jar and for the
        <classname>PhoneticFilterFactory</classname> you need the <ulink
        url="http://commons.apache.org/codec">commons-codec</ulink> jar. Your
        distribution of Hibernate Search provides these dependencies in its
        <filename>lib/optional</filename> directory. Have a look at <xref
        linkend="table-available-tokenizers" /> and <xref
        linkend="table-available-filters" /> to see which anaylzers and
        filters have additional dependencies</para>

        <para>Prior to Search version 3.3.0.Beta2 it was required to add the
        Solr dependency <emphasis>org.apache.solr:solr-core</emphasis> when
        you wanted to use the analyzer definition framework. In case you are
        using Maven this is no longer needed: all required Solr dependencies
        are now defined as dependencies of the artifact
        <emphasis>org.hibernate:hibernate-search-analyzers</emphasis>; just
        add the following dependency :<programlisting>&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-search-analyzers&lt;/artifactId&gt;
   &lt;version&gt;&version;&lt;/version&gt;
&lt;dependency&gt;</programlisting></para>
      </note>

      <para>Let's have a look at a concrete example now - <xref
      linkend="example-analyzer-def" />. First a char filter is defined by its
      factory. In our example, a mapping char filter is used, and will replace
      characters in the input based on the rules specified in the mapping
      file. Next a tokenizer is defined. This example uses the standard
      tokenizer. Last but not least, a list of filters is defined by their
      factories. In our example, the <classname>StopFilter</classname> filter
      is built reading the dedicated words property file. The filter is also
      expected to ignore case.</para>

      <example id="example-analyzer-def">
        <title><classname>@AnalyzerDef</classname> and the Solr
        framework</title>

        <programlisting language="JAVA" role="JAVA">@AnalyzerDef(name="customanalyzer",
  charFilters = {
    @CharFilterDef(factory = MappingCharFilterFactory.class, params = {
      @Parameter(name = "mapping",
        value = "org/hibernate/search/test/analyzer/solr/mapping-chars.properties")
    })
  },
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = ISOLatin1AccentFilterFactory.class),
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = StopFilterFactory.class, params = {
      @Parameter(name="words",
        value= "org/hibernate/search/test/analyzer/solr/stoplist.properties" ),
      @Parameter(name="ignoreCase", value="true")
    })
})
public class Team {
    ...
}</programlisting>
      </example>

      <tip>
        <para>Filters and char filters are applied in the order they are
        defined in the <classname>@AnalyzerDef</classname> annotation. Order
        matters!</para>
      </tip>

      <para>Some tokenizers, token filters or char filters load resources like
      a configuration or metadata file. This is the case for the stop filter
      and the synonym filter. If the resource charset is not using the VM
      default, you can explicitly specify it by adding a
      <literal>resource_charset</literal> parameter.</para>

      <example id="example-analyzer-def-charset">
        <title>Use a specific charset to load the property file</title>

        <programlisting language="JAVA" role="JAVA">@AnalyzerDef(name="customanalyzer",
  charFilters = {
    @CharFilterDef(factory = MappingCharFilterFactory.class, params = {
      @Parameter(name = "mapping",
        value = "org/hibernate/search/test/analyzer/solr/mapping-chars.properties")
    })
  },
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = ISOLatin1AccentFilterFactory.class),
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = StopFilterFactory.class, params = {
      @Parameter(name="words",
        value= "org/hibernate/search/test/analyzer/solr/stoplist.properties" ),
      @Parameter(name="resource_charset", value = "UTF-16BE"),
      @Parameter(name="ignoreCase", value="true")
  })
})
public class Team {
    ...
}</programlisting>
      </example>

      <para>Once defined, an analyzer definition can be reused by an
      <classname>@Analyzer</classname> declaration as seen in <xref
      linkend="example-referencing-analyzer-def" />.</para>

      <example>
        <title id="example-referencing-analyzer-def" remap="">Referencing an
        analyzer by name</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
@AnalyzerDef(name="customanalyzer", ... )
public class Team {
    @Id
    @DocumentId
    @GeneratedValue
    private Integer id;

    @Field
    private String name;

    @Field
    private String location;

    @Field 
    <emphasis role="bold">@Analyzer(definition = "customanalyzer")</emphasis>
    private String description;
}</programlisting>
      </example>

      <para>Analyzer instances declared by <classname>@AnalyzerDef</classname>
      are also available by their name in the
      <classname>SearchFactory</classname> which is quite useful wen building
      queries.</para>

      <programlisting language="JAVA" role="JAVA">Analyzer analyzer = fullTextSession.getSearchFactory().getAnalyzer("customanalyzer");</programlisting>

      <para>Fields in queries should be analyzed with the same analyzer used
      to index the field so that they speak a common "language": the same
      tokens are reused between the query and the indexing process. This rule
      has some exceptions but is true most of the time. Respect it unless you
      know what you are doing.</para>

      <section>
        <title>Available analyzers</title>

        <para>Solr and Lucene come with a lot of useful default char filters,
        tokenizers and filters. You can find a complete list of char filter
        factories, tokenizer factories and filter factories at <ulink
        url="http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters">http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters</ulink>.
        Let's check a few of them.</para>

        <table id="table-available-char-filters">
          <title>Example of available char filters</title>

          <tgroup cols="4">
            <thead>
              <row>
                <entry align="center">Factory</entry>

                <entry align="center">Description</entry>

                <entry align="center">Parameters</entry>

                <entry align="center">Additional dependencies</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><classname>MappingCharFilterFactory</classname></entry>

                <entry>Replaces one or more characters with one or more
                characters, based on mappings specified in the resource
                file</entry>

                <entry><para><literal>mapping</literal>: points to a resource
                file containing the mappings using the format: <literallayout>
                    "á" =&gt; "a"
                    "ñ" =&gt; "n"
                    "ø" =&gt; "o"
                </literallayout> </para></entry>

                <entry>none</entry>
              </row>

              <row>
                <entry><classname>HTMLStripCharFilterFactory</classname></entry>

                <entry>Remove HTML standard tags, keeping the text</entry>

                <entry>none</entry>

                <entry>none</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table id="table-available-tokenizers">
          <title>Example of available tokenizers</title>

          <tgroup cols="4">
            <thead>
              <row>
                <entry align="center">Factory</entry>

                <entry align="center">Description</entry>

                <entry align="center">Parameters</entry>

                <entry align="center">Additional dependencies</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><classname>StandardTokenizerFactory</classname></entry>

                <entry>Use the Lucene StandardTokenizer</entry>

                <entry>none</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry><classname>HTMLStripCharFilterFactory</classname></entry>

                <entry>Remove HTML tags, keep the text and pass it to a
                StandardTokenizer.</entry>

                <entry>none</entry>

                <entry><literal>solr-core</literal></entry>
              </row>

              <row>
                <entry><classname>PatternTokenizerFactory</classname></entry>

                <entry>Breaks text at the specified regular expression
                pattern.</entry>

                <entry><para><literal>pattern</literal>: the regular
                expression to use for tokenizing</para><para>group: says which
                pattern group to extract into tokens</para></entry>

                <entry><literal>solr-core</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table id="table-available-filters">
          <title>Examples of available filters</title>

          <tgroup cols="4">
            <thead>
              <row>
                <entry align="center">Factory</entry>

                <entry align="center">Description</entry>

                <entry align="center">Parameters</entry>

                <entry align="center">Additional dependencies</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><classname>StandardFilterFactory</classname></entry>

                <entry>Remove dots from acronyms and 's from words</entry>

                <entry>none</entry>

                <entry><literal>solr-core</literal></entry>
              </row>

              <row>
                <entry><classname>LowerCaseFilterFactory</classname></entry>

                <entry>Lowercases all words</entry>

                <entry>none</entry>

                <entry><literal>solr-core</literal></entry>
              </row>

              <row>
                <entry><classname>StopFilterFactory</classname></entry>

                <entry>Remove words (tokens) matching a list of stop
                words</entry>

                <entry><para><literal>words</literal>: points to a resource
                file containing the stop words</para><para>ignoreCase: true if
                <literal>case</literal> should be ignore when comparing stop
                words, <literal>false</literal> otherwise </para></entry>

                <entry><literal>solr-core</literal></entry>
              </row>

              <row>
                <entry><classname>SnowballPorterFilterFactory</classname></entry>

                <entry>Reduces a word to it's root in a given language. (eg.
                protect, protects, protection share the same root). Using such
                a filter allows searches matching related words.</entry>

                <entry><literal>language</literal>: Danish, Dutch, English,
                Finnish, French, German, Italian, Norwegian, Portuguese,
                Russian, Spanish, Swedish and a few more</entry>

                <entry><literal>solr-core</literal></entry>
              </row>

              <row>
                <entry><classname>ISOLatin1AccentFilterFactory</classname></entry>

                <entry>Remove accents for languages like French</entry>

                <entry>none</entry>

                <entry><literal>solr-core</literal></entry>
              </row>

              <row>
                <entry><classname>PhoneticFilterFactory</classname></entry>

                <entry>Inserts phonetically similar tokens into the token
                stream</entry>

                <entry><para><literal>encoder</literal>: One of
                DoubleMetaphone, Metaphone, Soundex or
                RefinedSoundex</para><para>inject: <constant>true</constant>
                will add tokens to the stream, <constant>false</constant> will
                replace the existing token
                </para><para><literal>maxCodeLength</literal>: sets the
                maximum length of the code to be generated. Supported only for
                Metaphone and DoubleMetaphone encodings</para></entry>

                <entry><literal>solr-core</literal> and
                <literal>commons-codec</literal></entry>
              </row>

              <row>
                <entry><classname>CollationKeyFilterFactory</classname></entry>

                <entry>Converts each token into its
                <classname>java.text.CollationKey</classname>, and then
                encodes the <classname>CollationKey</classname> with
                <classname>IndexableBinaryStringTools</classname>, to allow it
                to be stored as an index term.</entry>

                <entry><literal>custom</literal>, <literal>language</literal>,
                <literal>country</literal>, <literal>variant</literal>,
                <literal>strength</literal>, <literal>decomposition
                </literal>see Lucene's
                <classname>CollationKeyFilter</classname> javadocs for more
                info</entry>

                <entry><literal>solr-core</literal> and
                <literal>commons-io</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>We recommend to check all the implementations of
        <classname>org.apache.solr.analysis.TokenizerFactory</classname> and
        <classname>org.apache.solr.analysis.TokenFilterFactory</classname> in
        your IDE to see the implementations available.</para>
      </section>
    </section>

    <section>
      <title>Dynamic analyzer selection</title>

      <para>So far all the introduced ways to specify an analyzer were static.
      However, there are use cases where it is useful to select an analyzer
      depending on the current state of the entity to be indexed, for example
      in a multilingual applications. For an <classname>BlogEntry</classname>
      class for example the analyzer could depend on the language property of
      the entry. Depending on this property the correct language specific
      stemmer should be chosen to index the actual text.</para>

      <para>To enable this dynamic analyzer selection Hibernate Search
      introduces the <classname>AnalyzerDiscriminator</classname> annotation.
      <xref linkend="example-analyzer-discriminator" /> demonstrates the usage
      of this annotation.</para>

      <example id="example-analyzer-discriminator">
        <title>Usage of @AnalyzerDiscriminator</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
@AnalyzerDefs({
  @AnalyzerDef(name = "en",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = EnglishPorterFilterFactory.class
      )
    }),
  @AnalyzerDef(name = "de",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = GermanStemFilterFactory.class)
    })
})
public class BlogEntry {

    @Id
    @GeneratedValue
    @DocumentId
    private Integer id;

    @Field
    @AnalyzerDiscriminator(impl = LanguageDiscriminator.class)
    private String language;
    
    @Field
    private String text;
    
    private Set&lt;BlogEntry&gt; references;

    // standard getter/setter
    ...
}</programlisting>

        <programlisting language="JAVA" role="JAVA">public class LanguageDiscriminator implements Discriminator {

    public String getAnalyzerDefinitionName(Object value, Object entity, String field) {
        if ( value == null || !( entity instanceof Article ) ) {
            return null;
        }
        return (String) value;

    }
}</programlisting>
      </example>

      <para>The prerequisite for using
      <classname>@AnalyzerDiscriminator</classname> is that all analyzers
      which are going to be used dynamically are predefined via
      <classname>@AnalyzerDef</classname> definitions. If this is the case,
      one can place the <classname>@AnalyzerDiscriminator</classname>
      annotation either on the class or on a specific property of the entity
      for which to dynamically select an analyzer. Via the
      <literal>impl</literal> parameter of the
      <classname>AnalyzerDiscriminator</classname> you specify a concrete
      implementation of the <classname>Discriminator</classname> interface. It
      is up to you to provide an implementation for this interface. The only
      method you have to implement is
      <classname>getAnalyzerDefinitionName()</classname> which gets called for
      each field added to the Lucene document. The entity which is getting
      indexed is also passed to the interface method. The
      <literal>value</literal> parameter is only set if the
      <classname>AnalyzerDiscriminator</classname> is placed on property level
      instead of class level. In this case the value represents the current
      value of this property.</para>

      <para>An implemention of the <classname>Discriminator</classname>
      interface has to return the name of an existing analyzer definition or
      <classname>null</classname> if the default analyzer should not be
      overridden. <xref linkend="example-analyzer-discriminator" /> assumes
      that the language parameter is either 'de' or 'en' which matches the
      specified names in the <classname>@AnalyzerDef</classname>s.</para>
    </section>

    <section id="analyzer-retrievinganalyzer">
      <title>Retrieving an analyzer</title>

      <para>In some situations retrieving analyzers can be handy. For example,
      if your domain model makes use of multiple analyzers (maybe to benefit
      from stemming, use phonetic approximation and so on), you need to make
      sure to use the same analyzers when you build your query.</para>

      <note>
        <para>This rule can be broken but you need a good reason for it. If
        you are unsure, use the same analyzers. If you use the Hibernate
        Search query DSL (see <xref linkend="search-query-querydsl" />), you
        don't have to think about it. The query DSL does use the right
        analyzer transparently for you.</para>
      </note>

      <para>Whether you are using the Lucene programmatic API or the Lucene
      query parser, you can retrieve the scoped analyzer for a given entity. A
      scoped analyzer is an analyzer which applies the right analyzers
      depending on the field indexed. Remember, multiple analyzers can be
      defined on a given entity each one working on an individual field. A
      scoped analyzer unifies all these analyzers into a context-aware
      analyzer. While the theory seems a bit complex, using the right analyzer
      in a query is very easy.</para>

      <example>
        <title>Using the scoped analyzer when building a full-text
        query</title>

        <programlisting language="JAVA" role="JAVA">org.apache.lucene.queryParser.QueryParser parser = new QueryParser(
    "title", 
    fullTextSession.getSearchFactory().getAnalyzer( Song.class )
);

org.apache.lucene.search.Query luceneQuery = 
    parser.parse( "title:sky Or title_stemmed:diamond" );

org.hibernate.Query fullTextQuery = 
    fullTextSession.createFullTextQuery( luceneQuery, Song.class );

List result = fullTextQuery.list(); //return a list of managed objects    </programlisting>
      </example>

      <para>In the example above, the song title is indexed in two fields: the
      standard analyzer is used in the field <literal>title</literal> and a
      stemming analyzer is used in the field <literal>title_stemmed</literal>.
      By using the analyzer provided by the search factory, the query uses the
      appropriate analyzer depending on the field targeted.</para>

      <tip>
        <para>You can also retrieve analyzers defined via
        <classname>@AnalyzerDef</classname> by their definition name using
        <code>searchFactory.getAnalyzer(String)</code>.</para>
      </tip>
    </section>
  </section>

  <section id="search-mapping-bridge">
    <title>Bridges</title>

    <para>When discussing the basic mapping for an entity one important fact
    was so far disregarded. In Lucene all index fields have to be represented
    as strings. All entity properties annotated with <literal>@Field</literal>
    have to be converted to strings to be indexed. The reason we have not
    mentioned it so far is, that for most of your properties Hibernate Search
    does the translation job for you thanks to set of built-in bridges.
    However, in some cases you need a more fine grained control over the
    translation process.</para>

    <section>
      <title>Built-in bridges</title>

      <para>Hibernate Search comes bundled with a set of built-in bridges
      between a Java property type and its full text representation.</para>

      <variablelist>
        <varlistentry>
          <term>null</term>

          <listitem>
            <para>Per default <constant>null</constant> elements are not
            indexed. Lucene does not support null elements. However, in some
            situation it can be useful to insert a custom token representing
            the <constant>null</constant> value. See <xref lang=""
            linkend="field-annotation" /> for more information.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>java.lang.String</term>

          <listitem>
            <para>Strings are indexed as are</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>short, Short, integer, Integer, long, Long, float, Float,
          double, Double, BigInteger, BigDecimal</term>

          <listitem>
            <para>Numbers are converted into their string representation. Note
            that numbers cannot be compared by Lucene (ie used in ranged
            queries) out of the box: they have to be padded <note>
                <para>Using a Range query is debatable and has drawbacks, an
                alternative approach is to use a Filter query which will
                filter the result query to the appropriate range.</para>

                <para>Hibernate Search will support a padding mechanism</para>
              </note></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>java.util.Date</term>

          <listitem>
            <para>Dates are stored as yyyyMMddHHmmssSSS in GMT time
            (200611072203012 for Nov 7th of 2006 4:03PM and 12ms EST). You
            shouldn't really bother with the internal format. What is
            important is that when using a TermRangeQuery, you should know
            that the dates have to be expressed in GMT time.</para>

            <para>Usually, storing the date up to the millisecond is not
            necessary. <literal>@DateBridge</literal> defines the appropriate
            resolution you are willing to store in the index
            (<literal>@DateBridge(resolution=Resolution.DAY)</literal>). The
            date pattern will then be truncated accordingly.</para>

            <programlisting language="JAVA" role="JAVA">@Entity 
@Indexed
public class Meeting {
    @Field(analyze=Analyze.NO)
    <emphasis role="bold">@DateBridge(resolution=Resolution.MINUTE)</emphasis>
    private Date date;
    ...                 </programlisting>

            <warning>
              <para>A Date whose resolution is lower than
              <literal>MILLISECOND</literal> cannot be a
              <literal>@DocumentId</literal></para>
            </warning>

            <important>
              <para>The default <classname>Date</classname> bridge uses
              Lucene's <classname>DateTools</classname> to convert from and to
              <classname>String</classname>. This means that all dates are
              expressed in GMT time. If your requirements are to store dates
              in a fixed time zone you have to implement a custom date bridge.
              Make sure you understand the requirements of your applications
              regarding to date indexing and searching. </para>
            </important>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>java.net.URI, java.net.URL</term>

          <listitem>
            <para>URI and URL are converted to their string
            representation</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>java.lang.Class</term>

          <listitem>
            <para>Class are converted to their fully qualified class name. The
            thread context classloader is used when the class is
            rehydrated</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section>
      <title>Custom bridges</title>

      <para>Sometimes, the built-in bridges of Hibernate Search do not cover
      some of your property types, or the String representation used by the
      bridge does not meet your requirements. The following paragraphs
      describe several solutions to this problem.</para>

      <section>
        <title>StringBridge</title>

        <para>The simplest custom solution is to give Hibernate Search an
        implementation of your expected <classname>Object</classname> to
        <classname>String</classname> bridge. To do so you need to implement
        the <literal>org.hibernate.search.bridge.StringBridge</literal>
        interface. All implementations have to be thread-safe as they are used
        concurrently.</para>

        <example id="example-custom-string-bridge">
          <title>Custom <classname>StringBridge</classname>
          implementation</title>

          <programlisting language="JAVA" role="JAVA">/**
 * Padding Integer bridge.
 * All numbers will be padded with 0 to match 5 digits
 *
 * @author Emmanuel Bernard
 */
public class PaddedIntegerBridge implements <emphasis role="bold">StringBridge</emphasis> {

    private int PADDING = 5;

    <emphasis role="bold">public String objectToString(Object object)</emphasis> {
        String rawInteger = ( (Integer) object ).toString();
        if (rawInteger.length() &gt; PADDING) 
            throw new IllegalArgumentException( "Try to pad on a number too big" );
        StringBuilder paddedInteger = new StringBuilder( );
        for ( int padIndex = rawInteger.length() ; padIndex &lt; PADDING ; padIndex++ ) {
            paddedInteger.append('0');
        }
        return paddedInteger.append( rawInteger ).toString();
    }
}                </programlisting>
        </example>

        <para>Given the string bridge defined in <xref
        linkend="example-custom-string-bridge" />, any property or field can
        use this bridge thanks to the <literal>@FieldBridge</literal>
        annotation:</para>

        <programlisting language="JAVA" role="JAVA"><emphasis role="bold">@FieldBridge(impl = PaddedIntegerBridge.class)</emphasis>
private Integer length;                </programlisting>

        <section>
          <title>Parameterized bridge</title>

          <para>Parameters can also be passed to the bridge implementation
          making it more flexible. <xref
          linkend="example-passing-bridge-paremters" /> implements a
          <classname>ParameterizedBridge</classname> interface and parameters
          are passed through the <literal>@FieldBridge</literal>
          annotation.</para>

          <example id="example-passing-bridge-paremters">
            <title>Passing parameters to your bridge implementation</title>

            <programlisting language="JAVA" role="JAVA">public class PaddedIntegerBridge implements StringBridge, <emphasis
                role="bold">ParameterizedBridge</emphasis> {

    public static String PADDING_PROPERTY = "padding";
    private int padding = 5; //default

    <emphasis role="bold">public void setParameterValues(Map&lt;String,String&gt; parameters)</emphasis> {
        String padding = parameters.get( PADDING_PROPERTY );
        if (padding != null) this.padding = Integer.parseInt( padding );
    }

    public String objectToString(Object object) {
        String rawInteger = ( (Integer) object ).toString();
        if (rawInteger.length() &gt; padding) 
            throw new IllegalArgumentException( "Try to pad on a number too big" );
        StringBuilder paddedInteger = new StringBuilder( );
        for ( int padIndex = rawInteger.length() ; padIndex &lt; padding ; padIndex++ ) {
            paddedInteger.append('0');
        }
        return paddedInteger.append( rawInteger ).toString();
    }
}


//property
@FieldBridge(impl = PaddedIntegerBridge.class,
             <emphasis role="bold">params = @Parameter(name="padding", value="10")</emphasis>
            )
private Integer length;                </programlisting>
          </example>

          <para>The <classname>ParameterizedBridge</classname> interface can
          be implemented by <classname>StringBridge</classname>,
          <classname>TwoWayStringBridge</classname>,
          <classname>FieldBridge</classname> implementations.</para>

          <para>All implementations have to be thread-safe, but the parameters
          are set during initialization and no special care is required at
          this stage.</para>
        </section>

        <section>
          <title>Type aware bridge</title>

          <para>It is sometimes useful to get the type the bridge is applied
          on:</para>

          <itemizedlist>
            <listitem>
              <para>the return type of the property for field/getter-level
              bridges</para>
            </listitem>

            <listitem>
              <para>the class type for class-level bridges</para>
            </listitem>
          </itemizedlist>

          <para>An example is a bridge that deals with enums in a custom
          fashion but needs to access the actual enum type. Any bridge
          implementing <classname>AppliedOnTypeAwareBridge</classname> will
          get the type the bridge is applied on injected. Like parameters, the
          type injected needs no particular care with regard to
          thread-safety.</para>
        </section>

        <section>
          <title>Two-way bridge</title>

          <para>If you expect to use your bridge implementation on an id
          property (ie annotated with <literal>@DocumentId</literal> ), you
          need to use a slightly extended version of
          <literal>StringBridge</literal> named
          <classname>TwoWayStringBridge</classname>. Hibernate Search needs to
          read the string representation of the identifier and generate the
          object out of it. There is no difference in the way the
          <literal>@FieldBridge</literal> annotation is used.</para>

          <example>
            <title>Implementing a TwoWayStringBridge usable for id
            properties</title>

            <programlisting language="JAVA" role="JAVA">public class PaddedIntegerBridge implements TwoWayStringBridge, ParameterizedBridge {

    public static String PADDING_PROPERTY = "padding";
    private int padding = 5; //default

    public void setParameterValues(Map parameters) {
        Object padding = parameters.get( PADDING_PROPERTY );
        if (padding != null) this.padding = (Integer) padding;
    }

    public String objectToString(Object object) {
        String rawInteger = ( (Integer) object ).toString();
        if (rawInteger.length() &gt; padding) 
            throw new IllegalArgumentException( "Try to pad on a number too big" );
        StringBuilder paddedInteger = new StringBuilder( );
        for ( int padIndex = rawInteger.length() ; padIndex &lt; padding ; padIndex++ ) {
            paddedInteger.append('0');
        }
        return paddedInteger.append( rawInteger ).toString();
    }

    <emphasis role="bold">public Object stringToObject(String stringValue)</emphasis> {
        return new Integer(stringValue);
    }
}


//id property
@DocumentId
@FieldBridge(impl = PaddedIntegerBridge.class,
             params = @Parameter(name="padding", value="10") 
private Integer id;
                </programlisting>
          </example>

          <important>
            <para>It is important for the two-way process to be idempotent (ie
            object = stringToObject( objectToString( object ) ) ).</para>
          </important>
        </section>
      </section>

      <section>
        <title>FieldBridge</title>

        <para>Some use cases require more than a simple object to string
        translation when mapping a property to a Lucene index. To give you the
        greatest possible flexibility you can also implement a bridge as a
        <classname>FieldBridge</classname>. This interface gives you a
        property value and let you map it the way you want in your Lucene
        <classname>Document</classname>. You can for example store a property
        in two different document fields. The interface is very similar in its
        concept to the Hibernate <classname>UserType</classname>s.</para>

        <example id="example-field-bridge">
          <title>Implementing the FieldBridge interface</title>

          <programlisting language="JAVA" role="JAVA">/**
 * Store the date in 3 different fields - year, month, day - to ease Range Query per
 * year, month or day (eg get all the elements of December for the last 5 years).
 * @author Emmanuel Bernard
 */
public class DateSplitBridge implements FieldBridge {
    private final static TimeZone GMT = TimeZone.getTimeZone("GMT");

    <emphasis role="bold">public void set(String name, Object value, Document document, 
                    LuceneOptions luceneOptions)</emphasis> {
        Date date = (Date) value;
        Calendar cal = GregorianCalendar.getInstance(GMT);
        cal.setTime(date);
        int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH) + 1;
        int day = cal.get(Calendar.DAY_OF_MONTH);
  
        // set year
        luceneOptions.addFieldToDocument(
            name + ".year",
            String.valueOf( year ),
            document );
  
        // set month and pad it if needed
        luceneOptions.addFieldToDocument(
            name + ".month",
            month &lt; 10 ? "0" : "" + String.valueOf( month ),
            document );
  
        // set day and pad it if needed
        luceneOptions.addFieldToDocument(
            name + ".day",
            day &lt; 10 ? "0" : "" + String.valueOf( day ),
            document );
    }
}

//property
<emphasis role="bold">@FieldBridge(impl = DateSplitBridge.class)</emphasis>
private Date date;                </programlisting>
        </example>

        <para>In <xref linkend="example-field-bridge" /> the fields are not
        added directly to Document. Instead the addition is delegated to the
        <classname>LuceneOptions</classname> helper; this helper will apply
        the options you have selected on <literal>@Field</literal>, like
        <literal>Store</literal> or <literal>TermVector</literal>, or apply
        the choosen <classname>@Boost</classname> value. It is especially
        useful to encapsulate the complexity of <literal>COMPRESS</literal>
        implementations. Even though it is recommended to delegate to
        <classname>LuceneOptions</classname> to add fields to the
        <classname>Document</classname>, nothing stops you from editing the
        <classname>Document</classname> directly and ignore the
        <classname>LuceneOptions</classname> in case you need to.</para>

        <tip>
          <para>Classes like <classname>LuceneOptions</classname> are created
          to shield your application from changes in Lucene API and simplify
          your code. Use them if you can, but if you need more flexibility
          you're not required to.</para>
        </tip>
      </section>

      <section>
        <title>ClassBridge</title>

        <para>It is sometimes useful to combine more than one property of a
        given entity and index this combination in a specific way into the
        Lucene index. The <classname>@ClassBridge</classname> respectively
        <classname>@ClassBridges</classname> annotations can be defined at
        class level (as opposed to the property level). In this case the
        custom field bridge implementation receives the entity instance as the
        value parameter instead of a particular property. Though not shown in
        <xref linkend="example-class-bridge" />,
        <classname>@ClassBridge</classname> supports the
        <methodname>termVector</methodname> attribute discussed in section
        <xref linkend="basic-mapping" />.</para>

        <example id="example-class-bridge">
          <title>Implementing a class bridge</title>

          <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
<emphasis role="bold">@ClassBridge</emphasis>(name="branchnetwork",
             store=Store.YES,
             impl = <emphasis role="bold">CatFieldsClassBridge.class</emphasis>,
             params = @Parameter( name="sepChar", value=" " ) )
public class Department {
    private int id;
    private String network;
    private String branchHead;
    private String branch;
    private Integer maxEmployees
    ...
}

public class CatFieldsClassBridge implements FieldBridge, ParameterizedBridge {
    private String sepChar;

    public void setParameterValues(Map parameters) {
        this.sepChar = (String) parameters.get( "sepChar" );
    }

    <emphasis role="bold">public void set(
        String name, Object value, Document document, LuceneOptions luceneOptions)</emphasis> {
        // In this particular class the name of the new field was passed
        // from the name field of the ClassBridge Annotation. This is not
        // a requirement. It just works that way in this instance. The
        // actual name could be supplied by hard coding it below.
        Department dep = (Department) value;
        String fieldValue1 = dep.getBranch();
        if ( fieldValue1 == null ) {
            fieldValue1 = "";
        }
        String fieldValue2 = dep.getNetwork();
        if ( fieldValue2 == null ) {
            fieldValue2 = "";
        }
        String fieldValue = fieldValue1 + sepChar + fieldValue2;
        Field field = new Field( name, fieldValue, luceneOptions.getStore(),
            luceneOptions.getIndex(), luceneOptions.getTermVector() );
        field.setBoost( luceneOptions.getBoost() );
        document.add( field );
   }
}</programlisting>
        </example>

        <para>In this example, the particular
        <classname>CatFieldsClassBridge</classname> is applied to the
        <literal>department</literal> instance, the field bridge then
        concatenate both branch and network and index the
        concatenation.</para>
      </section>
    </section>
  </section>

  <section id="provided-id">
    <title>Providing your own id</title>

    <warning>
      <para>This part of the documentation is a work in progress.</para>
    </warning>

    <para>You can provide your own id for Hibernate Search if you are
    extending the internals. You will have to generate a unique value so it
    can be given to Lucene to be indexed. This will have to be given to
    Hibernate Search when you create an org.hibernate.search.Work object - the
    document id is required in the constructor.</para>

    <section id="ProvidedId">
      <title>The ProvidedId annotation</title>

      <para>Unlike <classname>@DocumentId</classname>which is applied on field
      level, <classname>@ProvidedId</classname> is used on the class level.
      Optionally you can specify your own bridge implementation using the
      <constant>bridge</constant> property. Also, if you annotate a class with
      <classname>@ProvidedId</classname>, your subclasses will also get the
      annotation - but it is not done by using the
      java.lang.annotations.@Inherited. Be sure however, to
      <emphasis>not</emphasis> use this annotation with @DocumentId as your
      system will break.</para>

      <example>
        <title>Providing your own id</title>

        <programlisting language="JAVA" role="JAVA">@ProvidedId (bridge = org.my.own.package.MyCustomBridge)
@Indexed
public class MyClass{
    @Field
    String MyString;
    ...
}</programlisting>
      </example>
    </section>
  </section>

  <section id="hsearch-mapping-programmaticapi">
    <title>Programmatic API</title>

    <para><warning>
        <para>This feature is considered experimental. While stable code-wise,
        the API is subject to change in the future.</para>
      </warning>Although the recommended approach for mapping indexed entities
    is to use annotations, it is sometimes more convenient to use a different
    approach:</para>

    <itemizedlist>
      <listitem>
        <para>the same entity is mapped differently depending on deployment
        needs (customization for clients)</para>
      </listitem>

      <listitem>
        <para>some automatization process requires the dynamic mapping of many
        entities sharing common traits</para>
      </listitem>
    </itemizedlist>

    <para>While it has been a popular demand in the past, the Hibernate team
    never found the idea of an XML alternative to annotations appealing due to
    it's heavy duplication, lack of code refactoring safety, because it did
    not cover all the use case spectrum and because we are in the 21st century
    :)</para>

    <para>The idea of a programmatic API was much more appealing and has now
    become a reality. You can programmatically define your mapping using a
    programmatic API: you define entities and fields as indexable by using
    mapping classes which effectively mirror the annotation concepts in
    Hibernate Search. Note that fan(s) of XML approach can design their own
    schema and use the programmatic API to create the mapping while parsing
    the XML stream.</para>

    <para>In order to use the programmatic model you must first construct a
    <classname>SearchMapping</classname> object which you can do in two
    ways:</para>

    <itemizedlist>
      <listitem>
        <para>directly</para>
      </listitem>

      <listitem>
        <para>via a factory</para>
      </listitem>
    </itemizedlist>

    <para>You can pass the <classname>SearchMapping</classname> object
    directly via the property key
    <literal>hibernate.search.model_mapping</literal> or its type-safe
    representation <classname>Environment.MODEL_MAPPING</classname>. Use the
    <classname>Configuration</classname> API or the Map passed to the JPA
    <classname>Persistence</classname> bootstrap methods.</para>

    <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();
[...]
configuration.setProperty( Environment.MODEL_MAPPING, mapping );

//or in JPA
SearchMapping mapping = new SearchMapping();
[...]
Map&lt;String,String&gt; properties = new HashMap&lt;String,String)(1);
properties.put( Environment.MODEL_MAPPING, mapping );
EntityManagerFactory emf = Persistence.createEntityManagerFactory( "userPU", properties );</programlisting>

    <para>Alternatively, you can create a factory class (ie. hosting a method
    annotated with <classname>@Factory</classname>) whose factory method
    returns the <classname>SearchMapping</classname> object. The factory class
    must have a no-arg constructor and its fully qualified class name is
    passed to the property key
    <literal>hibernate.search.model_mapping</literal> or its type-safe
    representation <classname>Environment.MODEL_MAPPING</classname>. This
    approach is useful when you do not necessarily control the bootstrap
    process like in a Java EE, CDI or Spring Framework container.</para>

    <example>
      <title>Use a mapping factory</title>

      <programlisting language="JAVA" role="JAVA">public class MyAppSearchMappingFactory {
    @Factory
    public SearchMapping getSearchMapping() {
        SearchMapping mapping = new SearchMapping();
        mapping
                .analyzerDef( "ngram", StandardTokenizerFactory.class )
                    .filter( LowerCaseFilterFactory.class )
                    .filter( NGramFilterFactory.class )
                        .param( "minGramSize", "3" )
                        .param( "maxGramSize", "3" );
        return mapping;
    }
}</programlisting>

      <programlisting language="XML" role="XML">&lt;persistence ...&gt;
    &lt;persistence-unit name="users"&gt;
        ...
        &lt;properties&gt;
            &lt;property name="hibernate.search.model_mapping"
                      value="com.acme.MyAppSearchMappingFactory"/&gt;
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;</programlisting>
    </example>

    <para>The <classname>SearchMapping</classname> is the root object which
    contains all the necessary indexable entities and fields. From there, the
    <classname>SearchMapping</classname> object exposes a fluent (and thus
    intuitive) API to express your mappings: it contextually exposes the
    relevant mapping options in a type-safe way. Just let your IDE
    autocompletion feature guide you through.</para>

    <para>Today, the programmatic API cannot be used on a class annotated with
    Hibernate Search annotations, chose one approach or the other. Also note
    that the same default values apply in annotations and the programmatic
    API. For example, the <methodname>@Field.name</methodname> is defaulted to
    the property name and does not have to be set.</para>

    <para>Each core concept of the programmatic API has a corresponding
    example to depict how the same definition would look using annotation.
    Therefore seeing an annotation example of the programmatic approach should
    give you a clear picture of what Hibernate Search will build with the
    marked entities and associated properties.</para>

    <section>
      <title>Mapping an entity as indexable</title>

      <para>The first concept of the programmatic API is to define an entity
      as indexable. Using the annotation approach a user would mark the entity
      as <classname>@Indexed</classname>, the following example demonstrates
      how to programmatically achieve this.</para>

      <example>
        <title>Marking an entity indexable</title>

        <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();

mapping.entity(Address.class)
           .indexed()
               .indexName("Address_Index"); //optional

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</programlisting>
      </example>

      <para>As you can see you must first create a
      <classname>SearchMapping</classname> object which is the root object
      that is then passed to the <classname>Configuration</classname> object
      as property. You must declare an entity and if you wish to make that
      entity as indexable then you must call the
      <methodname>indexed()</methodname> method. The <methodname>indexed()
      </methodname>method has an optional <methodname>indexName(String
      indexName)</methodname> which can be used to change the default index
      name that is created by Hibernate Search. Using the annotation model the
      above can be achieved as:</para>

      <example>
        <title>Annotation example of indexing entity</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed(index="Address_Index")
public class Address {
....
}</programlisting>
      </example>
    </section>

    <section>
      <title>Adding DocumentId to indexed entity</title>

      <para>To set a property as a document id:</para>

      <example>
        <title>Enabling document id with programmatic model</title>

        <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();

mapping.entity(Address.class).indexed()
           .property("addressId", ElementType.FIELD) //field access
               .documentId()
                   .name("id");

cfg.getProperties().put( "hibernate.search.model_mapping", mapping);</programlisting>
      </example>

      <para>The above is equivalent to annotating a property in the entity as
      <classname>@DocumentId</classname> as seen in the following
      example:</para>

      <example>
        <title>DocumentId annotation definition</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public class Address {
 @Id
 @GeneratedValue
 @DocumentId(name="id")
 private Long addressId;

 ....
}</programlisting>

        <para>The next section demonstrates how to programmatically define
        analyzers.</para>
      </example>
    </section>

    <section>
      <title>Defining analyzers</title>

      <para>Analyzers can be programmatically defined using the
      <methodname>analyzerDef(String analyzerDef, Class&lt;? extends
      TokenizerFactory&gt; tokenizerFactory) </methodname>method. This method
      also enables you to define filters for the analyzer definition. Each
      filter that you define can optionally take in parameters as seen in the
      following example :</para>

      <example>
        <title>Defining analyzers using programmatic model</title>

        <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    <emphasis role="bold">.analyzerDef( "ngram", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( NGramFilterFactory.class )
            .param( "minGramSize", "3" )
            .param( "maxGramSize", "3" )
    .analyzerDef( "en", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( EnglishPorterFilterFactory.class )
    .analyzerDef( "de", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( GermanStemFilterFactory.class )</emphasis>
    .entity(Address.class).indexed()
        .property("addressId", ElementType.METHOD) //getter access
            .documentId()
                .name("id");

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</programlisting>
      </example>

      <para>The analyzer mapping defined above is equivalent to the annotation
      model using <classname>@AnalyzerDef</classname> in conjunction with
      <classname>@AnalyzerDefs</classname>:</para>

      <example>
        <title>Analyzer definition using annotation</title>

        <programlisting language="JAVA" role="JAVA">@Indexed
@Entity
@AnalyzerDefs({
  @AnalyzerDef(name = "ngram",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = NGramFilterFactory.class, 
        params = {
          @Parameter(name = "minGramSize",value = "3"),
          @Parameter(name = "maxGramSize",value = "3") 
       })
   }),
  @AnalyzerDef(name = "en",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = EnglishPorterFilterFactory.class)
   }),

  @AnalyzerDef(name = "de",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = GermanStemFilterFactory.class)
  })

})
public class Address {
...
}</programlisting>
      </example>
    </section>

    <section>
      <title>Defining full text filter definitions</title>

      <para>The programmatic API provides easy mechanism for defining full
      text filter definitions which is available via
      <classname>@FullTextFilterDef</classname> and
      <classname>@FullTextFilterDefs</classname> (see <xref
      linkend="query-filter" />). The next example depicts the creation of
      full text filter definition using the <methodname>fullTextFilterDef
      </methodname>method.</para>

      <example>
        <title>Defining full text definition programmatically</title>

        <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .analyzerDef( "en", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( EnglishPorterFilterFactory.class )
    <emphasis role="bold">.fullTextFilterDef("security", SecurityFilterFactory.class)
            .cache(FilterCacheModeType.INSTANCE_ONLY)</emphasis>
    .entity(Address.class)
        .indexed()
        .property("addressId", ElementType.METHOD)
            .documentId()
                .name("id")
        .property("street1", ElementType.METHOD)
            .field()
                .analyzer("en")
                .store(Store.YES)
            .field()
                .name("address_data")
                .analyzer("en")
                .store(Store.NO);

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</programlisting>
      </example>

      <para>The previous example can effectively been seen as annotating your
      entity with <classname>@FullTextFilterDef</classname> like below:</para>

      <example>
        <title>Using annotation to define full text filter definition</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
@AnalyzerDefs({
  @AnalyzerDef(name = "en",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = EnglishPorterFilterFactory.class)
   })
})
@FullTextFilterDefs({
 @FullTextFilterDef(name = "security", impl = SecurityFilterFactory.class, cache = FilterCacheModeType.INSTANCE_ONLY)
})
public class Address {
 
 @Id
 @GeneratedValue
 @DocumentId(name="id")
 pubblic Long getAddressId() {...};

 @Fields({
      @Field(store=Store.YES, analyzer=@Analyzer(definition="en")),
      @Field(name="address_data", analyzer=@Analyzer(definition="en"))
 })
 public String getAddress1() {...};

 ......
 
}</programlisting>
      </example>
    </section>

    <section>
      <title>Defining fields for indexing</title>

      <para>When defining fields for indexing using the programmatic API, call
      <methodname>field()</methodname> on the <methodname>property(String
      propertyName, ElementType elementType)</methodname> method. From
      <methodname>field()</methodname> you can specify the <methodname>name,
      index</methodname>, <methodname>store</methodname>,
      <methodname>bridge</methodname> and <methodname>analyzer</methodname>
      definitions.</para>

      <example>
        <title>Indexing fields using programmatic API</title>

        <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .analyzerDef( "en", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( EnglishPorterFilterFactory.class )
    .entity(Address.class).indexed()
        .property("addressId", ElementType.METHOD)
            .documentId()
                .name("id")
        .property("street1", ElementType.METHOD)
            <emphasis role="bold">.field()
                .analyzer("en")
                .store(Store.YES)
            .field()
                .name("address_data")
                .analyzer("en");</emphasis>

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</programlisting>
      </example>

      <para>The above example of marking fields as indexable is equivalent to
      defining fields using <classname>@Field</classname> as seen
      below:</para>

      <example>
        <title>Indexing fields using annotation</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
@AnalyzerDefs({
  @AnalyzerDef(name = "en",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = EnglishPorterFilterFactory.class)
   })
})
public class Address {
 
 @Id
 @GeneratedValue
 @DocumentId(name="id")
 private Long getAddressId() {...};

 @Fields({
      @Field(store=Store.YES, analyzer=@Analyzer(definition="en")),
      @Field(name="address_data", analyzer=@Analyzer(definition="en"))
 })
 public String getAddress1() {...}

 ......
}</programlisting>
      </example>
    </section>

    <section>
      <title>Programmatically defining embedded entities</title>

      <para>In this section you will see how to programmatically define
      entities to be embedded into the indexed entity similar to using the
      <classname>@IndexedEmbedded</classname> model. In order to define this you
      must mark the property as <methodname>indexEmbedded.</methodname>There
      is the option to add a prefix to the embedded entity definition which
      can be done by calling <methodname>prefix</methodname> as seen in the
      example below:</para>

      <example>
        <title>Programmatically defining embedded entites</title>

        <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .entity(ProductCatalog.class)
        .indexed()
        .property("catalogId", ElementType.METHOD)
            .documentId()
                .name("id")
        .property("title", ElementType.METHOD)
            .field()
                .index(Index.YES)
                .store(Store.NO)
        .property("description", ElementType.METHOD)
             .field()
                 .index(Index.YES)
                 .store(Store.NO)
        .property("items", ElementType.METHOD)
            <emphasis role="bold">.indexEmbedded()
                .prefix("catalog.items"); //optional</emphasis>

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</programlisting>
      </example>

      <para>The next example shows the same definition using annotation
      (<classname>@IndexedEmbedded</classname>):</para>

      <example>
        <title>Using @IndexedEmbedded</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public class ProductCatalog {
 @Id
 @GeneratedValue
 @DocumentId(name="id")
 public Long getCatalogId() {...}
 
 @Field
 public String getTitle() {...}

 @Field
 public String getDescription();
 
 @OneToMany(fetch = FetchType.LAZY)
 @IndexColumn(name = "list_position")
 @Cascade(org.hibernate.annotations.CascadeType.ALL)
 @IndexedEmbedded(prefix="catalog.items")
 public List&lt;Item&gt; getItems() {...}

 ...

}</programlisting>
      </example>
    </section>

    <section>
      <title>Contained In definition</title>

      <para><classname>@ContainedIn</classname> can be define as seen in the
      example below:</para>

      <example>
        <title>Programmatically defining ContainedIn</title>

        <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .entity(ProductCatalog.class)
        .indexed()
        .property("catalogId", ElementType.METHOD)
            .documentId()
        .property("title", ElementType.METHOD)
            .field()
        .property("description", ElementType.METHOD)
            .field()
        .property("items", ElementType.METHOD)
            .indexEmbedded()

    .entity(Item.class)
        .property("description", ElementType.METHOD)
            .field()
        .property("productCatalog", ElementType.METHOD)
            <emphasis role="bold">.containedIn()</emphasis>;

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</programlisting>
      </example>

      <para>This is equivalent to defining <classname>@ContainedIn</classname>
      in your entity:</para>

      <example>
        <title>Annotation approach for ContainedIn</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public class ProductCatalog {
 
 @Id
 @GeneratedValue
 @DocumentId
 public Long getCatalogId() {...}
 
 @Field
 public String getTitle() {...}

 @Field
 public String getDescription() {...}
 
 @OneToMany(fetch = FetchType.LAZY)
 @IndexColumn(name = "list_position")
 @Cascade(org.hibernate.annotations.CascadeType.ALL)
 @IndexedEmbedded
 private List&lt;Item&gt; getItems() {...}

 ...
}

@Entity
public class Item {
 
 @Id
 @GeneratedValue
 private Long itemId;

 @Field
 public String getDescription() {...}
 
 @ManyToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )
 @ContainedIn
 public ProductCatalog getProductCatalog() {...}

 ...
}</programlisting>
      </example>
    </section>

    <section>
      <title>Date/Calendar Bridge</title>

      <para>In order to define a calendar or date bridge mapping, call the
      <methodname>dateBridge(Resolution resolution) </methodname>or
      <methodname>calendarBridge(Resolution resolution)</methodname> methods
      after you have defined a <methodname>field()</methodname> in the
      <classname>SearchMapping </classname>hierarchy.</para>

      <example>
        <title>Programmatic model for defining calendar/date bridge</title>

        <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .entity(Address.class)
        .indexed()
        .property("addressId", ElementType.FIELD)
            .documentId()
    .property("street1", ElementType.FIELD()
        .field()
    .property("createdOn", ElementType.FIELD)
        .field()
        <emphasis role="bold">.dateBridge(Resolution.DAY)</emphasis>
    .property("lastUpdated", ElementType.FIELD)
        <emphasis role="bold">.calendarBridge(Resolution.DAY)</emphasis>;

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</programlisting>
      </example>

      <para>See below for defining the above using
      <classname>@CalendarBridge</classname> and
      <classname>@DateBridge</classname>:</para>

      <example>
        <title>@CalendarBridge and @DateBridge definition</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public class Address {
 
 @Id
 @GeneratedValue
 @DocumentId
 private Long addressId;

 @Field
 private String address1;

 @Field
 @DateBridge(resolution=Resolution.DAY)
 private Date createdOn;

 @CalendarBridge(resolution=Resolution.DAY)
 private Calendar lastUpdated;

 ...
}</programlisting>
      </example>
    </section>

    <section>
      <title>Defining bridges</title>

      <para>It is possible to associate bridges to programmatically defined
      fields. When you define a <methodname>field()</methodname>
      programmatically you can use the <methodname>bridge(Class&lt;?&gt;
      impl)</methodname> to associate a <classname>FieldBridge
      </classname>implementation class. The bridge method also provides
      optional methods to include any parameters required for the bridge
      class. The below shows an example of programmatically defining a
      bridge:</para>

      <example>
        <title>Defining field bridges programmatically</title>

        <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .entity(Address.class)
        .indexed()
        .property("addressId", ElementType.FIELD)
            .documentId()
        .property("street1", ElementType.FIELD)
            .field()
            .field()
                .name("street1_abridged")
                <emphasis role="bold">.bridge( ConcatStringBridge.class )
                    .param( "size", "4" )</emphasis>;
 
cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</programlisting>
      </example>

      <para>The above can equally be defined using annotations, as seen in the
      next example.</para>

      <example>
        <title>Defining field bridges using annotation</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public class Address {
 
 @Id
 @GeneratedValue
 @DocumentId(name="id")
 private Long addressId;

 @Fields({
      @Field,
      @Field(name="street1_abridged", 
             bridge = @FieldBridge( impl = ConcatStringBridge.class, 
             params = @Parameter( name="size", value="4" ))
 })
 private String address1;

 ...
}</programlisting>
      </example>
    </section>

    <section>
      <title>Mapping class bridge</title>

      <para>You can define class bridges on entities programmatically. This is
      shown in the next example:</para>

      <example>
        <title>Defining class briges using API</title>

        <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .entity(Departments.class)
<emphasis>       .classBridge(CatDeptsFieldsClassBridge.class)
         .name("branchnetwork")
         .index(Index.YES)
         .store(Store.YES)
         .param("sepChar", " ")
      .classBridge(EquipmentType.class)
         .name("equiptype")
         .index(Index.YES)
         .store(Store.YES)
         .param("C", "Cisco")
         .param("D", "D-Link")
         .param("K", "Kingston")
         .param("3", "3Com")</emphasis>
      .indexed();

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );

</programlisting>
      </example>

      <para>The above is similar to using <classname>@ClassBridge
      </classname>as seen in the next example:</para>

      <example>
        <title>Using @ClassBridge</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
@ClassBridges ( {
  @ClassBridge(name="branchnetwork",
     store= Store.YES,
     impl = CatDeptsFieldsClassBridge.class,
     params = @Parameter( name="sepChar", value=" " ) ),
  @ClassBridge(name="equiptype",
     store= Store.YES,
     impl = EquipmentType.class,
     params = {@Parameter( name="C", value="Cisco" ),
        @Parameter( name="D", value="D-Link" ),
        @Parameter( name="K", value="Kingston" ),
        @Parameter( name="3", value="3Com" )
   })
})
public class Departments {

....
}</programlisting>
      </example>
    </section>

    <section>
      <title>Mapping dynamic boost</title>

      <para>You can apply a dynamic boost factor on either a field or a whole
      entity:</para>

      <example>
        <title>DynamicBoost mapping using programmatic model</title>

        <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();

mapping
  .entity(DynamicBoostedDescLibrary.class)
   .indexed()
   <emphasis>.dynamicBoost(CustomBoostStrategy.class)</emphasis>
  .property("libraryId", ElementType.FIELD)
    .documentId().name("id")
  .property("name", ElementType.FIELD)
    <emphasis>.dynamicBoost(CustomFieldBoostStrategy.class)</emphasis>;
    .field()
      .store(Store.YES)

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</programlisting>
      </example>

      <para>The next example shows the equivalent mapping using the
      <classname>@DynamicBoost</classname> annotation:</para>

      <example>
        <title>Using the @DynamicBoost</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
@DynamicBoost(impl = CustomBoostStrategy.class)
public class DynamicBoostedDescriptionLibrary {

 @Id
 @GeneratedValue
 @DocumentId
 private int id;

 private float dynScore;
 
 @Field(store = Store.YES)
 @DynamicBoost(impl = CustomFieldBoostStrategy.class)
 private String name;

 public DynamicBoostedDescriptionLibrary() {
  dynScore = 1.0f;
 }
  
 .......
}</programlisting>
      </example>
    </section>
  </section>
</chapter>
