diff --git a/main/java/org/hibernate/search/mapper/orm/bootstrap/impl/HibernateSearchIntegrator.java b/main/java/org/hibernate/search/mapper/orm/bootstrap/impl/HibernateSearchIntegrator.java
index 15485e0ce1..7645e7bb21 100644
--- a/main/java/org/hibernate/search/mapper/orm/bootstrap/impl/HibernateSearchIntegrator.java
+++ b/main/java/org/hibernate/search/mapper/orm/bootstrap/impl/HibernateSearchIntegrator.java
@@ -12,7 +12,6 @@
 
 import org.hibernate.boot.Metadata;
 import org.hibernate.boot.spi.BootstrapContext;
-import org.hibernate.boot.spi.MetadataImplementor;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.search.mapper.orm.common.impl.HibernateOrmUtils;
@@ -29,19 +28,16 @@
 public class HibernateSearchIntegrator implements Integrator {
 
 	@Override
-	public void integrate(Metadata metadata, SessionFactoryImplementor sessionFactory,
-			SessionFactoryServiceRegistry serviceRegistry) {
+	public void integrate(Metadata metadata, BootstrapContext bootstrapContext,
+			SessionFactoryImplementor sessionFactory) {
 		Optional<HibernateSearchPreIntegrationService> preIntegrationServiceOptional =
-				HibernateOrmUtils.getServiceOrEmpty( serviceRegistry, HibernateSearchPreIntegrationService.class );
+				HibernateOrmUtils.getServiceOrEmpty( bootstrapContext.getServiceRegistry(), HibernateSearchPreIntegrationService.class );
 
 		if ( !preIntegrationServiceOptional.isPresent() ) {
 			// Hibernate Search is disabled
 			return;
 		}
 
-		// TODO When we'll move to Hibernate ORM 6, use the bootstrapContext parameter passed to the integrate() method
-		BootstrapContext bootstrapContext = ( (MetadataImplementor) metadata ).getTypeConfiguration()
-				.getMetadataBuildingContext().getBootstrapContext();
 		HibernateOrmIntegrationBooterImpl booter =
 				new HibernateOrmIntegrationBooterImpl.BuilderImpl( metadata, bootstrapContext )
 						.build();
diff --git a/main/java/org/hibernate/search/mapper/orm/common/impl/HibernateOrmUtils.java b/main/java/org/hibernate/search/mapper/orm/common/impl/HibernateOrmUtils.java
index 66de4ebc40..d0c4c1dafe 100644
--- a/main/java/org/hibernate/search/mapper/orm/common/impl/HibernateOrmUtils.java
+++ b/main/java/org/hibernate/search/mapper/orm/common/impl/HibernateOrmUtils.java
@@ -17,14 +17,14 @@
 import jakarta.persistence.EntityManager;
 import jakarta.persistence.EntityManagerFactory;
 
-import org.hibernate.AssertionFailure;
 import org.hibernate.Session;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.mapping.Property;
-import org.hibernate.metamodel.spi.MetamodelImplementor;
-import org.hibernate.persister.entity.EntityPersister;
+import org.hibernate.metamodel.MappingMetamodel;
+import org.hibernate.metamodel.mapping.EntityMappingType;
 import org.hibernate.search.mapper.orm.logging.impl.Log;
+import org.hibernate.search.util.common.AssertionFailure;
 import org.hibernate.search.util.common.annotation.impl.SuppressForbiddenApis;
 import org.hibernate.search.util.common.logging.impl.LoggerFactory;
 import org.hibernate.service.Service;
@@ -66,25 +66,11 @@ public static SessionImplementor toSessionImplementor(EntityManager entityManage
 		}
 	}
 
-	private static boolean isSuperTypeOf(EntityPersister type1, EntityPersister type2) {
-		return type1.isSubclassEntityName( type2.getEntityName() );
+	private static boolean isSuperTypeOf(EntityMappingType type1, EntityMappingType type2) {
+		return type1.getSubclassEntityNames().contains( type2.getEntityName() );
 	}
 
-	public static EntityPersister toRootEntityType(SessionFactoryImplementor sessionFactory,
-			EntityPersister entityType) {
-		/*
-		 * We need to rely on Hibernate ORM's SPIs: this is complex stuff.
-		 * For example there may be class hierarchies such as A > B > C
-		 * where A and C are entity types and B is a mapped superclass.
-		 * So we need to exclude non-entity types, and for that we need the Hibernate ORM metamodel.
-		 */
-		MetamodelImplementor metamodel = sessionFactory.getMetamodel();
-		String rootEntityName = entityType.getRootEntityName();
-		return metamodel.entityPersister( rootEntityName );
-	}
-
-	public static EntityPersister toMostSpecificCommonEntitySuperType(MetamodelImplementor metamodel,
-			EntityPersister type1, EntityPersister type2) {
+	public static EntityMappingType toMostSpecificCommonEntitySuperType(EntityMappingType type1, EntityMappingType type2) {
 		/*
 		 * We need to rely on Hibernate ORM's SPIs: this is complex stuff.
 		 * For example there may be class hierarchies such as A > B > C
@@ -92,36 +78,32 @@ public static EntityPersister toMostSpecificCommonEntitySuperType(MetamodelImple
 		 * So even if we know the two types have a common superclass,
 		 * we need to skip non-entity superclasses, and for that we need the Hibernate ORM metamodel.
 		 */
-		EntityPersister superTypeCandidate = type1;
+		EntityMappingType superTypeCandidate = type1;
 		while ( superTypeCandidate != null && !isSuperTypeOf( superTypeCandidate, type2 ) ) {
-			String superSuperTypeEntityName = superTypeCandidate.getEntityMetamodel().getSuperclass();
-			superTypeCandidate = superSuperTypeEntityName == null
-					? null
-					: metamodel.entityPersister( superSuperTypeEntityName ).getEntityPersister();
+			superTypeCandidate = superTypeCandidate.getSuperMappingType();
 		}
 		if ( superTypeCandidate == null ) {
 			throw new AssertionFailure(
 					"Cannot find a common entity supertype for " + type1.getEntityName()
 							+ " and " + type2.getEntityName() + "."
-							+ " There is a bug in Hibernate Search, please report it."
 			);
 		}
 		return superTypeCandidate;
 	}
 
 	public static boolean targetsAllConcreteSubTypes(SessionFactoryImplementor sessionFactory,
-			EntityPersister parentType, Collection<?> targetConcreteSubTypes) {
-		@SuppressWarnings("unchecked")
-		Set<String> subClassEntityNames = parentType.getEntityMetamodel().getSubclassEntityNames();
+			EntityMappingType parentType, Collection<?> targetConcreteSubTypes) {
+		Set<String> subClassEntityNames = parentType.getSubclassEntityNames();
 		// Quick check to return true immediately if all subtypes are concrete
 		if ( subClassEntityNames.size() == targetConcreteSubTypes.size() ) {
 			return true;
 		}
 
-		MetamodelImplementor metamodel = sessionFactory.getMetamodel();
+		MappingMetamodel metamodel = sessionFactory.getMappingMetamodel();
 		int concreteSubTypesCount = 0;
 		for ( String subClassEntityName : subClassEntityNames ) {
-			if ( !metamodel.entityPersister( subClassEntityName ).getEntityMetamodel().isAbstract() ) {
+			EntityMappingType subclassType = metamodel.getEntityDescriptor( subClassEntityName );
+			if ( !subclassType.isAbstract() ) {
 				++concreteSubTypesCount;
 			}
 		}
@@ -133,7 +115,7 @@ public static <T extends Service> T getServiceOrFail(ServiceRegistry serviceRegi
 			Class<T> serviceClass) {
 		T service = serviceRegistry.getService( serviceClass );
 		if ( service == null ) {
-			throw new org.hibernate.search.util.common.AssertionFailure(
+			throw new AssertionFailure(
 					"A required service was missing. Missing service: " + serviceClass );
 		}
 		return service;
diff --git a/main/java/org/hibernate/search/mapper/orm/event/impl/HibernateSearchEventListener.java b/main/java/org/hibernate/search/mapper/orm/event/impl/HibernateSearchEventListener.java
index f5ea6d7742..b4a1e1eb8e 100644
--- a/main/java/org/hibernate/search/mapper/orm/event/impl/HibernateSearchEventListener.java
+++ b/main/java/org/hibernate/search/mapper/orm/event/impl/HibernateSearchEventListener.java
@@ -35,11 +35,13 @@
 import org.hibernate.event.spi.PostInsertEventListener;
 import org.hibernate.event.spi.PostUpdateEvent;
 import org.hibernate.event.spi.PostUpdateEventListener;
+import org.hibernate.metamodel.mapping.EntityMappingType;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.search.mapper.orm.common.impl.HibernateOrmUtils;
 import org.hibernate.search.mapper.orm.logging.impl.Log;
 import org.hibernate.search.mapper.pojo.work.spi.PojoIndexingPlan;
 import org.hibernate.search.mapper.pojo.work.spi.PojoTypeIndexingPlan;
+import org.hibernate.search.util.common.annotation.impl.SuppressForbiddenApis;
 import org.hibernate.search.util.common.logging.impl.LoggerFactory;
 
 /**
@@ -290,8 +292,8 @@ private PojoIndexingPlan getCurrentIndexingPlanIfExisting(SessionImplementor ses
 		return contextProvider.currentIndexingPlanIfExisting( sessionImplementor );
 	}
 
-	private HibernateOrmListenerTypeContext getTypeContextOrNull(EntityPersister entityPersister) {
-		String entityName = entityPersister.getEntityName();
+	private HibernateOrmListenerTypeContext getTypeContextOrNull(EntityMappingType entityMappingType) {
+		String entityName = entityMappingType.getEntityName();
 		return contextProvider.typeContextProvider().byHibernateOrmEntityName().getOrNull( entityName );
 	}
 
@@ -363,8 +365,8 @@ private void processCollectionEvent(AbstractCollectionEvent event) {
 	 * Required since Hibernate ORM 4.3
 	 */
 	@Override
-	@SuppressWarnings("deprecation") // Deprecated but abstract, so we have to implement it...
-	public boolean requiresPostCommitHanding(EntityPersister persister) {
+	@SuppressForbiddenApis(reason = "We are forced to implement this method and it requires accepting an EntityPersister")
+	public boolean requiresPostCommitHandling(EntityPersister persister) {
 		// TODO Tests seem to pass using _false_ but we might be able to take
 		// advantage of this new hook?
 		return false;
diff --git a/main/java/org/hibernate/search/mapper/orm/loading/impl/AbstractHibernateOrmLoadingStrategy.java b/main/java/org/hibernate/search/mapper/orm/loading/impl/AbstractHibernateOrmLoadingStrategy.java
index a17a46c893..45316ede5d 100644
--- a/main/java/org/hibernate/search/mapper/orm/loading/impl/AbstractHibernateOrmLoadingStrategy.java
+++ b/main/java/org/hibernate/search/mapper/orm/loading/impl/AbstractHibernateOrmLoadingStrategy.java
@@ -13,7 +13,7 @@
 import java.util.Set;
 
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.persister.entity.EntityPersister;
+import org.hibernate.metamodel.mapping.EntityMappingType;
 import org.hibernate.search.mapper.orm.common.impl.HibernateOrmUtils;
 import org.hibernate.search.mapper.orm.massindexing.impl.ConditionalExpression;
 import org.hibernate.search.util.common.AssertionFailure;
@@ -22,13 +22,13 @@ public abstract class AbstractHibernateOrmLoadingStrategy<E, I>
 		implements HibernateOrmEntityLoadingStrategy<E, I> {
 
 	private final SessionFactoryImplementor sessionFactory;
-	private final EntityPersister rootEntityPersister;
+	private final EntityMappingType rootEntityMappingType;
 	private final TypeQueryFactory<E, I> queryFactory;
 
 	AbstractHibernateOrmLoadingStrategy(SessionFactoryImplementor sessionFactory,
-			EntityPersister rootEntityPersister, TypeQueryFactory<E, I> queryFactory) {
+			EntityMappingType rootEntityMappingType, TypeQueryFactory<E, I> queryFactory) {
 		this.sessionFactory = sessionFactory;
-		this.rootEntityPersister = rootEntityPersister;
+		this.rootEntityMappingType = rootEntityMappingType;
 		this.queryFactory = queryFactory;
 	}
 
@@ -36,7 +36,7 @@ public abstract class AbstractHibernateOrmLoadingStrategy<E, I>
 	public HibernateOrmQueryLoader<E, I> createQueryLoader(
 			List<LoadingTypeContext<? extends E>> typeContexts, Optional<ConditionalExpression> conditionalExpression) {
 		Set<Class<? extends E>> includedTypesFilter;
-		if ( HibernateOrmUtils.targetsAllConcreteSubTypes( sessionFactory, rootEntityPersister, typeContexts ) ) {
+		if ( HibernateOrmUtils.targetsAllConcreteSubTypes( sessionFactory, rootEntityMappingType, typeContexts ) ) {
 			// All concrete types are included, no need to filter by type.
 			includedTypesFilter = Collections.emptySet();
 		}
@@ -52,9 +52,9 @@ public HibernateOrmQueryLoader<E, I> createQueryLoader(
 				throw new AssertionFailure( "conditional expression is always defined on a single type" );
 			}
 
-			EntityPersister entityPersister = typeContexts.get( 0 ).entityPersister();
+			EntityMappingType entityMappingType = typeContexts.get( 0 ).entityMappingType();
 			return new HibernateOrmQueryLoader<>(
-					queryFactory, entityPersister, includedTypesFilter, conditionalExpression.get() );
+					queryFactory, entityMappingType, includedTypesFilter, conditionalExpression.get() );
 		}
 		return new HibernateOrmQueryLoader<>( queryFactory, includedTypesFilter );
 	}
diff --git a/main/java/org/hibernate/search/mapper/orm/loading/impl/AbstractHibernateOrmSelectionEntityLoader.java b/main/java/org/hibernate/search/mapper/orm/loading/impl/AbstractHibernateOrmSelectionEntityLoader.java
index 4fa0ba9e1b..1dabd67a96 100644
--- a/main/java/org/hibernate/search/mapper/orm/loading/impl/AbstractHibernateOrmSelectionEntityLoader.java
+++ b/main/java/org/hibernate/search/mapper/orm/loading/impl/AbstractHibernateOrmSelectionEntityLoader.java
@@ -10,7 +10,7 @@
 
 import org.hibernate.QueryTimeoutException;
 import org.hibernate.exception.LockTimeoutException;
-import org.hibernate.persister.entity.EntityPersister;
+import org.hibernate.metamodel.mapping.EntityMappingType;
 import org.hibernate.query.Query;
 import org.hibernate.search.engine.common.timing.Deadline;
 import org.hibernate.search.mapper.orm.search.query.spi.HibernateOrmSearchQueryHints;
@@ -19,14 +19,14 @@
 abstract class AbstractHibernateOrmSelectionEntityLoader<E> implements PojoSelectionEntityLoader<E> {
 	protected static final String IDS_PARAMETER_NAME = "ids";
 
-	protected final EntityPersister entityPersister;
+	protected final EntityMappingType entityMappingType;
 	protected final LoadingSessionContext sessionContext;
 	protected final MutableEntityLoadingOptions loadingOptions;
 	protected final TypeQueryFactory<E, ?> queryFactory;
 
-	public AbstractHibernateOrmSelectionEntityLoader(EntityPersister entityPersister, TypeQueryFactory<E, ?> queryFactory,
+	public AbstractHibernateOrmSelectionEntityLoader(EntityMappingType entityMappingType, TypeQueryFactory<E, ?> queryFactory,
 			LoadingSessionContext sessionContext, MutableEntityLoadingOptions loadingOptions) {
-		this.entityPersister = entityPersister;
+		this.entityMappingType = entityMappingType;
 		this.sessionContext = sessionContext;
 		this.loadingOptions = loadingOptions;
 		this.queryFactory = queryFactory;
@@ -58,7 +58,7 @@ final Query<E> createQuery(int fetchSize, Long timeout) {
 			query.setHint( HibernateOrmSearchQueryHints.JAVAX_TIMEOUT, Math.toIntExact( timeout ) );
 		}
 
-		EntityGraphHint<?> entityGraphHint = loadingOptions.entityGraphHintOrNullForType( entityPersister );
+		EntityGraphHint<?> entityGraphHint = loadingOptions.entityGraphHintOrNullForType( entityMappingType );
 		if ( entityGraphHint != null ) {
 			query.applyGraph( entityGraphHint.graph, entityGraphHint.semantic );
 		}
diff --git a/main/java/org/hibernate/search/mapper/orm/loading/impl/ConditionalExpressionQueryFactory.java b/main/java/org/hibernate/search/mapper/orm/loading/impl/ConditionalExpressionQueryFactory.java
index 81fa041778..ec2dc3cfa2 100644
--- a/main/java/org/hibernate/search/mapper/orm/loading/impl/ConditionalExpressionQueryFactory.java
+++ b/main/java/org/hibernate/search/mapper/orm/loading/impl/ConditionalExpressionQueryFactory.java
@@ -9,35 +9,36 @@
 import java.util.Set;
 
 import org.hibernate.engine.spi.SharedSessionContractImplementor;
-import org.hibernate.persister.entity.EntityPersister;
+import org.hibernate.metamodel.mapping.EntityMappingType;
 import org.hibernate.query.Query;
 import org.hibernate.search.mapper.orm.massindexing.impl.ConditionalExpression;
 
 public abstract class ConditionalExpressionQueryFactory<E, I> implements TypeQueryFactory<E, I> {
 
 	private static final String TYPES_PARAM_NAME = "HIBERNATE_SEARCH_INCLUDED_TYPES_FILTER";
+	protected final Class<I> uniquePropertyType;
 	protected final String uniquePropertyName;
 
-	public ConditionalExpressionQueryFactory(String uniquePropertyName) {
+	public ConditionalExpressionQueryFactory(Class<I> uniquePropertyType, String uniquePropertyName) {
+		this.uniquePropertyType = uniquePropertyType;
 		this.uniquePropertyName = uniquePropertyName;
 	}
 
 	@Override
-	public Query<Long> createQueryForCount(SharedSessionContractImplementor session, EntityPersister persister,
+	public Query<Long> createQueryForCount(SharedSessionContractImplementor session, EntityMappingType entityMappingType,
 			Set<? extends Class<? extends E>> includedTypesFilter, ConditionalExpression conditionalExpression) {
 		return createQueryWithConditionalExpression( session,
-				"select count(e) from " + persister.getEntityName() + " e",
+				"select count(e) from " + entityMappingType.getEntityName() + " e",
 				Long.class, "e", includedTypesFilter, conditionalExpression
 		);
 	}
 
 	@Override
-	@SuppressWarnings("unchecked") // Can't do better here: EntityPersister has no generics
-	public Query<I> createQueryForIdentifierListing(SharedSessionContractImplementor session, EntityPersister persister,
+	public Query<I> createQueryForIdentifierListing(SharedSessionContractImplementor session, EntityMappingType entityMappingType,
 			Set<? extends Class<? extends E>> includedTypesFilter, ConditionalExpression conditionalExpression) {
 		return createQueryWithConditionalExpression( session,
-				"select e. " + uniquePropertyName + " from " + persister.getEntityName() + " e",
-				(Class<I>) persister.getIdentifierType().getReturnedClass(), "e",
+				"select e. " + uniquePropertyName + " from " + entityMappingType.getEntityName() + " e",
+				uniquePropertyType, "e",
 				includedTypesFilter, conditionalExpression
 		);
 	}
diff --git a/main/java/org/hibernate/search/mapper/orm/loading/impl/CriteriaTypeQueryFactory.java b/main/java/org/hibernate/search/mapper/orm/loading/impl/CriteriaTypeQueryFactory.java
index 0ad329e389..bdd92e70f1 100644
--- a/main/java/org/hibernate/search/mapper/orm/loading/impl/CriteriaTypeQueryFactory.java
+++ b/main/java/org/hibernate/search/mapper/orm/loading/impl/CriteriaTypeQueryFactory.java
@@ -26,16 +26,14 @@ class CriteriaTypeQueryFactory<E, I> extends ConditionalExpressionQueryFactory<E
 
 	public static <E> CriteriaTypeQueryFactory<E, ?> create(EntityDomainType<E> type,
 			String uniquePropertyName) {
-		return new CriteriaTypeQueryFactory<>( type, uniquePropertyName,
-				type.getSingularAttribute( uniquePropertyName ) );
+		return new CriteriaTypeQueryFactory<>( type, type.getSingularAttribute( uniquePropertyName ) );
 	}
 
 	private final EntityDomainType<E> type;
 	private final SingularAttribute<? super E, I> uniqueProperty;
 
-	private CriteriaTypeQueryFactory(EntityDomainType<E> type,
-			String uniquePropertyName, SingularAttribute<? super E, I> uniqueProperty) {
-		super( uniquePropertyName );
+	private CriteriaTypeQueryFactory(EntityDomainType<E> type, SingularAttribute<? super E, I> uniqueProperty) {
+		super( uniqueProperty.getJavaType(), uniqueProperty.getName() );
 		this.type = type;
 		this.uniqueProperty = uniqueProperty;
 	}
diff --git a/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmEntityIdEntityLoadingStrategy.java b/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmEntityIdEntityLoadingStrategy.java
index 8dea14d074..2280fb4fd4 100644
--- a/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmEntityIdEntityLoadingStrategy.java
+++ b/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmEntityIdEntityLoadingStrategy.java
@@ -12,8 +12,7 @@
 import org.hibernate.AssertionFailure;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.metamodel.spi.MetamodelImplementor;
-import org.hibernate.persister.entity.EntityPersister;
+import org.hibernate.metamodel.mapping.EntityMappingType;
 import org.hibernate.search.mapper.orm.common.impl.HibernateOrmUtils;
 import org.hibernate.search.mapper.orm.search.loading.EntityLoadingCacheLookupStrategy;
 import org.hibernate.search.mapper.pojo.loading.spi.PojoSelectionEntityLoader;
@@ -22,20 +21,20 @@ public class HibernateOrmEntityIdEntityLoadingStrategy<E, I>
 		extends AbstractHibernateOrmLoadingStrategy<E, I> {
 
 	public static HibernateOrmEntityLoadingStrategy<?, ?> create(SessionFactoryImplementor sessionFactory,
-			EntityPersister entityPersister) {
-		EntityPersister rootEntityPersister = HibernateOrmUtils.toRootEntityType( sessionFactory, entityPersister );
-		TypeQueryFactory<?, ?> queryFactory = TypeQueryFactory.create( sessionFactory, rootEntityPersister,
-				entityPersister.getIdentifierPropertyName() );
-		return new HibernateOrmEntityIdEntityLoadingStrategy<>( sessionFactory, rootEntityPersister, queryFactory );
+			EntityMappingType entityMappingType) {
+		EntityMappingType rootEntityMappingType = entityMappingType.getRootEntityDescriptor();
+		TypeQueryFactory<?, ?> queryFactory = TypeQueryFactory.create( sessionFactory, rootEntityMappingType,
+				entityMappingType.getIdentifierMapping().getAttributeName() );
+		return new HibernateOrmEntityIdEntityLoadingStrategy<>( sessionFactory, rootEntityMappingType, queryFactory );
 	}
 
-	private final EntityPersister rootEntityPersister;
+	private final EntityMappingType rootEntityMappingType;
 	private final TypeQueryFactory<E, I> queryFactory;
 
 	HibernateOrmEntityIdEntityLoadingStrategy(SessionFactoryImplementor sessionFactory,
-			EntityPersister rootEntityPersister, TypeQueryFactory<E, I> queryFactory) {
-		super( sessionFactory, rootEntityPersister, queryFactory );
-		this.rootEntityPersister = rootEntityPersister;
+			EntityMappingType rootEntityMappingType, TypeQueryFactory<E, I> queryFactory) {
+		super( sessionFactory, rootEntityMappingType, queryFactory );
+		this.rootEntityMappingType = rootEntityMappingType;
 		this.queryFactory = queryFactory;
 	}
 
@@ -47,12 +46,12 @@ public boolean equals(Object obj) {
 		HibernateOrmEntityIdEntityLoadingStrategy<?, ?> other = (HibernateOrmEntityIdEntityLoadingStrategy<?, ?>) obj;
 		// If the root entity type is different,
 		// the factories work in separate ID spaces and should be used separately.
-		return rootEntityPersister.equals( other.rootEntityPersister );
+		return rootEntityMappingType.equals( other.rootEntityMappingType );
 	}
 
 	@Override
 	public int hashCode() {
-		return rootEntityPersister.hashCode();
+		return rootEntityMappingType.hashCode();
 	}
 
 	@Override
@@ -69,13 +68,12 @@ public <E2> PojoSelectionEntityLoader<E2> createLoader(Set<LoadingTypeContext<?
 			 */
 			@SuppressWarnings("unchecked")
 			PojoSelectionEntityLoader<E2> result =
-					(PojoSelectionEntityLoader<E2>) doCreate( targetEntityTypeContext.entityPersister(), sessionContext,
+					(PojoSelectionEntityLoader<E2>) doCreate( targetEntityTypeContext.entityMappingType(), sessionContext,
 							cacheLookupStrategy, loadingOptions );
 			return result;
 		}
 
-		EntityPersister commonSuperType =
-				toMostSpecificCommonEntitySuperType( sessionContext.session(), targetEntityTypeContexts );
+		EntityMappingType commonSuperType = toMostSpecificCommonEntitySuperType( targetEntityTypeContexts );
 		if ( commonSuperType == null ) {
 			throw invalidTypesException( targetEntityTypeContexts );
 		}
@@ -99,12 +97,11 @@ public <E2> PojoSelectionEntityLoader<E2> createLoader(Set<LoadingTypeContext<?
 		return result;
 	}
 
-	@SuppressWarnings("unchecked") // Can't do better here: EntityPersister has no generics
-	private PojoSelectionEntityLoader<?> doCreate(EntityPersister entityPersister,
+	private PojoSelectionEntityLoader<?> doCreate(EntityMappingType entityMappingType,
 			LoadingSessionContext sessionContext, EntityLoadingCacheLookupStrategy cacheLookupStrategy,
 			MutableEntityLoadingOptions loadingOptions) {
-		if ( !rootEntityPersister.getMappedClass().isAssignableFrom( entityPersister.getMappedClass() ) ) {
-			throw invalidTypeException( entityPersister );
+		if ( !rootEntityMappingType.getJavaType().getJavaTypeClass().isAssignableFrom( entityMappingType.getJavaType().getJavaTypeClass() ) ) {
+			throw invalidTypeException( entityMappingType );
 		}
 
 		SessionImplementor session = sessionContext.session();
@@ -136,40 +133,38 @@ private PojoSelectionEntityLoader<?> doCreate(EntityPersister entityPersister,
 				// to avoid a WrongClassException when the type of an entity changes,
 				// because that exception cannot be recovered from.
 				cacheLookupStrategyImplementor =
-						PersistenceContextThenSecondLevelCacheLookupStrategy.create( rootEntityPersister, session );
+						PersistenceContextThenSecondLevelCacheLookupStrategy.create( rootEntityMappingType, session );
 				break;
 			default:
 				throw new AssertionFailure( "Unexpected cache lookup strategy: " + cacheLookupStrategy );
 		}
 
-		// We must pass rootEntityPersister here, to avoid getting a WrongClassException when loading from the cache,
-		// even if we know we actually want instances from the most specific entity persister,
+		// We must pass rootEntityMappingType here, to avoid getting a WrongClassException when loading from the cache,
+		// even if we know we actually want instances from the most specific entity type,
 		// because that exception cannot be recovered from.
-		return new HibernateOrmSelectionEntityByIdLoader<>( rootEntityPersister, queryFactory, sessionContext,
+		return new HibernateOrmSelectionEntityByIdLoader<>( rootEntityMappingType, queryFactory, sessionContext,
 				persistenceContextLookup, cacheLookupStrategyImplementor, loadingOptions );
 	}
 
-	private static EntityPersister toMostSpecificCommonEntitySuperType(SessionImplementor session,
-			Iterable<? extends LoadingTypeContext<?>> targetEntityTypeContexts) {
-		MetamodelImplementor metamodel = session.getSessionFactory().getMetamodel();
-		EntityPersister result = null;
+	private static EntityMappingType toMostSpecificCommonEntitySuperType(Iterable<? extends LoadingTypeContext<?>> targetEntityTypeContexts) {
+		EntityMappingType result = null;
 		for ( LoadingTypeContext<?> targetTypeContext : targetEntityTypeContexts ) {
-			EntityPersister type = targetTypeContext.entityPersister();
+			EntityMappingType type = targetTypeContext.entityMappingType();
 			if ( result == null ) {
 				result = type;
 			}
 			else {
-				result = HibernateOrmUtils.toMostSpecificCommonEntitySuperType( metamodel, result, type );
+				result = HibernateOrmUtils.toMostSpecificCommonEntitySuperType( result, type );
 			}
 		}
 		return result;
 	}
 
-	private AssertionFailure invalidTypeException(EntityPersister otherEntityPersister) {
+	private AssertionFailure invalidTypeException(EntityMappingType otherEntityMappingType) {
 		throw new AssertionFailure(
 				"The targeted entity type is not a subclass of the expected root entity type."
-						+ " Expected root entity name: " + rootEntityPersister.getEntityName()
-						+ " Targeted entity name: " + otherEntityPersister.getEntityName()
+						+ " Expected root entity name: " + rootEntityMappingType.getEntityName()
+						+ " Targeted entity name: " + otherEntityMappingType.getEntityName()
 		);
 	}
 
@@ -177,11 +172,11 @@ private AssertionFailure invalidTypesException(
 			Set<? extends LoadingTypeContext<?>> targetEntityTypeContexts) {
 		return new AssertionFailure(
 				"Some types among the targeted entity types are not subclasses of the expected root entity type."
-						+ " Expected entity name: " + rootEntityPersister.getEntityName()
+						+ " Expected entity name: " + rootEntityMappingType.getEntityName()
 						+ " Targeted entity names: "
 						+ targetEntityTypeContexts.stream()
-								.map( LoadingTypeContext::entityPersister )
-								.map( EntityPersister::getEntityName )
+								.map( LoadingTypeContext::entityMappingType )
+								.map( EntityMappingType::getEntityName )
 								.collect( Collectors.toList() )
 		);
 	}
diff --git a/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmMassEntityLoader.java b/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmMassEntityLoader.java
index bf4e8fd64a..87f96d8441 100644
--- a/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmMassEntityLoader.java
+++ b/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmMassEntityLoader.java
@@ -6,7 +6,6 @@
  */
 package org.hibernate.search.mapper.orm.loading.impl;
 
-import java.io.Serializable;
 import java.util.List;
 
 import org.hibernate.FlushMode;
@@ -56,12 +55,11 @@ public void load(List<I> identifiers) throws InterruptedException {
 		transactionHelper.commit( session );
 	}
 
-	@SuppressWarnings("unchecked") // We can assume identifiers are serializable
 	private List<E> multiLoad(List<I> identifiers) {
 		return typeQueryLoader.createMultiIdentifierLoadAccess( session )
 				.with( options.cacheMode() )
 				.with( LockOptions.NONE )
-				.multiLoad( (List<Serializable>) identifiers );
+				.multiLoad( identifiers );
 	}
 
 	private List<E> queryByIds(List<I> identifiers) {
diff --git a/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmMassIdentifierLoader.java b/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmMassIdentifierLoader.java
index 61cf2863dc..033ccecf9e 100644
--- a/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmMassIdentifierLoader.java
+++ b/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmMassIdentifierLoader.java
@@ -29,7 +29,7 @@ public final class HibernateOrmMassIdentifierLoader<E, I> implements PojoMassIde
 	private final TransactionHelper transactionHelper;
 	private final long totalCount;
 	private long totalLoaded = 0;
-	private final ScrollableResults results;
+	private final ScrollableResults<I> results;
 
 	public HibernateOrmMassIdentifierLoader(HibernateOrmQueryLoader<E, I> typeQueryLoader,
 			HibernateOrmMassLoadingOptions options,
@@ -88,8 +88,7 @@ public void loadNext() throws InterruptedException {
 		int batchSize = options.objectLoadingBatchSize();
 		ArrayList<I> destinationList = new ArrayList<>( batchSize );
 		while ( destinationList.size() < batchSize && totalLoaded < totalCount && results.next() ) {
-			@SuppressWarnings("unchecked")
-			I id = (I) results.get( 0 );
+			I id = results.get();
 			destinationList.add( id );
 			++totalLoaded;
 		}
diff --git a/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmNonEntityIdPropertyEntityLoadingStrategy.java b/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmNonEntityIdPropertyEntityLoadingStrategy.java
index ab527b92d3..48140e8931 100644
--- a/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmNonEntityIdPropertyEntityLoadingStrategy.java
+++ b/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmNonEntityIdPropertyEntityLoadingStrategy.java
@@ -12,7 +12,7 @@
 import java.util.stream.Collectors;
 
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.persister.entity.EntityPersister;
+import org.hibernate.metamodel.mapping.EntityMappingType;
 import org.hibernate.search.mapper.orm.logging.impl.Log;
 import org.hibernate.search.mapper.orm.search.loading.EntityLoadingCacheLookupStrategy;
 import org.hibernate.search.mapper.pojo.loading.spi.PojoSelectionEntityLoader;
@@ -26,30 +26,30 @@ public class HibernateOrmNonEntityIdPropertyEntityLoadingStrategy<E, I>
 	private static final Log log = LoggerFactory.make( Log.class, MethodHandles.lookup() );
 
 	public static <I> HibernateOrmEntityLoadingStrategy<?, ?> create(SessionFactoryImplementor sessionFactory,
-			EntityPersister entityPersister,
+			EntityMappingType entityMappingType,
 			String documentIdSourcePropertyName, ValueReadHandle<I> documentIdSourceHandle) {
 		// By contract, the documentIdSourceHandle and the documentIdSourcePropertyName refer to the same property,
 		// whose type is I.
 		@SuppressWarnings("unchecked")
 		TypeQueryFactory<?, I> queryFactory = (TypeQueryFactory<?, I>) TypeQueryFactory.create( sessionFactory,
-				entityPersister, documentIdSourcePropertyName );
+				entityMappingType, documentIdSourcePropertyName );
 		return new HibernateOrmNonEntityIdPropertyEntityLoadingStrategy<>( sessionFactory,
-				entityPersister, queryFactory,
+				entityMappingType, queryFactory,
 				documentIdSourcePropertyName, documentIdSourceHandle );
 	}
 
-	private final EntityPersister entityPersister;
+	private final EntityMappingType entityMappingType;
 	private final TypeQueryFactory<E, I> queryFactory;
 	private final String documentIdSourcePropertyName;
 	private final ValueReadHandle<?> documentIdSourceHandle;
 
 	private HibernateOrmNonEntityIdPropertyEntityLoadingStrategy(SessionFactoryImplementor sessionFactory,
-			EntityPersister entityPersister,
+			EntityMappingType entityMappingType,
 			TypeQueryFactory<E, I> queryFactory,
 			String documentIdSourcePropertyName,
 			ValueReadHandle<I> documentIdSourceHandle) {
-		super( sessionFactory, entityPersister, queryFactory );
-		this.entityPersister = entityPersister;
+		super( sessionFactory, entityMappingType, queryFactory );
+		this.entityMappingType = entityMappingType;
 		this.queryFactory = queryFactory;
 		this.documentIdSourcePropertyName = documentIdSourcePropertyName;
 		this.documentIdSourceHandle = documentIdSourceHandle;
@@ -64,14 +64,14 @@ public boolean equals(Object obj) {
 				(HibernateOrmNonEntityIdPropertyEntityLoadingStrategy<?, ?>) obj;
 		// If the entity type is different,
 		// the factories work in separate ID spaces and should be used separately.
-		return entityPersister.equals( other.entityPersister )
+		return entityMappingType.equals( other.entityMappingType )
 				&& documentIdSourcePropertyName.equals( other.documentIdSourcePropertyName )
 				&& documentIdSourceHandle.equals( other.documentIdSourceHandle );
 	}
 
 	@Override
 	public int hashCode() {
-		return Objects.hash( entityPersister, documentIdSourcePropertyName, documentIdSourceHandle );
+		return Objects.hash( entityMappingType, documentIdSourcePropertyName, documentIdSourceHandle );
 	}
 
 	@Override
@@ -89,17 +89,17 @@ private <E2> PojoSelectionEntityLoader<E2> doCreate(LoadingTypeContext<?> target
 			LoadingSessionContext sessionContext,
 			EntityLoadingCacheLookupStrategy cacheLookupStrategy,
 			MutableEntityLoadingOptions loadingOptions) {
-		if ( !entityPersister.equals( targetEntityTypeContext.entityPersister() ) ) {
-			throw invalidTypeException( targetEntityTypeContext.entityPersister() );
+		if ( !entityMappingType.equals( targetEntityTypeContext.entityMappingType() ) ) {
+			throw invalidTypeException( targetEntityTypeContext.entityMappingType() );
 		}
 
 		/*
-		 * We checked just above that "entityPersister" is equal to "targetEntityTypeContext.entityPersister()",
+		 * We checked just above that "entityMappingType" is equal to "targetEntityTypeContext.entityMappingType()",
 		 * so this loader will actually return entities of type E2.
 		 */
 		@SuppressWarnings("unchecked")
 		PojoSelectionEntityLoader<E2> result = new HibernateOrmSelectionEntityByNonIdPropertyLoader<>(
-				entityPersister, (LoadingTypeContext<E2>) targetEntityTypeContext,
+				entityMappingType, (LoadingTypeContext<E2>) targetEntityTypeContext,
 				(TypeQueryFactory<E2, ?>) queryFactory,
 				documentIdSourcePropertyName, documentIdSourceHandle,
 				sessionContext, loadingOptions
@@ -121,22 +121,22 @@ private <E2> PojoSelectionEntityLoader<E2> doCreate(LoadingTypeContext<?> target
 		return result;
 	}
 
-	private AssertionFailure invalidTypeException(EntityPersister otherEntityPersister) {
+	private AssertionFailure invalidTypeException(EntityMappingType otherEntityMappingType) {
 		throw new AssertionFailure(
 				"Attempt to use a criteria-based entity loader with an unexpected target entity type."
-						+ " Expected entity name: " + entityPersister.getEntityName()
-						+ " Targeted entity name: " + otherEntityPersister
+						+ " Expected entity name: " + entityMappingType.getEntityName()
+						+ " Targeted entity name: " + otherEntityMappingType.getEntityName()
 		);
 	}
 
 	private AssertionFailure multipleTypesException(Set<? extends LoadingTypeContext<?>> targetEntityTypeContexts) {
 		return new AssertionFailure(
 				"Attempt to use a criteria-based entity loader with multiple target entity types."
-						+ " Expected entity name: " + entityPersister.getEntityName()
+						+ " Expected entity name: " + entityMappingType.getEntityName()
 						+ " Targeted entity names: "
 						+ targetEntityTypeContexts.stream()
-								.map( LoadingTypeContext::entityPersister )
-								.map( EntityPersister::getEntityName )
+								.map( LoadingTypeContext::entityMappingType )
+								.map( EntityMappingType::getEntityName )
 								.collect( Collectors.toList() )
 		);
 	}
diff --git a/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmQueryLoader.java b/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmQueryLoader.java
index 44a8719126..83a8b93fb7 100644
--- a/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmQueryLoader.java
+++ b/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmQueryLoader.java
@@ -11,30 +11,30 @@
 import org.hibernate.MultiIdentifierLoadAccess;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.SharedSessionContractImplementor;
-import org.hibernate.persister.entity.EntityPersister;
+import org.hibernate.metamodel.mapping.EntityMappingType;
 import org.hibernate.query.Query;
 import org.hibernate.search.mapper.orm.massindexing.impl.ConditionalExpression;
 
 public class HibernateOrmQueryLoader<E, I> {
 	private final TypeQueryFactory<E, I> queryFactory;
 	private final Set<Class<? extends E>> includedTypesFilter;
-	private final EntityPersister persister;
+	private final EntityMappingType entityMappingType;
 	private final ConditionalExpression conditionalExpression;
 
 	public HibernateOrmQueryLoader(TypeQueryFactory<E, I> queryFactory,
 			Set<Class<? extends E>> includedTypesFilter) {
 		this.queryFactory = queryFactory;
 		this.includedTypesFilter = includedTypesFilter;
-		this.persister = null;
+		this.entityMappingType = null;
 		this.conditionalExpression = null;
 	}
 
 	public HibernateOrmQueryLoader(TypeQueryFactory<E, I> queryFactory,
-			EntityPersister persister, Set<Class<? extends E>> includedTypesFilter,
+			EntityMappingType entityMappingType, Set<Class<? extends E>> includedTypesFilter,
 			ConditionalExpression conditionalExpression) {
 		this.queryFactory = queryFactory;
 		this.includedTypesFilter = includedTypesFilter;
-		this.persister = persister;
+		this.entityMappingType = entityMappingType;
 		this.conditionalExpression = conditionalExpression;
 	}
 
@@ -42,7 +42,7 @@ public Query<Long> createCountQuery(SharedSessionContractImplementor session) {
 		return ( conditionalExpression == null )
 				? queryFactory.createQueryForCount( session, includedTypesFilter )
 				: queryFactory.createQueryForCount(
-						session, persister, includedTypesFilter, conditionalExpression
+						session, entityMappingType, includedTypesFilter, conditionalExpression
 				);
 	}
 
@@ -50,7 +50,7 @@ public Query<I> createIdentifiersQuery(SharedSessionContractImplementor session)
 		return ( conditionalExpression == null )
 				? queryFactory.createQueryForIdentifierListing( session, includedTypesFilter )
 				: queryFactory.createQueryForIdentifierListing(
-						session, persister, includedTypesFilter, conditionalExpression
+						session, entityMappingType, includedTypesFilter, conditionalExpression
 				);
 	}
 
diff --git a/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmSelectionEntityByIdLoader.java b/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmSelectionEntityByIdLoader.java
index 8220212f46..3c20b4003b 100644
--- a/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmSelectionEntityByIdLoader.java
+++ b/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmSelectionEntityByIdLoader.java
@@ -6,13 +6,13 @@
  */
 package org.hibernate.search.mapper.orm.loading.impl;
 
-import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.hibernate.engine.spi.EntityKey;
-import org.hibernate.persister.entity.EntityPersister;
+import org.hibernate.metamodel.mapping.EntityMappingType;
 import org.hibernate.query.Query;
+import org.hibernate.search.util.common.annotation.impl.SuppressForbiddenApis;
 
 /**
  * An entity loader for indexed entities whose document ID is the entity ID.
@@ -24,12 +24,12 @@ class HibernateOrmSelectionEntityByIdLoader<E> extends AbstractHibernateOrmSelec
 	private final PersistenceContextLookupStrategy persistenceContextLookup;
 	private final EntityLoadingCacheLookupStrategyImplementor cacheLookupStrategyImplementor;
 
-	HibernateOrmSelectionEntityByIdLoader(EntityPersister rootEntityPersister,
+	HibernateOrmSelectionEntityByIdLoader(EntityMappingType rootEntityMappingType,
 			TypeQueryFactory<E, ?> queryFactory, LoadingSessionContext sessionContext,
 			PersistenceContextLookupStrategy persistenceContextLookup,
 			EntityLoadingCacheLookupStrategyImplementor cacheLookupStrategyImplementor,
 			MutableEntityLoadingOptions loadingOptions) {
-		super( rootEntityPersister, queryFactory, sessionContext, loadingOptions );
+		super( rootEntityMappingType, queryFactory, sessionContext, loadingOptions );
 		this.persistenceContextLookup = persistenceContextLookup;
 		this.cacheLookupStrategyImplementor = cacheLookupStrategyImplementor;
 	}
@@ -84,11 +84,12 @@ protected List<E> doLoadEntities(List<?> allIds, Long timeout) {
 		return loadedEntities;
 	}
 
+	@SuppressForbiddenApis(reason = "generateEntityKey requires passing an EntityPersister")
 	private EntityKey[] toEntityKeys(List<?> ids) {
 		EntityKey[] entityKeys = new EntityKey[ids.size()];
 		for ( int i = 0; i < ids.size(); i++ ) {
-			Serializable id = (Serializable) ids.get( i );
-			EntityKey entityKey = sessionContext.session().generateEntityKey( id, entityPersister );
+			Object id = ids.get( i );
+			EntityKey entityKey = sessionContext.session().generateEntityKey( id, entityMappingType.getEntityPersister() );
 			entityKeys[i] = ( entityKey );
 		}
 		return entityKeys;
diff --git a/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmSelectionEntityByNonIdPropertyLoader.java b/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmSelectionEntityByNonIdPropertyLoader.java
index 11409cad25..58b36111c5 100644
--- a/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmSelectionEntityByNonIdPropertyLoader.java
+++ b/main/java/org/hibernate/search/mapper/orm/loading/impl/HibernateOrmSelectionEntityByNonIdPropertyLoader.java
@@ -12,7 +12,7 @@
 import java.util.Map;
 
 import org.hibernate.Hibernate;
-import org.hibernate.persister.entity.EntityPersister;
+import org.hibernate.metamodel.mapping.EntityMappingType;
 import org.hibernate.query.Query;
 import org.hibernate.search.mapper.orm.logging.impl.Log;
 import org.hibernate.search.util.common.impl.CollectionHelper;
@@ -33,14 +33,14 @@ class HibernateOrmSelectionEntityByNonIdPropertyLoader<E> extends AbstractHibern
 	private final String documentIdSourcePropertyName;
 	private final ValueReadHandle<?> documentIdSourceHandle;
 
-	HibernateOrmSelectionEntityByNonIdPropertyLoader(EntityPersister entityPersister,
+	HibernateOrmSelectionEntityByNonIdPropertyLoader(EntityMappingType entityMappingType,
 			LoadingTypeContext<E> targetEntityTypeContext,
 			TypeQueryFactory<E, ?> queryFactory,
 			String documentIdSourcePropertyName,
 			ValueReadHandle<?> documentIdSourceHandle,
 			LoadingSessionContext sessionContext,
 			MutableEntityLoadingOptions loadingOptions) {
-		super( entityPersister, queryFactory, sessionContext, loadingOptions );
+		super( entityMappingType, queryFactory, sessionContext, loadingOptions );
 		this.targetEntityTypeContext = targetEntityTypeContext;
 		this.documentIdSourcePropertyName = documentIdSourcePropertyName;
 		this.documentIdSourceHandle = documentIdSourceHandle;
diff --git a/main/java/org/hibernate/search/mapper/orm/loading/impl/HqlTypeQueryFactory.java b/main/java/org/hibernate/search/mapper/orm/loading/impl/HqlTypeQueryFactory.java
index a43ff3c025..abebc0d505 100644
--- a/main/java/org/hibernate/search/mapper/orm/loading/impl/HqlTypeQueryFactory.java
+++ b/main/java/org/hibernate/search/mapper/orm/loading/impl/HqlTypeQueryFactory.java
@@ -11,56 +11,57 @@
 import org.hibernate.MultiIdentifierLoadAccess;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.SharedSessionContractImplementor;
-import org.hibernate.persister.entity.EntityPersister;
+import org.hibernate.metamodel.mapping.EntityMappingType;
 import org.hibernate.query.Query;
 
 class HqlTypeQueryFactory<E, I> extends ConditionalExpressionQueryFactory<E, I> {
 
-	private final EntityPersister entityPersister;
+	private final EntityMappingType entityMappingType;
 
-	HqlTypeQueryFactory(EntityPersister entityPersister, String uniquePropertyName) {
-		super( uniquePropertyName );
-		this.entityPersister = entityPersister;
+	@SuppressWarnings("unchecked") // Can't do better here: EntityMappingType has no generics
+	HqlTypeQueryFactory(EntityMappingType entityMappingType, String uniquePropertyName) {
+		super( uniquePropertyName.equals( entityMappingType.getIdentifierMapping().getAttributeName() )
+				? (Class<I>) entityMappingType.getIdentifierMapping().getJavaType().getJavaTypeClass()
+				: (Class<I>) entityMappingType.findAttributeMapping( uniquePropertyName ).getJavaType().getJavaTypeClass(),
+				uniquePropertyName );
+		this.entityMappingType = entityMappingType;
 	}
 
 	@Override
 	public Query<Long> createQueryForCount(SharedSessionContractImplementor session,
 			Set<? extends Class<? extends E>> includedTypesFilter) {
 		return createQueryWithTypesFilter( session,
-				"select count(e) from " + entityPersister.getEntityName() + " e",
+				"select count(e) from " + entityMappingType.getEntityName() + " e",
 				Long.class,
 				"e", includedTypesFilter );
 	}
 
-	@SuppressWarnings("unchecked")
 	@Override
 	public Query<I> createQueryForIdentifierListing(SharedSessionContractImplementor session,
 			Set<? extends Class<? extends E>> includedTypesFilter) {
 		return createQueryWithTypesFilter( session,
-				"select e. " + uniquePropertyName + " from " + entityPersister.getEntityName() + " e",
-				(Class<I>) entityPersister.getIdentifierType().getReturnedClass(),
-				"e", includedTypesFilter );
+				"select e. " + uniquePropertyName + " from " + entityMappingType.getEntityName() + " e",
+				uniquePropertyType, "e", includedTypesFilter );
 	}
 
 	@SuppressWarnings("unchecked")
 	@Override
 	public Query<E> createQueryForLoadByUniqueProperty(SessionImplementor session, String parameterName) {
 		return session.createQuery(
-				"select e from " + entityPersister.getEntityName()
+				"select e from " + entityMappingType.getEntityName()
 						+ " e where " + uniquePropertyName + " in (:" + parameterName + ")",
-				(Class<E>) entityPersister.getMappedClass()
+				(Class<E>) entityMappingType.getMappedJavaType().getJavaTypeClass()
 		);
 	}
 
 	@Override
-	@SuppressWarnings("unchecked") // Can't do better here: the underlying method has no generics
 	public MultiIdentifierLoadAccess<E> createMultiIdentifierLoadAccess(SessionImplementor session) {
-		return session.byMultipleIds( entityPersister.getEntityName() );
+		return session.byMultipleIds( entityMappingType.getEntityName() );
 	}
 
 	@Override
 	public boolean uniquePropertyIsTheEntityId() {
-		return uniquePropertyName.equals( entityPersister.getIdentifierPropertyName() );
+		return uniquePropertyName.equals( entityMappingType.getIdentifierMapping().getAttributeName() );
 	}
 
 	private <T> Query<T> createQueryWithTypesFilter(SharedSessionContractImplementor session,
diff --git a/main/java/org/hibernate/search/mapper/orm/loading/impl/LoadingTypeContext.java b/main/java/org/hibernate/search/mapper/orm/loading/impl/LoadingTypeContext.java
index 4fd6258ed4..eaac4243ea 100644
--- a/main/java/org/hibernate/search/mapper/orm/loading/impl/LoadingTypeContext.java
+++ b/main/java/org/hibernate/search/mapper/orm/loading/impl/LoadingTypeContext.java
@@ -8,7 +8,7 @@
 
 import java.util.List;
 
-import org.hibernate.persister.entity.EntityPersister;
+import org.hibernate.metamodel.mapping.EntityMappingType;
 import org.hibernate.search.mapper.pojo.model.spi.PojoRawTypeIdentifier;
 
 public interface LoadingTypeContext<E> {
@@ -21,9 +21,9 @@ public interface LoadingTypeContext<E> {
 	PojoRawTypeIdentifier<E> typeIdentifier();
 
 	/**
-	 * @return The entity persister, giving access to a representation of the entity type in the Hibernate ORM metamodel.
+	 * @return The entity mapping type, giving access to a representation of the entity type in the Hibernate ORM metamodel.
 	 */
-	EntityPersister entityPersister();
+	EntityMappingType entityMappingType();
 
 	HibernateOrmEntityLoadingStrategy<? super E, ?> loadingStrategy();
 
diff --git a/main/java/org/hibernate/search/mapper/orm/loading/impl/MutableEntityLoadingOptions.java b/main/java/org/hibernate/search/mapper/orm/loading/impl/MutableEntityLoadingOptions.java
index a8669bf79d..48e2214a60 100644
--- a/main/java/org/hibernate/search/mapper/orm/loading/impl/MutableEntityLoadingOptions.java
+++ b/main/java/org/hibernate/search/mapper/orm/loading/impl/MutableEntityLoadingOptions.java
@@ -9,7 +9,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import org.hibernate.persister.entity.EntityPersister;
+import org.hibernate.metamodel.mapping.EntityMappingType;
+import org.hibernate.metamodel.model.domain.EntityDomainType;
 import org.hibernate.search.util.common.impl.Contracts;
 
 public class MutableEntityLoadingOptions {
@@ -30,15 +31,20 @@ public void fetchSize(int fetchSize) {
 		this.fetchSize = fetchSize;
 	}
 
-	public EntityGraphHint<?> entityGraphHintOrNullForType(EntityPersister entityPersister) {
-		if ( entityGraphHints == null ) {
+	public EntityGraphHint<?> entityGraphHintOrNullForType(EntityMappingType entityMappingType) {
+		if ( entityGraphHints == null || entityGraphHints.isEmpty() ) {
 			return null;
 		}
-		String hibernateOrmEntityName = entityPersister.getEntityName();
-		for ( EntityGraphHint<?> entityGraphHint : entityGraphHints ) {
-			if ( entityGraphHint.graph.appliesTo( hibernateOrmEntityName ) ) {
-				return entityGraphHint;
+		EntityMappingType testedType = entityMappingType;
+		while ( testedType != null ) {
+			for ( EntityGraphHint<?> entityGraphHint : entityGraphHints ) {
+				// This cast is fine because a RootGraph always applies to an entity type
+				EntityDomainType<?> graphedType = (EntityDomainType<?>) entityGraphHint.graph.getGraphedType();
+				if ( graphedType.getHibernateEntityName().equals( testedType.getEntityName() ) ) {
+					return entityGraphHint;
+				}
 			}
+			testedType = testedType.getSuperMappingType();
 		}
 		return null;
 	}
@@ -50,6 +56,9 @@ public void entityGraphHint(EntityGraphHint<?> entityGraphHint, boolean replaceE
 		else if ( replaceExisting ) {
 			entityGraphHints.clear();
 		}
+		if ( entityGraphHint == null ) {
+			return;
+		}
 		this.entityGraphHints.add( entityGraphHint );
 	}
 }
diff --git a/main/java/org/hibernate/search/mapper/orm/loading/impl/PersistenceContextThenSecondLevelCacheLookupStrategy.java b/main/java/org/hibernate/search/mapper/orm/loading/impl/PersistenceContextThenSecondLevelCacheLookupStrategy.java
index 2e7c0c9d52..f5b23c4b54 100644
--- a/main/java/org/hibernate/search/mapper/orm/loading/impl/PersistenceContextThenSecondLevelCacheLookupStrategy.java
+++ b/main/java/org/hibernate/search/mapper/orm/loading/impl/PersistenceContextThenSecondLevelCacheLookupStrategy.java
@@ -12,8 +12,10 @@
 import org.hibernate.cache.spi.access.EntityDataAccess;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.metamodel.mapping.EntityMappingType;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.search.mapper.orm.logging.impl.Log;
+import org.hibernate.search.util.common.annotation.impl.SuppressForbiddenApis;
 import org.hibernate.search.util.common.logging.impl.LoggerFactory;
 
 /**
@@ -24,25 +26,27 @@
  *
  * @author Emmanuel Bernard
  */
+@SuppressForbiddenApis(reason = "EntityPersister is needed to retrieve/use EntityDataAccess")
 class PersistenceContextThenSecondLevelCacheLookupStrategy
 		implements EntityLoadingCacheLookupStrategyImplementor {
 
 	private static final Log log = LoggerFactory.make( Log.class, MethodHandles.lookup() );
 
-	static EntityLoadingCacheLookupStrategyImplementor create(EntityPersister commonEntitySuperTypePersister,
+	static EntityLoadingCacheLookupStrategyImplementor create(EntityMappingType entityMappingType,
 			SessionImplementor session) {
 		EntityLoadingCacheLookupStrategyImplementor persistenceContextLookupStrategy =
 				PersistenceContextLookupStrategy.create( session );
-		EntityDataAccess cacheAccess = commonEntitySuperTypePersister.getCacheAccessStrategy();
+		EntityPersister entityPersister = entityMappingType.getEntityPersister();
+		EntityDataAccess cacheAccess = entityPersister.getCacheAccessStrategy();
 		if ( cacheAccess == null ) {
 			// No second-level cache
 			log.skippingSecondLevelCacheLookupsForNonCachedEntityTypeEntityLoader(
-					commonEntitySuperTypePersister.getEntityName() );
+					entityPersister.getEntityName() );
 			return persistenceContextLookupStrategy;
 		}
 		return new PersistenceContextThenSecondLevelCacheLookupStrategy(
 				persistenceContextLookupStrategy,
-				commonEntitySuperTypePersister,
+				entityPersister,
 				cacheAccess,
 				session
 		);
diff --git a/main/java/org/hibernate/search/mapper/orm/loading/impl/TypeQueryFactory.java b/main/java/org/hibernate/search/mapper/orm/loading/impl/TypeQueryFactory.java
index 82c86985ab..1d289634b7 100644
--- a/main/java/org/hibernate/search/mapper/orm/loading/impl/TypeQueryFactory.java
+++ b/main/java/org/hibernate/search/mapper/orm/loading/impl/TypeQueryFactory.java
@@ -6,32 +6,33 @@
  */
 package org.hibernate.search.mapper.orm.loading.impl;
 
+import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.MultiIdentifierLoadAccess;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.SharedSessionContractImplementor;
+import org.hibernate.metamodel.mapping.EntityMappingType;
 import org.hibernate.metamodel.model.domain.EntityDomainType;
-import org.hibernate.metamodel.spi.MetamodelImplementor;
-import org.hibernate.persister.entity.EntityPersister;
+import org.hibernate.metamodel.model.domain.JpaMetamodel;
 import org.hibernate.query.Query;
 import org.hibernate.search.mapper.orm.massindexing.impl.ConditionalExpression;
 
 public interface TypeQueryFactory<E, I> {
 
-	static TypeQueryFactory<?, ?> create(SessionFactoryImplementor sessionFactory, EntityPersister entityPersister,
+	static TypeQueryFactory<?, ?> create(SessionFactoryImplementor sessionFactory, EntityMappingType entityMappingType,
 			String uniquePropertyName) {
-		MetamodelImplementor metamodel = sessionFactory.getMetamodel();
-		EntityDomainType<?> typeOrNull = metamodel.entity( entityPersister.getEntityName() );
-		if ( typeOrNull != null ) {
+		JpaMetamodel metamodel = sessionFactory.getJpaMetamodel();
+		EntityDomainType<?> typeOrNull = metamodel.entity( entityMappingType.getEntityName() );
+		if ( typeOrNull != null && !( entityMappingType.getMappedJavaType().getJavaTypeClass().equals( Map.class ) ) ) {
 			return CriteriaTypeQueryFactory.create( typeOrNull, uniquePropertyName );
 		}
 		else {
 			// Most likely this is a dynamic-map entity; they don't have a representation in the JPA metamodel
 			// and can't be queried using the Criteria API.
 			// Use HQL queries instead, even if it feels a bit dirty.
-			return new HqlTypeQueryFactory<>( entityPersister, uniquePropertyName );
+			return new HqlTypeQueryFactory<>( entityMappingType, uniquePropertyName );
 		}
 	}
 
@@ -41,10 +42,10 @@ Query<Long> createQueryForCount(SharedSessionContractImplementor session,
 	Query<I> createQueryForIdentifierListing(SharedSessionContractImplementor session,
 			Set<? extends Class<? extends E>> includedTypesFilter);
 
-	Query<Long> createQueryForCount(SharedSessionContractImplementor session, EntityPersister persister,
+	Query<Long> createQueryForCount(SharedSessionContractImplementor session, EntityMappingType entityMappingType,
 			Set<? extends Class<? extends E>> includedTypesFilter, ConditionalExpression conditionalExpression);
 
-	Query<I> createQueryForIdentifierListing(SharedSessionContractImplementor session, EntityPersister persister,
+	Query<I> createQueryForIdentifierListing(SharedSessionContractImplementor session, EntityMappingType entityMappingType,
 			Set<? extends Class<? extends E>> includedTypesFilter, ConditionalExpression conditionalExpression);
 
 	Query<E> createQueryForLoadByUniqueProperty(SessionImplementor session, String parameterName);
diff --git a/main/java/org/hibernate/search/mapper/orm/logging/impl/Log.java b/main/java/org/hibernate/search/mapper/orm/logging/impl/Log.java
index 6fbfb8b005..0c63c4cddb 100644
--- a/main/java/org/hibernate/search/mapper/orm/logging/impl/Log.java
+++ b/main/java/org/hibernate/search/mapper/orm/logging/impl/Log.java
@@ -253,14 +253,10 @@ SearchException foundMultipleEntitiesForDocumentId(String entityName, String doc
 			+ " Currently configured tenant identifiers: %2$s.")
 	SearchException invalidTenantId(String tenantId, Set<String> allTenantIds, String tenantIdsConfigurationPropertyKey);
 
-	// NOTE: This is used in -orm6 modules
-	@SuppressWarnings("unused")
 	@LogMessage(level = Logger.Level.INFO)
 	@Message(id = ID_OFFSET + 56, value = "Ignoring unrecognized query hint [%s]")
 	void ignoringUnrecognizedQueryHint(String hintName);
 
-	// NOTE: This is used in -orm6 modules
-	@SuppressWarnings("unused")
 	@Message(id = ID_OFFSET + 57,
 			value = "Cannot set the fetch size of Hibernate Search ScrollableResults after having created them."
 					+ " If you want to define the size of batches for entity loading, set loading options when defining the query instead,"
diff --git a/main/java/org/hibernate/search/mapper/orm/mapping/impl/AbstractHibernateOrmTypeContext.java b/main/java/org/hibernate/search/mapper/orm/mapping/impl/AbstractHibernateOrmTypeContext.java
index 3e83b7bc62..04702fd757 100644
--- a/main/java/org/hibernate/search/mapper/orm/mapping/impl/AbstractHibernateOrmTypeContext.java
+++ b/main/java/org/hibernate/search/mapper/orm/mapping/impl/AbstractHibernateOrmTypeContext.java
@@ -10,8 +10,8 @@
 import java.util.stream.Collectors;
 
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.metamodel.spi.MetamodelImplementor;
-import org.hibernate.persister.entity.EntityPersister;
+import org.hibernate.metamodel.MappingMetamodel;
+import org.hibernate.metamodel.mapping.EntityMappingType;
 import org.hibernate.search.mapper.orm.event.impl.HibernateOrmListenerTypeContext;
 import org.hibernate.search.mapper.orm.loading.impl.HibernateOrmEntityIdEntityLoadingStrategy;
 import org.hibernate.search.mapper.orm.loading.impl.HibernateOrmEntityLoadingStrategy;
@@ -32,7 +32,7 @@ abstract class AbstractHibernateOrmTypeContext<E>
 
 	private final PojoRawTypeIdentifier<E> typeIdentifier;
 	private final String jpaEntityName;
-	private final EntityPersister entityPersister;
+	private final EntityMappingType entityMappingType;
 	private final boolean documentIdIsEntityId;
 	private final HibernateOrmEntityLoadingStrategy<? super E, ?> loadingStrategy;
 	private final PojoPathFilter dirtyFilter;
@@ -44,23 +44,22 @@ abstract class AbstractHibernateOrmTypeContext<E>
 	AbstractHibernateOrmTypeContext(AbstractBuilder<E> builder, SessionFactoryImplementor sessionFactory) {
 		this.typeIdentifier = builder.typeIdentifier;
 		this.jpaEntityName = builder.jpaEntityName;
-		MetamodelImplementor metamodel = sessionFactory.getMetamodel();
-		this.entityPersister = metamodel.entityPersister( builder.hibernateOrmEntityName );
+		MappingMetamodel metamodel = sessionFactory.getMappingMetamodel();
+		this.entityMappingType = metamodel.getEntityDescriptor( builder.hibernateOrmEntityName );
 		this.ascendingSuperTypes = builder.ascendingSuperTypes;
 		if ( builder.documentIdSourcePropertyName != null ) {
-			if ( builder.documentIdSourcePropertyName.equals( entityPersister().getIdentifierPropertyName() ) ) {
+			if ( builder.documentIdSourcePropertyName.equals( entityMappingType().getIdentifierMapping().getAttributeName() ) ) {
 				documentIdIsEntityId = true;
 				loadingStrategy = (HibernateOrmEntityLoadingStrategy<? super E, ?>) HibernateOrmEntityIdEntityLoadingStrategy
-						.create( sessionFactory, entityPersister() );
+						.create( sessionFactory, entityMappingType() );
 			}
 			else {
 				// The entity ID is not the property used to generate the document ID
 				// We need to use a criteria query to load entities from the document IDs
 				documentIdIsEntityId = false;
 				loadingStrategy = (HibernateOrmEntityLoadingStrategy<? super E,
-						?>) HibernateOrmNonEntityIdPropertyEntityLoadingStrategy.create( sessionFactory, entityPersister(),
-								builder.documentIdSourcePropertyName, builder.documentIdSourcePropertyHandle
-						);
+						?>) HibernateOrmNonEntityIdPropertyEntityLoadingStrategy.create( sessionFactory, entityMappingType,
+								builder.documentIdSourcePropertyName, builder.documentIdSourcePropertyHandle );
 			}
 		}
 		else {
@@ -88,12 +87,12 @@ public String jpaEntityName() {
 	}
 
 	public String hibernateOrmEntityName() {
-		return entityPersister.getEntityName();
+		return entityMappingType.getEntityName();
 	}
 
 	@Override
-	public EntityPersister entityPersister() {
-		return entityPersister;
+	public EntityMappingType entityMappingType() {
+		return entityMappingType;
 	}
 
 	@Override
diff --git a/main/java/org/hibernate/search/mapper/orm/mapping/impl/HibernateOrmMappingConfigurationContributor.java b/main/java/org/hibernate/search/mapper/orm/mapping/impl/HibernateOrmMappingConfigurationContributor.java
index b04d92857d..a990dab6c6 100644
--- a/main/java/org/hibernate/search/mapper/orm/mapping/impl/HibernateOrmMappingConfigurationContributor.java
+++ b/main/java/org/hibernate/search/mapper/orm/mapping/impl/HibernateOrmMappingConfigurationContributor.java
@@ -59,9 +59,8 @@ public void configure(MappingBuildContext buildContext, PojoMappingConfiguration
 			}
 
 			// Sort the properties before processing for deterministic iteration
-			@SuppressWarnings("unchecked") // Hibernate ORM gives us raw types, we must make do.
 			List<Property> properties =
-					HibernateOrmUtils.sortedNonSyntheticProperties( persistentClass.getPropertyIterator() );
+					HibernateOrmUtils.sortedNonSyntheticProperties( persistentClass.getProperties().iterator() );
 
 			Property identifierProperty = persistentClass.getIdentifierProperty();
 			Optional<Property> identifierPropertyOptional = Optional.ofNullable( identifierProperty );
@@ -125,9 +124,8 @@ private void contributeEmbeddableTypeMetadata(
 			 */
 			if ( processedEmbeddableTypes.add( componentTypeModel ) ) {
 				// Sort the properties before processing for deterministic iteration
-				@SuppressWarnings("unchecked") // Hibernate ORM gives us raw types, we must make do.
 				List<Property> properties =
-						HibernateOrmUtils.sortedNonSyntheticProperties( componentValue.getPropertyIterator() );
+						HibernateOrmUtils.sortedNonSyntheticProperties( componentValue.getProperties().iterator() );
 				configurationCollector.collectContributor( componentTypeModel,
 						new ErrorCollectingPojoTypeMetadataContributor()
 								// Ensure Hibernate ORM metadata about properties is translated into Hibernate Search metadata
diff --git a/main/java/org/hibernate/search/mapper/orm/mapping/impl/HibernateOrmMappingInitiator.java b/main/java/org/hibernate/search/mapper/orm/mapping/impl/HibernateOrmMappingInitiator.java
index e737b7c23b..55cc7ffe23 100644
--- a/main/java/org/hibernate/search/mapper/orm/mapping/impl/HibernateOrmMappingInitiator.java
+++ b/main/java/org/hibernate/search/mapper/orm/mapping/impl/HibernateOrmMappingInitiator.java
@@ -8,10 +8,9 @@
 
 import java.util.List;
 
-import org.hibernate.MultiTenancyStrategy;
 import org.hibernate.annotations.common.reflection.ReflectionManager;
 import org.hibernate.boot.Metadata;
-import org.hibernate.engine.config.spi.ConfigurationService;
+import org.hibernate.boot.spi.MetadataImplementor;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.search.engine.cfg.ConfigurationPropertySource;
 import org.hibernate.search.engine.cfg.spi.ConfigurationProperty;
@@ -71,13 +70,14 @@ public static HibernateOrmMappingInitiator create(Metadata metadata, IndexView j
 				HibernateOrmBasicTypeMetadataProvider.create( metadata );
 		HibernateOrmBootstrapIntrospector introspector = HibernateOrmBootstrapIntrospector.create(
 				basicTypeMetadataProvider, reflectionManager, valueHandleFactory );
-		ConfigurationService ormConfigurationService =
-				HibernateOrmUtils.getServiceOrFail( serviceRegistry, ConfigurationService.class );
 		HibernateSearchPreIntegrationService preIntegrationService =
 				HibernateOrmUtils.getServiceOrFail( serviceRegistry, HibernateSearchPreIntegrationService.class );
 
+		boolean multiTenancyEnabled = ( (MetadataImplementor) metadata ).getMetadataBuildingOptions()
+				.isMultiTenancyEnabled();
+
 		return new HibernateOrmMappingInitiator( basicTypeMetadataProvider, jandexIndex, introspector,
-				ormConfigurationService, preIntegrationService );
+				preIntegrationService, multiTenancyEnabled );
 	}
 
 	private final HibernateOrmBasicTypeMetadataProvider basicTypeMetadataProvider;
@@ -87,10 +87,10 @@ public static HibernateOrmMappingInitiator create(Metadata metadata, IndexView j
 	private BeanHolder<? extends CoordinationStrategy> coordinationStrategyHolder;
 	private ConfiguredAutomaticIndexingStrategy configuredAutomaticIndexingStrategy;
 
-	private HibernateOrmMappingInitiator(HibernateOrmBasicTypeMetadataProvider basicTypeMetadataProvider,
+	private HibernateOrmMappingInitiator(
+			HibernateOrmBasicTypeMetadataProvider basicTypeMetadataProvider,
 			IndexView jandexIndex, HibernateOrmBootstrapIntrospector introspector,
-			ConfigurationService ormConfigurationService,
-			HibernateSearchPreIntegrationService preIntegrationService) {
+			HibernateSearchPreIntegrationService preIntegrationService, boolean multiTenancyEnabled) {
 		super( introspector );
 
 		this.basicTypeMetadataProvider = basicTypeMetadataProvider;
@@ -99,19 +99,7 @@ private HibernateOrmMappingInitiator(HibernateOrmBasicTypeMetadataProvider basic
 		}
 		this.introspector = introspector;
 
-		/*
-		 * This method is called when the session factory is created, and once again when HSearch boots.
-		 * It logs a warning when the configuration property is invalid,
-		 * so the warning will be logged twice.
-		 * Since it only happens when the configuration is invalid,
-		 * we can live with this quirk.
-		 */
-		MultiTenancyStrategy multiTenancyStrategy =
-				MultiTenancyStrategy.determineMultiTenancyStrategy( ormConfigurationService.getSettings() );
-
-		tenancyMode( MultiTenancyStrategy.NONE.equals( multiTenancyStrategy )
-				? TenancyMode.SINGLE_TENANCY
-				: TenancyMode.MULTI_TENANCY );
+		tenancyMode( multiTenancyEnabled ? TenancyMode.MULTI_TENANCY : TenancyMode.SINGLE_TENANCY );
 
 		this.preIntegrationService = preIntegrationService;
 	}
diff --git a/main/java/org/hibernate/search/mapper/orm/mapping/impl/HibernateOrmMappingPropertiesMetadataContributor.java b/main/java/org/hibernate/search/mapper/orm/mapping/impl/HibernateOrmMappingPropertiesMetadataContributor.java
index 746e9621a5..23ebbba4d6 100644
--- a/main/java/org/hibernate/search/mapper/orm/mapping/impl/HibernateOrmMappingPropertiesMetadataContributor.java
+++ b/main/java/org/hibernate/search/mapper/orm/mapping/impl/HibernateOrmMappingPropertiesMetadataContributor.java
@@ -10,12 +10,14 @@
 import java.util.List;
 import java.util.StringTokenizer;
 
+import org.hibernate.boot.Metadata;
+import org.hibernate.dialect.Dialect;
+import org.hibernate.engine.jdbc.Size;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.OneToMany;
 import org.hibernate.mapping.OneToOne;
 import org.hibernate.mapping.Property;
-import org.hibernate.mapping.Selectable;
 import org.hibernate.mapping.SimpleValue;
 import org.hibernate.mapping.ToOne;
 import org.hibernate.mapping.Value;
@@ -95,13 +97,18 @@ else if ( value instanceof SimpleValue ) {
 	}
 
 	private void collectScale(PojoAdditionalMetadataCollectorPropertyNode collector, Value value) {
-		Iterator<Selectable> ci = value.getColumnIterator();
-		while ( ci.hasNext() ) {
-			Selectable selectable = ci.next();
-			if ( selectable instanceof Column ) {
-				int scale = ( (Column) selectable ).getScale();
-				collector.value( getExtractorPath( value ) ).decimalScale( scale );
+		Iterator<Column> columnIterator = value.getColumns().iterator();
+		Dialect dialect = basicTypeMetadataProvider.getDialect();
+		Metadata metadata = basicTypeMetadataProvider.getMetadata();
+
+		while ( columnIterator.hasNext() ) {
+			Column column = columnIterator.next();
+			Size size = column.getColumnSize( dialect, metadata );
+			Integer scale = size.getScale();
+			if ( scale == null ) {
+				continue;
 			}
+			collector.value( getExtractorPath( value ) ).decimalScale( scale );
 		}
 	}
 
diff --git a/main/java/org/hibernate/search/mapper/orm/model/impl/HibernateOrmBasicTypeMetadataProvider.java b/main/java/org/hibernate/search/mapper/orm/model/impl/HibernateOrmBasicTypeMetadataProvider.java
index 73bfa52679..b604b66e20 100644
--- a/main/java/org/hibernate/search/mapper/orm/model/impl/HibernateOrmBasicTypeMetadataProvider.java
+++ b/main/java/org/hibernate/search/mapper/orm/model/impl/HibernateOrmBasicTypeMetadataProvider.java
@@ -16,13 +16,14 @@
 
 import org.hibernate.MappingException;
 import org.hibernate.boot.Metadata;
+import org.hibernate.dialect.Dialect;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.Value;
 import org.hibernate.property.access.spi.Getter;
 
-@SuppressWarnings("unchecked") // Hibernate ORM gives us raw types, we must make do.
+@SuppressWarnings("unchecked") // Hibernate Commons annotations gives us wildcard types, we must make do.
 public class HibernateOrmBasicTypeMetadataProvider {
 
 	public static HibernateOrmBasicTypeMetadataProvider create(Metadata metadata) {
@@ -34,7 +35,7 @@ public static HibernateOrmBasicTypeMetadataProvider create(Metadata metadata) {
 				new TreeSet<>( Comparator.comparing( PersistentClass::getEntityName ) );
 		persistentClasses.addAll( metadata.getEntityBindings() );
 
-		Builder builder = new Builder();
+		Builder builder = new Builder( metadata );
 
 		for ( PersistentClass persistentClass : persistentClasses ) {
 			collectPersistentClass( builder, persistentClass );
@@ -55,7 +56,7 @@ private static void collectPersistentClass(Builder metadataProviderBuilder, Pers
 
 			collectClassType(
 					metadataProviderBuilder, javaClass,
-					persistentClass.getIdentifierProperty(), persistentClass.getPropertyIterator()
+					persistentClass.getIdentifierProperty(), persistentClass.getProperties().iterator()
 			);
 
 			metadataProviderBuilder.typeIdentifierResolverBuilder.addClassEntityType(
@@ -66,7 +67,7 @@ private static void collectPersistentClass(Builder metadataProviderBuilder, Pers
 			collectDynamicMapType(
 					metadataProviderBuilder, hibernateOrmEntityName,
 					persistentClass.getSuperclass(),
-					persistentClass.getIdentifierProperty(), persistentClass.getPropertyIterator()
+					persistentClass.getIdentifierProperty(), persistentClass.getProperties().iterator()
 			);
 
 			metadataProviderBuilder.typeIdentifierResolverBuilder.addDynamicMapEntityType(
@@ -160,7 +161,7 @@ else if ( value instanceof org.hibernate.mapping.Array ) {
 		else if ( value instanceof org.hibernate.mapping.Map ) {
 			org.hibernate.mapping.Map map = (org.hibernate.mapping.Map) value;
 			return HibernateOrmTypeModelFactory.map(
-					map.getCollectionType().getReturnedClass(),
+					(Class<? extends Map<?, ?>>) map.getCollectionType().getReturnedClass(),
 					/*
 					 * Do not let ORM confuse you: getKey() doesn't return the value of the map key,
 					 * but the value of the foreign key to the targeted entity...
@@ -173,7 +174,7 @@ else if ( value instanceof org.hibernate.mapping.Map ) {
 		else if ( value instanceof org.hibernate.mapping.Collection ) {
 			org.hibernate.mapping.Collection collection = (org.hibernate.mapping.Collection) value;
 			return HibernateOrmTypeModelFactory.collection(
-					collection.getCollectionType().getReturnedClass(),
+					(Class<? extends Collection<?>>) collection.getCollectionType().getReturnedClass(),
 					collectValue( metadataProviderBuilder, collection.getElement() )
 			);
 		}
@@ -203,7 +204,7 @@ private static HibernateOrmTypeModelFactory<?> collectEmbedded(Builder metadataP
 				collectDynamicMapType(
 						metadataProviderBuilder, name,
 						null, /* No supertype */
-						null /* No ID */, component.getPropertyIterator()
+						null /* No ID */, component.getProperties().iterator()
 				);
 			}
 			return HibernateOrmTypeModelFactory.dynamicMap( name );
@@ -214,13 +215,15 @@ private static HibernateOrmTypeModelFactory<?> collectEmbedded(Builder metadataP
 			if ( !metadataProviderBuilder.classTypeMetadata.containsKey( javaClass ) ) {
 				collectClassType(
 						metadataProviderBuilder, javaClass,
-						null /* No ID */, component.getPropertyIterator()
+						null /* No ID */, component.getProperties().iterator()
 				);
 			}
 			return HibernateOrmTypeModelFactory.rawType( javaClass );
 		}
 	}
 
+	private final Metadata metadata;
+
 	private final Map<String, PersistentClass> persistentClasses;
 	private final Map<Class<?>, HibernateOrmBasicClassTypeMetadata> classTypeMetadata;
 	private final Map<String, HibernateOrmBasicDynamicMapTypeMetadata> dynamicMapTypeMetadata;
@@ -229,6 +232,7 @@ private static HibernateOrmTypeModelFactory<?> collectEmbedded(Builder metadataP
 	private final HibernateOrmRawTypeIdentifierResolver typeIdentifierResolver;
 
 	private HibernateOrmBasicTypeMetadataProvider(Builder builder) {
+		this.metadata = builder.metadata;
 		this.persistentClasses = builder.persistentClasses;
 		this.classTypeMetadata = builder.classTypeMetadata;
 		this.dynamicMapTypeMetadata = builder.dynamicMapTypeMetadata;
@@ -236,6 +240,14 @@ private HibernateOrmBasicTypeMetadataProvider(Builder builder) {
 		this.typeIdentifierResolver = builder.typeIdentifierResolverBuilder.build();
 	}
 
+	public Metadata getMetadata() {
+		return metadata;
+	}
+
+	public Dialect getDialect() {
+		return metadata.getDatabase().getDialect();
+	}
+
 	public Collection<PersistentClass> getPersistentClasses() {
 		return persistentClasses.values();
 	}
@@ -267,6 +279,8 @@ Set<String> getKnownDynamicMapTypeNames() {
 	}
 
 	private static class Builder {
+		private final Metadata metadata;
+
 		private final Map<String, PersistentClass> persistentClasses = new LinkedHashMap<>();
 		private final Map<Class<?>, HibernateOrmBasicClassTypeMetadata> classTypeMetadata = new LinkedHashMap<>();
 		private final Map<String, HibernateOrmBasicDynamicMapTypeMetadata> dynamicMapTypeMetadata = new LinkedHashMap<>();
@@ -275,6 +289,10 @@ private static class Builder {
 		private final HibernateOrmRawTypeIdentifierResolver.Builder typeIdentifierResolverBuilder =
 				new HibernateOrmRawTypeIdentifierResolver.Builder();
 
+		public Builder(Metadata metadata) {
+			this.metadata = metadata;
+		}
+
 		HibernateOrmBasicTypeMetadataProvider build() {
 			return new HibernateOrmBasicTypeMetadataProvider( this );
 		}
diff --git a/main/java/org/hibernate/search/mapper/orm/model/impl/HibernateOrmPathDefinitionProvider.java b/main/java/org/hibernate/search/mapper/orm/model/impl/HibernateOrmPathDefinitionProvider.java
index 1e978c8d18..e99b682d70 100644
--- a/main/java/org/hibernate/search/mapper/orm/model/impl/HibernateOrmPathDefinitionProvider.java
+++ b/main/java/org/hibernate/search/mapper/orm/model/impl/HibernateOrmPathDefinitionProvider.java
@@ -7,7 +7,6 @@
 package org.hibernate.search.mapper.orm.model.impl;
 
 import java.util.ArrayList;
-import java.util.Iterator;
 import java.util.List;
 
 import org.hibernate.mapping.PersistentClass;
@@ -38,8 +37,7 @@ public HibernateOrmPathDefinitionProvider(PojoRawTypeModel<?> typeModel, Persist
 		this.typeModel = typeModel;
 		this.persistentClass = persistentClass;
 		this.propertyStringRepresentationByOrdinal = new ArrayList<>();
-		for ( Iterator<Property> iterator = persistentClass.getPropertyClosureIterator(); iterator.hasNext(); ) {
-			Property property = iterator.next();
+		for ( Property property : persistentClass.getPropertyClosure() ) {
 			propertyStringRepresentationByOrdinal.add( property.getName() );
 		}
 	}
diff --git a/main/java/org/hibernate/search/mapper/orm/model/impl/HibernateOrmPathInterpreter.java b/main/java/org/hibernate/search/mapper/orm/model/impl/HibernateOrmPathInterpreter.java
index 520e91395f..55ef751fe4 100644
--- a/main/java/org/hibernate/search/mapper/orm/model/impl/HibernateOrmPathInterpreter.java
+++ b/main/java/org/hibernate/search/mapper/orm/model/impl/HibernateOrmPathInterpreter.java
@@ -17,6 +17,7 @@
 import org.hibernate.MappingException;
 import org.hibernate.event.spi.PostUpdateEvent;
 import org.hibernate.mapping.Any;
+import org.hibernate.mapping.BasicValue;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.ManyToOne;
 import org.hibernate.mapping.OneToMany;
@@ -352,7 +353,7 @@ public Value value(Context context, Property property, PojoModelPathValueNode pa
 				return baseValue;
 			}
 		}
-		else if ( SimpleValue.class.equals( valueClass ) ) { // equals() and not isAssignableFrom(), we mean it.
+		else if ( BasicValue.class.isAssignableFrom( valueClass ) ) {
 			// The path as a whole (and not just a prefix) was resolved to a non-component, non-association value
 			context.resolvedStringRepresentation( propertyNode.toPropertyString() );
 			// We don't need state extraction in this case
@@ -414,7 +415,7 @@ private Value resolveExtractorPath(Context context, PojoModelPathValueNode path,
 		if ( !extractorNameIterator.hasNext() ) {
 			// We managed to resolve the whole container value extractor list
 			Class<? extends Value> containedValueClass = containedValue.getClass();
-			if ( SimpleValue.class.equals( containedValueClass ) // equals() and not isAssignableFrom(), we mean it.
+			if ( BasicValue.class.isAssignableFrom( containedValueClass )
 					|| Component.class.isAssignableFrom( containedValueClass )
 					|| isWholePath && isAssociation( containedValueClass ) ) {
 				String stringRepresentationAsProperty = propertyNode.toPropertyString();
diff --git a/main/java/org/hibernate/search/mapper/orm/search/query/impl/HibernateOrmSearchQueryAdapter.java b/main/java/org/hibernate/search/mapper/orm/search/query/impl/HibernateOrmSearchQueryAdapter.java
index 9bb356037e..7612f14f70 100644
--- a/main/java/org/hibernate/search/mapper/orm/search/query/impl/HibernateOrmSearchQueryAdapter.java
+++ b/main/java/org/hibernate/search/mapper/orm/search/query/impl/HibernateOrmSearchQueryAdapter.java
@@ -7,34 +7,30 @@
 package org.hibernate.search.mapper.orm.search.query.impl;
 
 import java.lang.invoke.MethodHandles;
-import java.util.Calendar;
-import java.util.Collections;
-import java.util.Date;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
-import jakarta.persistence.FlushModeType;
-import jakarta.persistence.LockModeType;
-import jakarta.persistence.Parameter;
-import jakarta.persistence.QueryTimeoutException;
-import jakarta.persistence.TemporalType;
+import java.util.function.Function;
 
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
-import org.hibernate.QueryException;
 import org.hibernate.ScrollMode;
-import org.hibernate.TypeMismatchException;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.graph.GraphSemantic;
 import org.hibernate.graph.RootGraph;
-import org.hibernate.query.QueryParameter;
-import org.hibernate.query.internal.AbstractProducedQuery;
-import org.hibernate.query.internal.ParameterMetadataImpl;
+import org.hibernate.graph.spi.AppliedGraph;
+import org.hibernate.graph.spi.RootGraphImplementor;
+import org.hibernate.query.ResultListTransformer;
+import org.hibernate.query.TupleTransformer;
+import org.hibernate.query.spi.AbstractQuery;
+import org.hibernate.query.spi.MutableQueryOptions;
+import org.hibernate.query.spi.ParameterMetadataImplementor;
+import org.hibernate.query.spi.QueryImplementor;
+import org.hibernate.query.spi.QueryParameterBinding;
 import org.hibernate.query.spi.QueryParameterBindings;
+import org.hibernate.query.spi.QueryParameterImplementor;
 import org.hibernate.query.spi.ScrollableResultsImplementor;
 import org.hibernate.search.engine.search.query.SearchQuery;
 import org.hibernate.search.engine.search.query.spi.SearchQueryImplementor;
@@ -43,17 +39,19 @@
 import org.hibernate.search.mapper.orm.logging.impl.Log;
 import org.hibernate.search.mapper.orm.search.query.spi.HibernateOrmSearchQueryHints;
 import org.hibernate.search.mapper.orm.search.query.spi.HibernateOrmSearchScrollableResultsAdapter;
-import org.hibernate.search.mapper.orm.search.query.spi.HibernateOrmSearchScrollableResultsAdapter.ScrollHitExtractor;
 import org.hibernate.search.util.common.SearchTimeoutException;
 import org.hibernate.search.util.common.annotation.impl.SuppressForbiddenApis;
 import org.hibernate.search.util.common.logging.impl.LoggerFactory;
-import org.hibernate.transform.ResultTransformer;
-import org.hibernate.type.Type;
 
-@SuppressForbiddenApis(reason = "We need to extend the internal AbstractProducedQuery"
+import jakarta.persistence.LockModeType;
+import jakarta.persistence.Parameter;
+import jakarta.persistence.PersistenceException;
+import jakarta.persistence.QueryTimeoutException;
+
+@SuppressForbiddenApis(reason = "We need to use the internal QueryOptionsImpl"
 		+ " in order to implement a org.hibernate.query.Query")
 @SuppressWarnings("unchecked") // For some reason javac issues warnings for all methods returning this; IDEA doesn't.
-public final class HibernateOrmSearchQueryAdapter<R> extends AbstractProducedQuery<R> {
+public final class HibernateOrmSearchQueryAdapter<R> extends AbstractQuery<R> {
 
 	public static <R> HibernateOrmSearchQueryAdapter<R> create(SearchQuery<R> query) {
 		return query.extension( HibernateOrmSearchQueryAdapterExtension.get() );
@@ -62,14 +60,12 @@ public static <R> HibernateOrmSearchQueryAdapter<R> create(SearchQuery<R> query)
 	private static final Log log = LoggerFactory.make( Log.class, MethodHandles.lookup() );
 
 	private final SearchQueryImplementor<R> delegate;
-	private final MutableEntityLoadingOptions loadingOptions;
 
-	private Integer firstResult;
-	private Integer maxResults;
+	private final MutableEntityLoadingOptions loadingOptions;
 
 	HibernateOrmSearchQueryAdapter(SearchQueryImplementor<R> delegate, SessionImplementor sessionImplementor,
 			MutableEntityLoadingOptions loadingOptions) {
-		super( sessionImplementor, new ParameterMetadataImpl( null, null ) );
+		super( sessionImplementor );
 		this.delegate = delegate;
 		this.loadingOptions = loadingOptions;
 	}
@@ -85,83 +81,26 @@ public String toString() {
 
 	@Override
 	@SuppressWarnings("unchecked")
-	public <T> T unwrap(Class<T> type) {
-		if ( type.equals( SearchQuery.class ) ) {
+	public <T> T unwrap(Class<T> cls) {
+		if ( cls.equals( SearchQuery.class ) ) {
 			return (T) delegate;
 		}
+		else if ( cls.isInstance( this ) ) {
+			return (T) this;
+		}
 		else {
-			return super.unwrap( type );
+			throw new PersistenceException( "Unrecognized unwrap type [" + cls.getName() + "]" );
 		}
 	}
 
 	@Override
 	public List<R> list() {
-		/*
-		 * Reproduce the behavior of AbstractProducedQuery.list() regarding exceptions,
-		 * but without the beforeQuery/afterQuery calls.
-		 * These beforeQuery/afterQuery calls make everything fail
-		 * because they call methods related to parameters,
-		 * which are not supported here.
-		 */
 		try {
-			return doList();
+			return super.list();
 		}
 		catch (SearchTimeoutException e) {
 			throw new QueryTimeoutException( e );
 		}
-		catch (QueryException he) {
-			throw new IllegalStateException( he );
-		}
-		catch (TypeMismatchException e) {
-			throw new IllegalArgumentException( e );
-		}
-		catch (HibernateException he) {
-			throw getExceptionConverter().convert( he );
-		}
-	}
-
-	@Override
-	public HibernateOrmSearchQueryAdapter<R> setMaxResults(int maxResults) {
-		if ( maxResults < 0L ) {
-			throw new IllegalArgumentException(
-					"Negative (" + maxResults + ") parameter passed in to setMaxResults"
-			);
-		}
-		this.maxResults = maxResults;
-		return this;
-	}
-
-	@Override
-	public HibernateOrmSearchQueryAdapter<R> setFirstResult(int firstResult) {
-		if ( firstResult < 0 ) {
-			throw new IllegalArgumentException(
-					"Negative (" + firstResult + ") parameter passed in to setFirstResult"
-			);
-		}
-		this.firstResult = firstResult;
-		return this;
-	}
-
-	@Override
-	public int getMaxResults() {
-		return maxResults == null ? Integer.MAX_VALUE : maxResults;
-	}
-
-	@Override
-	public int getFirstResult() {
-		return firstResult == null ? 0 : firstResult;
-	}
-
-	@Override
-	public HibernateOrmSearchQueryAdapter<R> setFetchSize(int fetchSize) {
-		loadingOptions.fetchSize( fetchSize );
-		return this;
-	}
-
-	@Override
-	public HibernateOrmSearchQueryAdapter<R> setFlushMode(FlushModeType flushModeType) {
-		super.setFlushMode( flushModeType );
-		return this;
 	}
 
 	@Override
@@ -181,14 +120,12 @@ public HibernateOrmSearchQueryAdapter<R> setHint(String hintName, Object value)
 				break;
 			case HibernateOrmSearchQueryHints.JAVAX_FETCHGRAPH:
 			case HibernateOrmSearchQueryHints.JAKARTA_FETCHGRAPH:
-				applyGraph( hintValueToEntityGraph( value ), GraphSemantic.FETCH );
-				break;
 			case HibernateOrmSearchQueryHints.JAVAX_LOADGRAPH:
 			case HibernateOrmSearchQueryHints.JAKARTA_LOADGRAPH:
-				applyGraph( hintValueToEntityGraph( value ), GraphSemantic.LOAD );
+				applyEntityGraphHint( hintName, value );
 				break;
 			default:
-				handleUnrecognizedHint( hintName, value );
+				log.ignoringUnrecognizedQueryHint( hintName );
 				break;
 		}
 		return this;
@@ -201,150 +138,107 @@ public HibernateOrmSearchQueryAdapter<R> setTimeout(int timeout) {
 	}
 
 	@Override
-	@SuppressWarnings({ "unchecked", "rawtypes" })
+	@SuppressWarnings("rawtypes")
 	public HibernateOrmSearchQueryAdapter<R> applyGraph(RootGraph graph, GraphSemantic semantic) {
-		loadingOptions.entityGraphHint( new EntityGraphHint<>( graph, semantic ), true );
+		applyGraph( (RootGraphImplementor) graph, semantic );
 		return this;
 	}
 
 	@Override
-	public ScrollableResultsImplementor scroll() {
+	public ScrollableResultsImplementor<R> scroll() {
 		return scroll( ScrollMode.FORWARD_ONLY );
 	}
 
 	@Override
-	public ScrollableResultsImplementor scroll(ScrollMode scrollMode) {
+	protected ScrollableResultsImplementor<R> doScroll(ScrollMode scrollMode) {
 		if ( !ScrollMode.FORWARD_ONLY.equals( scrollMode ) ) {
 			throw log.canOnlyUseScrollWithScrollModeForwardsOnly( scrollMode );
 		}
 
 		int chunkSize = loadingOptions.fetchSize();
 		return new HibernateOrmSearchScrollableResultsAdapter<>( delegate.scroll( chunkSize ), getMaxResults(),
-				ScrollHitExtractor.singleObject() );
-	}
-
-	@Override
-	protected boolean isNativeQuery() {
-		return false;
+				Function.identity() );
 	}
 
 	@Override
 	protected List<R> doList() {
-		return delegate.fetchHits( firstResult, maxResults );
+		// Do not use getMaxRows()/getFirstRow() directly, they return weird values to comply with the JPA spec
+		Integer limit = getQueryOptions().getLimit().getMaxRows();
+		Integer offset = getQueryOptions().getLimit().getFirstRow();
+		return delegate.fetchHits( offset, limit );
+	}
+
+	@Override
+	protected void beforeQuery() {
+		super.beforeQuery();
+
+		extractQueryOptions();
+	}
+
+	private void extractQueryOptions() {
+		MutableQueryOptions queryOptions = getQueryOptions();
+		Integer queryFetchSize = queryOptions.getFetchSize();
+		if ( queryFetchSize != null ) {
+			loadingOptions.fetchSize( queryFetchSize );
+		}
+		Integer queryTimeout = queryOptions.getTimeout();
+		if ( queryTimeout != null ) {
+			delegate.failAfter( queryTimeout, TimeUnit.SECONDS );
+		}
+		EntityGraphHint<?> entityGraphHint = null;
+		if ( hasAppliedGraph( queryOptions ) ) {
+			AppliedGraph appliedGraph = queryOptions.getAppliedGraph();
+			RootGraph<?> graph = appliedGraph.getGraph();
+			if ( graph != null ) {
+				entityGraphHint = new EntityGraphHint<>( graph, appliedGraph.getSemantic() );
+			}
+		}
+		loadingOptions.entityGraphHint( entityGraphHint, true );
 	}
 
 	//-------------------------------------------------------------
 	// Unsupported ORM/JPA query methods
 	//-------------------------------------------------------------
 
-	/**
-	 * Return an iterator on the results.
-	 * Retrieve the object one by one (initialize it during the next() operation)
-	 */
-	@Override
-	public Iterator<R> iterate() {
-		throw new UnsupportedOperationException(
-				"iterate() is not implemented in Hibernate Search queries. Use scroll() instead." );
-	}
-
 	@Override
 	public Map<String, Object> getHints() {
 		throw new UnsupportedOperationException( "Not implemented yet" );
 	}
 
 	@Override
-	public <P> HibernateOrmSearchQueryAdapter<R> setParameter(Parameter<P> tParameter, P t) {
+	public ParameterMetadataImplementor getParameterMetadata() {
 		throw parametersNoSupported();
 	}
 
 	@Override
-	public HibernateOrmSearchQueryAdapter<R> setParameter(Parameter<Calendar> calendarParameter, Calendar calendar,
-			TemporalType temporalType) {
+	public QueryParameterBindings getParameterBindings() {
+		// parameters not supported in Hibernate Search queries
+		return QueryParameterBindings.NO_PARAM_BINDINGS;
+	}
+
+	@Override
+	public QueryParameterBindings getQueryParameterBindings() {
+		// parameters not supported in Hibernate Search queries
+		return QueryParameterBindings.NO_PARAM_BINDINGS;
+	}
+
+	@Override
+	protected <P> QueryParameterBinding<P> locateBinding(String name) {
 		throw parametersNoSupported();
 	}
 
 	@Override
-	public HibernateOrmSearchQueryAdapter<R> setParameter(Parameter<Date> dateParameter, Date date, TemporalType temporalType) {
+	protected <P> QueryParameterBinding<P> locateBinding(int position) {
 		throw parametersNoSupported();
 	}
 
 	@Override
-	public HibernateOrmSearchQueryAdapter<R> setParameter(String name, Object value) {
+	protected <P> QueryParameterBinding<P> locateBinding(Parameter<P> parameter) {
 		throw parametersNoSupported();
 	}
 
 	@Override
-	public HibernateOrmSearchQueryAdapter<R> setParameter(String name, Date value, TemporalType temporalType) {
-		throw parametersNoSupported();
-	}
-
-	@Override
-	public HibernateOrmSearchQueryAdapter<R> setParameter(String name, Calendar value, TemporalType temporalType) {
-		throw parametersNoSupported();
-	}
-
-	@Override
-	public HibernateOrmSearchQueryAdapter<R> setParameter(int position, Object value) {
-		throw parametersNoSupported();
-	}
-
-	@Override
-	public HibernateOrmSearchQueryAdapter<R> setParameter(int position, Date value, TemporalType temporalType) {
-		throw parametersNoSupported();
-	}
-
-	@Override
-	public Set<Parameter<?>> getParameters() {
-		return Collections.emptySet();
-	}
-
-	@Override
-	protected QueryParameterBindings getQueryParameterBindings() {
-		throw parametersNoSupported();
-	}
-
-	@Override
-	public HibernateOrmSearchQueryAdapter<R> setParameter(int position, Calendar value, TemporalType temporalType) {
-		throw parametersNoSupported();
-	}
-
-	@Override
-	public QueryParameter<?> getParameter(String name) {
-		throw parametersNoSupported();
-	}
-
-	@Override
-	public QueryParameter<?> getParameter(int position) {
-		throw parametersNoSupported();
-	}
-
-	@Override
-	public <T> QueryParameter<T> getParameter(String name, Class<T> type) {
-		throw parametersNoSupported();
-	}
-
-	@Override
-	public <T> QueryParameter<T> getParameter(int position, Class<T> type) {
-		throw parametersNoSupported();
-	}
-
-	@Override
-	public boolean isBound(Parameter<?> param) {
-		throw parametersNoSupported();
-	}
-
-	@Override
-	public <T> T getParameterValue(Parameter<T> param) {
-		throw parametersNoSupported();
-	}
-
-	@Override
-	public Object getParameterValue(String name) {
-		throw parametersNoSupported();
-	}
-
-	@Override
-	public Object getParameterValue(int position) {
+	protected <P> QueryParameterBinding<P> locateBinding(QueryParameterImplementor<P> parameter) {
 		throw parametersNoSupported();
 	}
 
@@ -353,18 +247,16 @@ private UnsupportedOperationException parametersNoSupported() {
 	}
 
 	@Override
-	public HibernateOrmSearchQueryAdapter<R> setLockOptions(LockOptions lockOptions) {
-		throw lockOptionsNotSupported();
+	public <T> QueryImplementor<T> setTupleTransformer(TupleTransformer<T> transformer) {
+		throw resultOrTupleTransformerNotImplemented();
 	}
 
-	@Deprecated
 	@Override
-	public HibernateOrmSearchQueryAdapter<R> setResultTransformer(ResultTransformer transformer) {
-		super.setResultTransformer( transformer );
-		throw resultTransformerNotImplemented();
+	public QueryImplementor<R> setResultListTransformer(ResultListTransformer<R> resultListTransformer) {
+		throw resultOrTupleTransformerNotImplemented();
 	}
 
-	private UnsupportedOperationException resultTransformerNotImplemented() {
+	private UnsupportedOperationException resultOrTupleTransformerNotImplemented() {
 		return new UnsupportedOperationException( "Result transformers are not supported in Hibernate Search queries" );
 	}
 
@@ -394,8 +286,13 @@ private UnsupportedOperationException lockOptionsNotSupported() {
 	}
 
 	@Override
-	public int executeUpdate() {
-		throw new UnsupportedOperationException( "executeUpdate is not supported in Hibernate Search queries" );
+	public int executeUpdate() throws HibernateException {
+		return doExecuteUpdate();
+	}
+
+	@Override
+	protected int doExecuteUpdate() {
+		throw new UnsupportedOperationException( "executeUpdate() is not supported in Hibernate Search queries" );
 	}
 
 	@Override
@@ -403,30 +300,6 @@ public HibernateOrmSearchQueryAdapter<R> setLockMode(String alias, LockMode lock
 		throw lockOptionsNotSupported();
 	}
 
-	@Deprecated
-	@Override
-	public Type[] getReturnTypes() {
-		throw new UnsupportedOperationException( "getReturnTypes() is not implemented in Hibernate Search queries" );
-	}
-
-	@Deprecated
-	@Override
-	public String[] getReturnAliases() {
-		throw new UnsupportedOperationException( "getReturnAliases() is not implemented in Hibernate Search queries" );
-	}
-
-	@Deprecated
-	@Override
-	public HibernateOrmSearchQueryAdapter<R> setEntity(int position, Object val) {
-		throw new UnsupportedOperationException( "setEntity(int,Object) is not implemented in Hibernate Search queries" );
-	}
-
-	@Deprecated
-	@Override
-	public HibernateOrmSearchQueryAdapter<R> setEntity(String name, Object val) {
-		throw new UnsupportedOperationException( "setEntity(String,Object) is not implemented in Hibernate Search queries" );
-	}
-
 	private static long hintValueToLong(Object value) {
 		if ( value instanceof Number ) {
 			return ( (Number) value ).longValue();
@@ -445,8 +318,4 @@ private static int hintValueToInteger(Object value) {
 		}
 	}
 
-	private static RootGraph<?> hintValueToEntityGraph(Object value) {
-		return (RootGraph<?>) value;
-	}
-
 }
diff --git a/main/java/org/hibernate/search/mapper/orm/search/query/spi/HibernateOrmSearchScrollableResultsAdapter.java b/main/java/org/hibernate/search/mapper/orm/search/query/spi/HibernateOrmSearchScrollableResultsAdapter.java
index 9d00283d91..8a1986f613 100644
--- a/main/java/org/hibernate/search/mapper/orm/search/query/spi/HibernateOrmSearchScrollableResultsAdapter.java
+++ b/main/java/org/hibernate/search/mapper/orm/search/query/spi/HibernateOrmSearchScrollableResultsAdapter.java
@@ -7,14 +7,7 @@
 package org.hibernate.search.mapper.orm.search.query.spi;
 
 import java.lang.invoke.MethodHandles;
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.sql.Blob;
-import java.sql.Clob;
-import java.util.Calendar;
-import java.util.Date;
-import java.util.Locale;
-import java.util.TimeZone;
+import java.util.function.Function;
 
 import jakarta.persistence.QueryTimeoutException;
 
@@ -25,15 +18,15 @@
 import org.hibernate.search.mapper.orm.logging.impl.Log;
 import org.hibernate.search.util.common.SearchTimeoutException;
 import org.hibernate.search.util.common.logging.impl.LoggerFactory;
-import org.hibernate.type.Type;
 
-public class HibernateOrmSearchScrollableResultsAdapter<H> implements ScrollableResults, ScrollableResultsImplementor {
+public class HibernateOrmSearchScrollableResultsAdapter<R, H>
+		implements ScrollableResults<R>, ScrollableResultsImplementor<R> {
 
 	private static final Log log = LoggerFactory.make( Log.class, MethodHandles.lookup() );
 
 	private final SearchScroll<H> scroll;
 	private final int maxResults;
-	private final ScrollHitExtractor<? super H> hitExtractor;
+	private final Function<? super H, ? extends R> hitExtractor;
 	private SearchScrollResult<H> currentChunk;
 	private H currentHit;
 	private int currentIndexInScroll;
@@ -42,7 +35,7 @@ public class HibernateOrmSearchScrollableResultsAdapter<H> implements Scrollable
 	private boolean closed;
 
 	public HibernateOrmSearchScrollableResultsAdapter(SearchScroll<H> scroll, int maxResults,
-			ScrollHitExtractor<? super H> hitExtractor) {
+			Function<? super H, ? extends R> hitExtractor) {
 		this.scroll = scroll;
 		this.maxResults = maxResults;
 		this.hitExtractor = hitExtractor;
@@ -183,6 +176,11 @@ public int getRowNumber() {
 		return currentIndexInScroll;
 	}
 
+	@Override
+	public boolean position(int position) {
+		return setRowNumber( position );
+	}
+
 	@Override
 	public boolean setRowNumber(int rowNumber) {
 		checkNotClosed();
@@ -196,132 +194,23 @@ public boolean setRowNumber(int rowNumber) {
 		return scroll( rowNumber - currentIndexInScroll );
 	}
 
+	// We cannot use @Override here because this method only exists in ORM 6.1.2+
+	public void setFetchSize(int i) {
+		throw log.cannotSetFetchSize();
+	}
+
 	@Override
 	public boolean isClosed() {
 		return closed;
 	}
 
 	@Override
-	public Object[] get() {
+	public R get() {
 		checkNotClosed();
 		if ( currentIndexInScroll < 0 || afterLast ) {
 			return null;
 		}
-		return hitExtractor.toArray( currentHit );
-	}
-
-	@Override
-	public Object get(int i) {
-		checkNotClosed();
-		if ( currentIndexInScroll < 0 || afterLast ) {
-			return null;
-		}
-		return hitExtractor.toElement( currentHit, i );
-	}
-
-	@Override
-	public Type getType(int i) {
-		throw columnTypesNotSupported();
-	}
-
-	@Override
-	public Integer getInteger(int col) {
-		throw columnTypesNotSupported();
-	}
-
-	@Override
-	public Long getLong(int col) {
-		throw columnTypesNotSupported();
-	}
-
-	@Override
-	public Float getFloat(int col) {
-		throw columnTypesNotSupported();
-	}
-
-	@Override
-	public Boolean getBoolean(int col) {
-		throw columnTypesNotSupported();
-	}
-
-	@Override
-	public Double getDouble(int col) {
-		throw columnTypesNotSupported();
-	}
-
-	@Override
-	public Short getShort(int col) {
-		throw columnTypesNotSupported();
-	}
-
-	@Override
-	public Byte getByte(int col) {
-		throw columnTypesNotSupported();
-	}
-
-	@Override
-	public Character getCharacter(int col) {
-		throw columnTypesNotSupported();
-	}
-
-	@Override
-	public byte[] getBinary(int col) {
-		throw columnTypesNotSupported();
-	}
-
-	@Override
-	public String getText(int col) {
-		throw columnTypesNotSupported();
-	}
-
-	@Override
-	public Blob getBlob(int col) {
-		throw columnTypesNotSupported();
-	}
-
-	@Override
-	public Clob getClob(int col) {
-		throw columnTypesNotSupported();
-	}
-
-	@Override
-	public String getString(int col) {
-		throw columnTypesNotSupported();
-	}
-
-	@Override
-	public BigDecimal getBigDecimal(int col) {
-		throw columnTypesNotSupported();
-	}
-
-	@Override
-	public BigInteger getBigInteger(int col) {
-		throw columnTypesNotSupported();
-	}
-
-	@Override
-	public Date getDate(int col) {
-		throw columnTypesNotSupported();
-	}
-
-	@Override
-	public Locale getLocale(int col) {
-		throw columnTypesNotSupported();
-	}
-
-	@Override
-	public Calendar getCalendar(int col) {
-		throw columnTypesNotSupported();
-	}
-
-	@Override
-	public TimeZone getTimeZone(int col) {
-		throw columnTypesNotSupported();
-	}
-
-	@Override
-	public int getNumberOfTypes() {
-		throw columnTypesNotSupported();
+		return hitExtractor.apply( currentHit );
 	}
 
 	private SearchScrollResult<H> nextChunk() {
@@ -333,43 +222,10 @@ private SearchScrollResult<H> nextChunk() {
 		}
 	}
 
-	private UnsupportedOperationException columnTypesNotSupported() {
-		return new UnsupportedOperationException( "column types not supported in Hibernate Search queries" );
-	}
-
 	private void checkNotClosed() {
 		if ( closed ) {
 			throw log.cannotUseClosedScrollableResults();
 		}
 	}
 
-	public interface ScrollHitExtractor<H> {
-		Object[] toArray(H hit);
-
-		Object toElement(H hit, int index);
-
-		@SuppressWarnings({ "unchecked", "rawtypes" }) // The instance works for any H
-		static <H> ScrollHitExtractor<H> singleObject() {
-			return (ScrollHitExtractor) SingleObjectScrollHitExtractor.INSTANCE;
-		}
-	}
-
-	private static final class SingleObjectScrollHitExtractor<H>
-			implements HibernateOrmSearchScrollableResultsAdapter.ScrollHitExtractor<H> {
-
-		private static final SingleObjectScrollHitExtractor<Object> INSTANCE = new SingleObjectScrollHitExtractor<>();
-
-		@Override
-		public Object[] toArray(H hit) {
-			return new Object[] { hit };
-		}
-
-		@Override
-		public Object toElement(H hit, int index) {
-			if ( index > 0 ) {
-				throw new IndexOutOfBoundsException();
-			}
-			return hit;
-		}
-	}
 }
