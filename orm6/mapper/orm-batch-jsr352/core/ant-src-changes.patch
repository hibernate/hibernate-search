diff --git a/main/java/org/hibernate/search/batch/jsr352/core/context/jpa/impl/ActiveSessionFactoryRegistryUpdater.java b/main/java/org/hibernate/search/batch/jsr352/core/context/jpa/impl/ActiveSessionFactoryRegistryUpdater.java
index 35980675a0..a49cd707ca 100644
--- a/main/java/org/hibernate/search/batch/jsr352/core/context/jpa/impl/ActiveSessionFactoryRegistryUpdater.java
+++ b/main/java/org/hibernate/search/batch/jsr352/core/context/jpa/impl/ActiveSessionFactoryRegistryUpdater.java
@@ -7,6 +7,7 @@
 package org.hibernate.search.batch.jsr352.core.context.jpa.impl;
 
 import org.hibernate.boot.Metadata;
+import org.hibernate.boot.spi.BootstrapContext;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
@@ -17,8 +18,8 @@
 public class ActiveSessionFactoryRegistryUpdater implements Integrator {
 
 	@Override
-	public void integrate(Metadata metadata, SessionFactoryImplementor sessionFactory,
-			SessionFactoryServiceRegistry serviceRegistry) {
+	public void integrate(Metadata metadata, BootstrapContext bootstrapContext,
+			SessionFactoryImplementor sessionFactory) {
 		ActiveSessionFactoryRegistry.getInstance().register( sessionFactory );
 	}
 
diff --git a/main/java/org/hibernate/search/batch/jsr352/core/massindexing/step/impl/HibernateSearchPartitionMapper.java b/main/java/org/hibernate/search/batch/jsr352/core/massindexing/step/impl/HibernateSearchPartitionMapper.java
index b70edc5152..21262a2c77 100644
--- a/main/java/org/hibernate/search/batch/jsr352/core/massindexing/step/impl/HibernateSearchPartitionMapper.java
+++ b/main/java/org/hibernate/search/batch/jsr352/core/massindexing/step/impl/HibernateSearchPartitionMapper.java
@@ -239,7 +239,7 @@ private List<PartitionBound> buildPartitionUnitsFrom(EntityManagerFactory emf, S
 			query.setMaxResults( maxResults );
 		}
 
-		try ( ScrollableResults scroll = query.scroll( ScrollMode.SCROLL_SENSITIVE ) ) {
+		try ( ScrollableResults<?> scroll = query.scroll( ScrollMode.SCROLL_SENSITIVE ) ) {
 			/*
 			 * The scroll results are originally positioned *before* the first element,
 			 * so we need to scroll rowsPerPartition + 1 positions to advanced to the
@@ -251,7 +251,7 @@ private List<PartitionBound> buildPartitionUnitsFrom(EntityManagerFactory emf, S
 
 			while ( scroll.scroll( rowsPerPartition ) ) {
 				lowerID = upperID;
-				upperID = scroll.get( 0 );
+				upperID = scroll.get();
 				partitionUnits.add( new PartitionBound( javaClass, lowerID, upperID, indexScope ) );
 			}
 
diff --git a/main/java/org/hibernate/search/batch/jsr352/core/massindexing/step/spi/EntityReader.java b/main/java/org/hibernate/search/batch/jsr352/core/massindexing/step/spi/EntityReader.java
index 9d1db50953..237341e6a5 100644
--- a/main/java/org/hibernate/search/batch/jsr352/core/massindexing/step/spi/EntityReader.java
+++ b/main/java/org/hibernate/search/batch/jsr352/core/massindexing/step/spi/EntityReader.java
@@ -402,7 +402,7 @@ else if ( lowerBound != null ) {
 
 	private interface FetchingStrategy {
 
-		ScrollableResults createScroll(Session session, CheckpointInfo lastCheckpointInfo);
+		ScrollableResults<?> createScroll(Session session, CheckpointInfo lastCheckpointInfo);
 
 	}
 
@@ -413,11 +413,11 @@ private static class ChunkState implements AutoCloseable {
 		private final int clearInterval;
 
 		private Session session;
-		private ScrollableResults scroll;
+		private ScrollableResults<?> scroll;
 
 		private CheckpointInfo lastCheckpointInfo;
 		private int processedEntityCount = 0;
-		private Serializable lastProcessedEntityId;
+		private Object lastProcessedEntityId;
 
 		public ChunkState(
 				EntityManagerFactory emf, String tenantId, FetchingStrategy fetchingStrategy, int clearInterval,
@@ -448,7 +448,7 @@ else if ( processedEntityCount % clearInterval == 0 ) {
 			if ( !scroll.next() ) {
 				return null;
 			}
-			Object entity = scroll.get( 0 );
+			Object entity = scroll.get();
 			lastProcessedEntityId = session.getIdentifier( entity );
 			++processedEntityCount;
 			return entity;
@@ -464,13 +464,13 @@ public Serializable end() {
 			if ( lastCheckpointInfo != null ) {
 				processedEntityCountInPartition += lastCheckpointInfo.getProcessedEntityCount();
 			}
-			Serializable lastProcessedEntityIdInPartition = lastProcessedEntityId;
+			Object lastProcessedEntityIdInPartition = lastProcessedEntityId;
 			if ( lastCheckpointInfo != null && lastProcessedEntityIdInPartition == null ) {
 				lastProcessedEntityIdInPartition = lastCheckpointInfo.getLastProcessedEntityId();
 			}
 			processedEntityCount = 0;
 			lastProcessedEntityId = null;
-			lastCheckpointInfo = new CheckpointInfo( lastProcessedEntityIdInPartition, processedEntityCountInPartition );
+			lastCheckpointInfo = new CheckpointInfo( (Serializable) lastProcessedEntityIdInPartition, processedEntityCountInPartition );
 			return lastCheckpointInfo;
 		}
 
diff --git a/main/java/org/hibernate/search/batch/jsr352/core/massindexing/util/impl/CompositeIdOrder.java b/main/java/org/hibernate/search/batch/jsr352/core/massindexing/util/impl/CompositeIdOrder.java
index 34524445c8..7a1b35c4b0 100644
--- a/main/java/org/hibernate/search/batch/jsr352/core/massindexing/util/impl/CompositeIdOrder.java
+++ b/main/java/org/hibernate/search/batch/jsr352/core/massindexing/util/impl/CompositeIdOrder.java
@@ -7,10 +7,7 @@
 package org.hibernate.search.batch.jsr352.core.massindexing.util.impl;
 
 import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Comparator;
 import java.util.List;
-import java.util.ListIterator;
 import java.util.function.BiFunction;
 
 import jakarta.persistence.EmbeddedId;
@@ -21,7 +18,8 @@
 import jakarta.persistence.criteria.Predicate;
 import jakarta.persistence.criteria.Root;
 
-import org.hibernate.type.ComponentType;
+import org.hibernate.metamodel.mapping.EmbeddableMappingType;
+import org.hibernate.metamodel.mapping.EntityIdentifierMapping;
 
 /**
  * Order over multiple ID attributes.
@@ -49,32 +47,12 @@
  */
 public class CompositeIdOrder implements IdOrder {
 
-	private final ComponentType componentType;
+	private final EntityIdentifierMapping mapping;
+	private final EmbeddableMappingType mappingType;
 
-	private final List<String> propertyPaths;
-
-	private final List<Integer> propertyIndices;
-
-	public CompositeIdOrder(String componentPath, ComponentType componentType) {
-		super();
-		this.componentType = componentType;
-
-		// Initialize with relative paths, but prepend a prefix below
-		this.propertyPaths = new ArrayList<>( Arrays.asList( componentType.getPropertyNames() ) );
-		this.propertyPaths.sort( Comparator.naturalOrder() );
-
-		String pathPrefix = componentPath == null ? "" : componentPath + ".";
-		this.propertyIndices = new ArrayList<>( propertyPaths.size() );
-		ListIterator<String> iterator = this.propertyPaths.listIterator();
-		while ( iterator.hasNext() ) {
-			String propertyName = iterator.next();
-
-			// We need the relative path of the property here
-			propertyIndices.add( componentType.getPropertyIndex( propertyName ) );
-
-			// Prepend the path prefix to each property; we will only use absolute path from now on
-			iterator.set( pathPrefix + propertyName );
-		}
+	public CompositeIdOrder(EntityIdentifierMapping mapping, EmbeddableMappingType mappingType) {
+		this.mapping = mapping;
+		this.mappingType = mappingType;
 	}
 
 	@Override
@@ -107,54 +85,51 @@ public Predicate idLesser(CriteriaBuilder builder, Root<?> root, Object idObj) {
 
 	@Override
 	public void addAscOrder(CriteriaBuilder builder, CriteriaQuery<?> criteria, Root<?> root) {
-		ArrayList<Order> orders = new ArrayList<>( propertyPaths.size() );
-		for ( String path : propertyPaths ) {
-			orders.add( builder.asc( root.get( path ) ) );
-		}
+		ArrayList<Order> orders = new ArrayList<>();
+		mapping.forEachSelectable( (i, selectable) ->
+				orders.add( builder.asc( root.get( selectable.getSelectablePath().getFullPath() ) ) ) );
 		criteria.orderBy( orders );
 	}
 
 	private Predicate restrictLexicographically(BiFunction<String, Object, Predicate> strictOperator,
 			CriteriaBuilder builder, Root<?> root, Object idObj, boolean orEquals) {
-		int propertyPathsSize = propertyPaths.size();
-		int expressionsInOr = propertyPathsSize + ( orEquals ? 1 : 0 );
+		Object[] selectableValues = mappingType.getValues( idObj );
+		int selectablesSize = selectableValues.length;
 
-		Predicate[] or = new Predicate[expressionsInOr];
+		List<Predicate> or = new ArrayList<>();
 
-		for ( int i = 0; i < propertyPathsSize; i++ ) {
+		mapping.forEachSelectable( (i, selectable) -> {
 			// Group expressions together in a single conjunction (A and B and C...).
 			Predicate[] and = new Predicate[i + 1];
-			int j = 0;
-			for ( ; j < and.length - 1; j++ ) {
-				// The first N-1 expressions have symbol `=`
-				String path = propertyPaths.get( j );
-				Object val = getPropertyValue( idObj, j );
-				and[j] = builder.equal( root.get( path ), val );
-			}
-			// The last expression has whatever symbol is defined by "strictOperator"
-			String path = propertyPaths.get( j );
-			Object val = getPropertyValue( idObj, j );
-			and[j] = strictOperator.apply( path, val );
 
-			or[i] = builder.and( and );
-		}
+			mapping.forEachSelectable( (j, previousSelectable) -> {
+				if ( j < i ) {
+					// The first N-1 expressions have symbol `=`
+					String path = previousSelectable.getSelectablePath().getFullPath();
+					Object val = selectableValues[j];
+					and[j] = builder.equal( root.get( path ), val );
+				}
+			} );
+			// The last expression has whatever symbol is defined by "strictOperator"
+			String path = selectable.getSelectablePath().getFullPath();
+			Object val = selectableValues[i];
+			and[i] = strictOperator.apply( path, val );
+
+			or.add( builder.and( and ) );
+		} );
 
 		if ( orEquals ) {
-			Predicate[] and = new Predicate[propertyPathsSize];
-			for ( int i = 0; i < propertyPathsSize; i++ ) {
-				String path = propertyPaths.get( i );
-				Object val = getPropertyValue( idObj, i );
+			Predicate[] and = new Predicate[selectablesSize];
+			mapping.forEachSelectable( (i, previousSelectable) -> {
+				String path = previousSelectable.getSelectablePath().getFullPath();
+				Object val = selectableValues[i];
 				and[i] = builder.equal( root.get( path ), val );
-			}
-			or[or.length - 1] = builder.and( and );
+			} );
+			or.add( builder.and( and ) );
 		}
 
 		// Group the disjunction of multiple expressions (X or Y or Z...).
-		return builder.or( or );
+		return builder.or( or.toArray( new Predicate[0] ) );
 	}
 
-	private Object getPropertyValue(Object obj, int ourIndex) {
-		int theirIndex = propertyIndices.get( ourIndex );
-		return componentType.getPropertyValue( obj, theirIndex );
-	}
 }
diff --git a/main/java/org/hibernate/search/batch/jsr352/core/massindexing/util/impl/PersistenceUtil.java b/main/java/org/hibernate/search/batch/jsr352/core/massindexing/util/impl/PersistenceUtil.java
index 2faf9f6a2e..51639b2963 100644
--- a/main/java/org/hibernate/search/batch/jsr352/core/massindexing/util/impl/PersistenceUtil.java
+++ b/main/java/org/hibernate/search/batch/jsr352/core/massindexing/util/impl/PersistenceUtil.java
@@ -19,12 +19,12 @@
 import org.hibernate.StatelessSession;
 import org.hibernate.StatelessSessionBuilder;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.metamodel.spi.MetamodelImplementor;
-import org.hibernate.persister.entity.EntityPersister;
+import org.hibernate.metamodel.MappingMetamodel;
+import org.hibernate.metamodel.mapping.EmbeddableMappingType;
+import org.hibernate.metamodel.mapping.EntityIdentifierMapping;
+import org.hibernate.metamodel.mapping.EntityMappingType;
 import org.hibernate.search.batch.jsr352.core.massindexing.step.impl.IndexScope;
 import org.hibernate.search.util.common.impl.StringHelper;
-import org.hibernate.type.ComponentType;
-import org.hibernate.type.Type;
 
 /**
  * Internal utility class for persistence usage.
@@ -96,28 +96,27 @@ public static IndexScope getIndexScope(String hql) {
 	public static List<EntityTypeDescriptor> createDescriptors(EntityManagerFactory entityManagerFactory, Set<Class<?>> types) {
 		SessionFactoryImplementor sessionFactory = entityManagerFactory.unwrap( SessionFactoryImplementor.class );
 		List<EntityTypeDescriptor> result = new ArrayList<>( types.size() );
-		MetamodelImplementor metamodel = sessionFactory.getMetamodel();
+		MappingMetamodel metamodel = sessionFactory.getMappingMetamodel();
 		for ( Class<?> type : types ) {
 			result.add( createDescriptor( metamodel, type ) );
 		}
 		return result;
 	}
 
-	private static <T> EntityTypeDescriptor createDescriptor(MetamodelImplementor metamodel, Class<T> type) {
-		EntityPersister entityPersister = metamodel.entityPersister( type );
-		IdOrder idOrder = createIdOrder( entityPersister );
+	private static <T> EntityTypeDescriptor createDescriptor(MappingMetamodel metamodel, Class<T> type) {
+		EntityMappingType entityMappingType = metamodel.findEntityDescriptor( type );
+		IdOrder idOrder = createIdOrder( entityMappingType );
 		return new EntityTypeDescriptor( type, idOrder );
 	}
 
-	private static IdOrder createIdOrder(EntityPersister entityPersister) {
-		final String identifierPropertyName = entityPersister.getIdentifierPropertyName();
-		final Type identifierType = entityPersister.getIdentifierType();
-		if ( identifierType instanceof ComponentType ) {
-			final ComponentType componentType = (ComponentType) identifierType;
-			return new CompositeIdOrder( identifierPropertyName, componentType );
+	private static IdOrder createIdOrder(EntityMappingType entityMappingType) {
+		EntityIdentifierMapping identifierMapping = entityMappingType.getIdentifierMapping();
+		if ( identifierMapping.getPartMappingType() instanceof EmbeddableMappingType ) {
+			return new CompositeIdOrder( identifierMapping,
+					(EmbeddableMappingType) identifierMapping.getPartMappingType() );
 		}
 		else {
-			return new SingularIdOrder( identifierPropertyName );
+			return new SingularIdOrder( identifierMapping.getAttributeName() );
 		}
 	}
 
