<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Hibernate, Relational Persistence for Idiomatic Java
  ~
  ~ Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  ~ indicated by the @author tags or express copyright attribution
  ~ statements applied by the authors.  All third-party contributions are
  ~ distributed under license by Red Hat Middleware LLC.
  ~
  ~ This copyrighted material is made available to anyone wishing to use, modify,
  ~ copy, or redistribute it subject to the terms and conditions of the GNU
  ~ Lesser General Public License, as published by the Free Software Foundation.
  ~
  ~ This program is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~ for more details.
  ~
  ~ You should have received a copy of the GNU Lesser General Public License
  ~ along with this distribution; if not, write to:
  ~ Free Software Foundation, Inc.
  ~ 51 Franklin Street, Fifth Floor
  ~ Boston, MA  02110-1301  USA
  -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="search-batchindex">
  <!--  $Id$ -->

  <title>Manual indexing</title>

  <section id="search-batchindex-indexing">
    <title>Indexing</title>

    <para>It is sometimes useful to index an entity even if this entity is not
    inserted or updated to the database. This is for example the case when you
    want to build your index for the first time.
    <classname>FullTextSession</classname>.<methodname>index()</methodname>
    allows you to do so.</para>

    <example>
      <title>Indexing an entity via
      <methodname>FullTextSession.index()</methodname></title>

      <programlisting>FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
for (Customer customer : customers) {
    <emphasis role="bold">fullTextSession.index(customer);</emphasis>
}
tx.commit(); //index are written at commit time    </programlisting>
    </example>

    <para>For maximum efficiency, Hibernate Search batches index operations
    and executes them at commit time. If you expect to index a lot of data,
    however, you need to be careful about memory consumption since all
    documents are kept in a queue until the transaction commit. You can
    potentially face an <classname>OutOfMemoryException</classname>. To avoid
    this exception, you can use
    <methodname>fullTextSession.flushToIndexes()</methodname>. Every time
    <methodname>fullTextSession.flushToIndexes()</methodname> is called (or if
    the transaction is committed), the batch queue is processed (freeing
    memory) applying all index changes. Be aware that once flushed changes
    cannot be rolled back.</para>

    <note>
      <para><literal>hibernate.search.worker.batch_size</literal> has been
      deprecated in favor of this explicit API which provides better
      control</para>
    </note>

    <para>Other parameters which also can affect indexing time and memory
    consumption are:</para>

    <itemizedlist>
      <listitem>
        <literal>hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].max_buffered_docs</literal>
      </listitem>

      <listitem>
        <literal>hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].max_field_length</literal>
      </listitem>

      <listitem>
        <literal>hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].max_merge_docs</literal>
      </listitem>

      <listitem>
        <literal>hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].merge_factor</literal>
      </listitem>

      <listitem>
        <literal>hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].ram_buffer_size</literal>
      </listitem>

      <listitem>
        <literal>hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].term_index_interval</literal>
      </listitem>
    </itemizedlist>

    <para>These parameters are Lucene specific and Hibernate Search is just
    passing these parameters through - see <xref
    linkend="lucene-indexing-performance" /> for more details.</para>

    <example>
      <title>Efficiently indexing a given class (useful for index
      (re)initialization)</title>

      <programlisting>fullTextSession.setFlushMode(FlushMode.MANUAL);
fullTextSession.setCacheMode(CacheMode.IGNORE);
transaction = fullTextSession.beginTransaction();
//Scrollable results will avoid loading too many objects in memory
ScrollableResults results = fullTextSession.createCriteria( Email.class )
    .setFetchSize(BATCH_SIZE)
    .scroll( ScrollMode.FORWARD_ONLY );
int index = 0;
while( results.next() ) {
    index++;
    fullTextSession.index( results.get(0) ); //index each element
    if (index % BATCH_SIZE == 0) {
        fullTextSession.flushToIndexes(); //apply changes to indexes
        fullTextSession.clear(); //clear since the queue is processed
    }
}
transaction.commit();</programlisting>
    </example>

    <para>Try to use a batch size that guarantees that your application will
    not run out of memory.</para>
  </section>

  <section>
    <title>Purging</title>

    <para>It is equally possible to remove an entity or all entities of a
    given type from a Lucene index without the need to physically remove them
    from the database. This operation is named purging and is also done
    through the <classname>FullTextSession</classname>.</para>

    <example>
      <title>Purging a specific instance of an entity from the index</title>

      <programlisting>FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
for (Customer customer : customers) {
    <emphasis role="bold">fullTextSession.purge( Customer.class, customer.getId() );</emphasis>
}
tx.commit(); //index are written at commit time    </programlisting>
    </example>

    <para>Purging will remove the entity with the given id from the Lucene
    index but will not touch the database.</para>

    <para>If you need to remove all entities of a given type, you can use the
    <methodname>purgeAll</methodname> method. This operation remove all
    entities of the type passed as a parameter as well as all its
    subtypes.</para>

    <example>
      <title>Purging all instances of an entity from the index</title>

      <programlisting>FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
<emphasis role="bold">fullTextSession.purgeAll( Customer.class );</emphasis>
//optionally optimize the index
//fullTextSession.getSearchFactory().optimize( Customer.class );
tx.commit(); //index are written at commit time    </programlisting>
    </example>

    <para>It is recommended to optimize the index after such an
    operation.</para>

    <note>
      <para>Methods <methodname>index</methodname>,
      <methodname>purge</methodname> and <methodname>purgeAll</methodname> are
      available on <classname>FullTextEntityManager</classname> as
      well.</para>
    </note>
  </section>
</chapter>
