# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2011-09-20 09:48+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: configuration.xml:31
#, no-c-format
msgid "Configuration"
msgstr ""

#. Tag: title
#: configuration.xml:34
#, no-c-format
msgid "Enabling Hibernate Search and automatic indexing"
msgstr ""

#. Tag: para
#: configuration.xml:36
#, no-c-format
msgid "Let's start with the most basic configuration question - how to enable Hibernate Search in your system."
msgstr ""

#. Tag: title
#: configuration.xml:40
#, no-c-format
msgid "Enabling Hibernate Search"
msgstr ""

#. Tag: para
#: configuration.xml:42
#, no-c-format
msgid "The good news is that Hibernate Search is enabled out of the box when detected on the classpath by Hibernate Core. If, for some reason you need to disable it, set <literal>hibernate.search.autoregister_listeners</literal> to false. Note that there is no performance penalty when the listeners are enabled but no entities are annotated as indexed."
msgstr ""

#. Tag: title
#: configuration.xml:51
#, no-c-format
msgid "Automatic indexing"
msgstr ""

#. Tag: para
#: configuration.xml:53
#, no-c-format
msgid "By default, every time an object is inserted, updated or deleted through Hibernate, Hibernate Search updates the according Lucene index. It is sometimes desirable to disable that features if either your index is read-only or if index updates are done in a batch way (see <xref linkend=\"search-batchindex\"/>)."
msgstr ""

#. Tag: para
#: configuration.xml:59
#, no-c-format
msgid "To disable event based indexing, set"
msgstr ""

#. Tag: programlisting
#: configuration.xml:61
#, no-c-format
msgid "hibernate.search.indexing_strategy = manual"
msgstr ""

#. Tag: para
#: configuration.xml:64
#, no-c-format
msgid "In most case, the JMS backend provides the best of both world, a lightweight event based system keeps track of all changes in the system, and the heavyweight indexing process is done by a separate process or machine."
msgstr ""

#. Tag: title
#: configuration.xml:73
#, no-c-format
msgid "Directory configuration"
msgstr ""

#. Tag: para
#: configuration.xml:75
#, no-c-format
msgid "Apache Lucene has a notion of a <classname>Directory</classname> to store the index files. The <classname>Directory</classname> implementation can be customized and Lucene comes bundled with a file system and an in-memory implementation. <classname>DirectoryProvider</classname> is the Hibernate Search abstraction around a Lucene <classname>Directory</classname> and handles the configuration and the initialization of the underlying Lucene resources. <xref linkend=\"directory-provider-table\"/> shows the list of the directory providers available in Hibernate Search together with their corresponding options."
msgstr ""

#. Tag: para
#: configuration.xml:86
#, no-c-format
msgid "To configure your <classname>DirectoryProvider</classname> you have to understand that each indexed entity is associated to a Lucene index (except of the case where multiple entities share the same index - <xref linkend=\"section-sharing-indexes\"/>). The name of the index is given by the <constant>index</constant> property of the <classname>@Indexed</classname> annotation. If the <constant>index</constant> property is not specified the fully qualified name of the indexed class will be used as name (recommended)."
msgstr ""

#. Tag: para
#: configuration.xml:95
#, no-c-format
msgid "For each index, an <classname>IndexManager</classname> is created, which holds references to <classname>ReaderProvider</classname> instances used by Hibernate Search to perform queries (see <xref linkend=\"IndexReaders\"/>) and to each backend, used to apply updates to the index."
msgstr ""

#. Tag: para
#: configuration.xml:101
#, no-c-format
msgid "Knowing the index name, you can configure the directory provider and any additional options by using the prefix <constant>hibernate.search.</constant><replaceable>&lt;indexname&gt;</replaceable>. The name <constant>default</constant> (<constant>hibernate.search.default</constant>) is reserved and can be used to define properties which apply to all indexes. <xref linkend=\"example-configuring-directory-providers\"/> shows how <constant>hibernate.search.default.directory_provider</constant> is used to set the default directory provider to be the filesystem one. <constant>hibernate.search.default.indexBase</constant> sets then the default base directory for the indexes. As a result the index for the entity <classname>Status</classname> is created in <filename>/usr/lucene/indexes/org.hibernate.example.Status</filename>."
msgstr ""

#. Tag: para
#: configuration.xml:115
#, no-c-format
msgid "The index for the <classname>Rule</classname> entity, however, is using an in-memory directory, because the default directory provider for this entity is overriden by the property <constant>hibernate.search.Rules.directory_provider</constant>."
msgstr ""

#. Tag: para
#: configuration.xml:120
#, no-c-format
msgid "Finally the <classname>Action</classname> entity uses a custom directory provider <classname>CustomDirectoryProvider</classname> specified via <constant>hibernate.search.Actions.directory_provider</constant>."
msgstr ""

#. Tag: title
#: configuration.xml:126
#, no-c-format
msgid "Specifying the index name"
msgstr ""

#. Tag: programlisting
#: configuration.xml:128
#, no-c-format
msgid ""
      "package org.hibernate.example;\n"
      "\n"
      "@Indexed\n"
      "public class Status { ... }\n"
      "\n"
      "@Indexed(index=\"Rules\")\n"
      "public class Rule { ... }\n"
      "\n"
      "@Indexed(index=\"Actions\")\n"
      "public class Action { ... }"
msgstr ""

#. Tag: title
#: configuration.xml:132
#, no-c-format
msgid "Configuring directory providers"
msgstr ""

#. Tag: programlisting
#: configuration.xml:134
#, no-c-format
msgid ""
      "hibernate.search.default.directory_provider filesystem\n"
      "hibernate.search.default.indexBase=/usr/lucene/indexes\n"
      "hibernate.search.Rules.directory_provider ram\n"
      "hibernate.search.Actions.directory_provider com.acme.hibernate.CustomDirectoryProvider"
msgstr ""

#. Tag: para
#: configuration.xml:138
#, no-c-format
msgid "Using the described configuration scheme you can easily define common rules like the directory provider and base directory, and override those defaults later on on a per index basis."
msgstr ""

#. Tag: title
#: configuration.xml:144
#, no-c-format
msgid "List of built-in <classname>DirectoryProvider</classname>s"
msgstr ""

#. Tag: entry
#: configuration.xml:150
#, no-c-format
msgid "Class or shortcut name"
msgstr ""

#. Tag: entry
#: configuration.xml:152 configuration.xml:1185 configuration.xml:1553
#, no-c-format
msgid "<entry>Description</entry>"
msgstr ""

#. Tag: entry
#: configuration.xml:154
#, no-c-format
msgid "Properties"
msgstr ""

#. Tag: entry
#: configuration.xml:160
#, no-c-format
msgid "<entry>ram</entry>"
msgstr ""

#. Tag: entry
#: configuration.xml:162
#, no-c-format
msgid "Memory based directory, the directory will be uniquely identified (in the same deployment unit) by the <literal>@Indexed.index</literal> element"
msgstr ""

#. Tag: entry
#: configuration.xml:166 configuration.xml:1599
#, no-c-format
msgid "none"
msgstr ""

#. Tag: entry
#: configuration.xml:170
#, no-c-format
msgid "filesystem"
msgstr ""

#. Tag: entry
#: configuration.xml:172
#, no-c-format
msgid "File system based directory. The directory used will be &lt;indexBase&gt;/&lt; indexName &gt;"
msgstr ""

#. Tag: para
#: configuration.xml:175
#, no-c-format
msgid "<literal>indexBase</literal> : Base directory"
msgstr ""

#. Tag: para
#: configuration.xml:176 configuration.xml:216 configuration.xml:267
#, no-c-format
msgid "<literal>indexName</literal>: override @Indexed.index (useful for sharded indexes)"
msgstr ""

#. Tag: para
#: configuration.xml:178 configuration.xml:228 configuration.xml:279
#, no-c-format
msgid "<literal>locking_strategy</literal> : optional, see"
msgstr ""

#. Tag: para
#: configuration.xml:181 configuration.xml:231 configuration.xml:296
#, no-c-format
msgid "<literal>filesystem_access_type</literal>: allows to determine the exact type of <classname>FSDirectory</classname> implementation used by this <classname>DirectoryProvider</classname>. Allowed values are <literal>auto</literal> (the default value, selects <classname>NIOFSDirectory</classname> on non Windows systems, <classname>SimpleFSDirectory</classname> on Windows), <literal>simple</literal> (<classname>SimpleFSDirectory</classname>), <literal>nio</literal> (<classname>NIOFSDirectory</classname>), <literal>mmap</literal> (<classname>MMapDirectory</classname>). Make sure to refer to Javadocs of these <classname>Directory</classname> implementations before changing this setting. Even though <classname>NIOFSDirectory</classname> or <classname>MMapDirectory</classname> can bring substantial performace boosts they also have their issues."
msgstr ""

#. Tag: entry
#: configuration.xml:200
#, no-c-format
msgid "filesystem-master"
msgstr ""

#. Tag: para
#: configuration.xml:202
#, no-c-format
msgid "File system based directory. Like <literal>filesystem</literal>. It also copies the index to a source directory (aka copy directory) on a regular basis."
msgstr ""

#. Tag: para
#: configuration.xml:205 configuration.xml:255
#, no-c-format
msgid "The recommended value for the refresh period is (at least) 50% higher that the time to copy the information (default 3600 seconds - 60 minutes)."
msgstr ""

#. Tag: para
#: configuration.xml:207 configuration.xml:258
#, no-c-format
msgid "Note that the copy is based on an incremental copy mechanism reducing the average copy time."
msgstr ""

#. Tag: para
#: configuration.xml:209
#, no-c-format
msgid "DirectoryProvider typically used on the master node in a JMS back end cluster."
msgstr ""

#. Tag: para
#: configuration.xml:210 configuration.xml:261
#, no-c-format
msgid "The <literal> buffer_size_on_copy</literal> optimum depends on your operating system and available RAM; most people reported good results using values between 16 and 64MB."
msgstr ""

#. Tag: para
#: configuration.xml:215 configuration.xml:266
#, no-c-format
msgid "<literal>indexBase</literal>: Base directory"
msgstr ""

#. Tag: para
#: configuration.xml:218 configuration.xml:269
#, no-c-format
msgid "<literal>sourceBase</literal>: Source (copy) base directory."
msgstr ""

#. Tag: para
#: configuration.xml:219 configuration.xml:270
#, no-c-format
msgid "<literal>source</literal>: Source directory suffix (default to <literal>@Indexed.index</literal>). The actual source directory name being <filename>&lt;sourceBase&gt;/&lt;source&gt;</filename>"
msgstr ""

#. Tag: para
#: configuration.xml:223 configuration.xml:274
#, no-c-format
msgid "<literal>refresh</literal>: refresh period in second (the copy will take place every refresh seconds)."
msgstr ""

#. Tag: para
#: configuration.xml:225 configuration.xml:276
#, no-c-format
msgid "<literal>buffer_size_on_copy</literal>: The amount of MegaBytes to move in a single low level copy instruction; defaults to 16MB."
msgstr ""

#. Tag: entry
#: configuration.xml:250
#, no-c-format
msgid "filesystem-slave"
msgstr ""

#. Tag: para
#: configuration.xml:252
#, no-c-format
msgid "File system based directory. Like <literal>filesystem</literal>, but retrieves a master version (source) on a regular basis. To avoid locking and inconsistent search results, 2 local copies are kept."
msgstr ""

#. Tag: para
#: configuration.xml:260
#, no-c-format
msgid "DirectoryProvider typically used on slave nodes using a JMS back end."
msgstr ""

#. Tag: para
#: configuration.xml:282
#, no-c-format
msgid "<literal>retry_marker_lookup</literal> : optional, default to 0. Defines how many times we look for the marker files in the source directory before failing. Waiting 5 seconds between each try."
msgstr ""

#. Tag: para
#: configuration.xml:285
#, no-c-format
msgid "<literal>retry_initialize_period</literal> : optional, set an integer value in seconds to enable the retry initialize feature: if the slave can't find the master index it will try again until it's found in background, without preventing the application to start: fullText queries performed before the index is initialized are not blocked but will return empty results. When not enabling the option or explicitly setting it to zero it will fail with an exception instead of scheduling a retry timer. To prevent the application from starting without an invalid index but still control an initialization timeout, see <literal>retry_marker_lookup</literal> instead."
msgstr ""

#. Tag: entry
#: configuration.xml:315
#, no-c-format
msgid "infinispan"
msgstr ""

#. Tag: para
#: configuration.xml:317
#, no-c-format
msgid "Infinispan based directory. Use it to store the index in a distributed grid, making index changes visible to all elements of the cluster very quickly. Also see <xref linkend=\"infinispan-directories\"/> for additional requirements and configuration settings. Infinispan needs a global configuration and additional dependencies; the settings defined here apply to each different index."
msgstr ""

#. Tag: para
#: configuration.xml:325
#, no-c-format
msgid "<literal>locking_cachename</literal>: name of the Infinispan cache to use to store locks."
msgstr ""

#. Tag: para
#: configuration.xml:327
#, no-c-format
msgid "<literal>data_cachename</literal> : name of the Infinispan cache to use to store the largest data chunks; this area will contain the largest objects, use replication if you have enough memory or switch to distribution."
msgstr ""

#. Tag: para
#: configuration.xml:331
#, no-c-format
msgid "<literal>metadata_cachename</literal>: name of the Infinispan cache to use to store the metadata relating to the index; this data is rather small and read very often, it's recommended to have this cache setup using replication."
msgstr ""

#. Tag: para
#: configuration.xml:335
#, no-c-format
msgid "<literal>chunk_size</literal>: large files of the index are split in smaller chunks, you might want to set the highest value efficiently handled by your network. Networking tuning might be useful."
msgstr ""

#. Tag: para
#: configuration.xml:345
#, no-c-format
msgid "If the built-in directory providers do not fit your needs, you can write your own directory provider by implementing the <classname>org.hibernate.store.DirectoryProvider</classname> interface. In this case, pass the fully qualified class name of your provider into the <literal>directory_provider</literal> property. You can pass any additional properties using the prefix <constant>hibernate.search.</constant><replaceable>&lt;indexname&gt;</replaceable>."
msgstr ""

#. Tag: title
#: configuration.xml:356
#, no-c-format
msgid "Sharding indexes"
msgstr ""

#. Tag: para
#: configuration.xml:358
#, no-c-format
msgid "In some cases it can be useful to split (shard) the indexed data of a given entity into several Lucene indexes."
msgstr ""

#. Tag: para
#: configuration.xml:362
#, no-c-format
msgid "This solution is not recommended unless there is a pressing need. Searches will be slower as all shards have to be opened for a single search. Don't do it until you have a real use case!"
msgstr ""

#. Tag: para
#: configuration.xml:367
#, no-c-format
msgid "Possible use cases for sharding are:"
msgstr ""

#. Tag: para
#: configuration.xml:371
#, no-c-format
msgid "A single index is so huge that index update times are slowing the application down."
msgstr ""

#. Tag: para
#: configuration.xml:376
#, no-c-format
msgid "A typical search will only hit a sub-set of the index, such as when data is naturally segmented by customer, region or application."
msgstr ""

#. Tag: para
#: configuration.xml:382
#, no-c-format
msgid "By default sharding is not enabled unless the number of shards is configured. To do this use the <constant>hibernate.search.&lt;indexName&gt;.sharding_strategy.nbr_of_shards</constant> property as seen in <xref linkend=\"example-index-sharding\"/>. In this example 5 shards are enabled."
msgstr ""

#. Tag: title
#: configuration.xml:389
#, no-c-format
msgid "Enabling index sharding"
msgstr ""

#. Tag: programlisting
#: configuration.xml:391
#, no-c-format
msgid "hibernate.search.&lt;indexName&gt;.sharding_strategy.nbr_of_shards 5"
msgstr ""

#. Tag: para
#: configuration.xml:394
#, no-c-format
msgid "Responsible for splitting the data into sub-indexes is the <classname>IndexShardingStrategy</classname>. The default sharding strategy splits the data according to the hash value of the id string representation (generated by the <classname>FieldBridge</classname>). This ensures a fairly balanced sharding. You can replace the default strategy by implementing a custom <classname>IndexShardingStrategy</classname>. To use your custom strategy you have to set the <constant>hibernate.search.&lt;indexName&gt;.sharding_strategy</constant> property."
msgstr ""

#. Tag: title
#: configuration.xml:405
#, no-c-format
msgid "Specifying a custom sharding strategy"
msgstr ""

#. Tag: programlisting
#: configuration.xml:407
#, no-c-format
msgid "hibernate.search.&lt;indexName&gt;.sharding_strategy my.shardingstrategy.Implementation"
msgstr ""

#. Tag: para
#: configuration.xml:410
#, no-c-format
msgid "The <classname> IndexShardingStrategy</classname> also allows for optimizing searches by selecting which shard to run the query against. By activating a filter (see <xref linkend=\"query-filter-shard\"/>), a sharding strategy can select a subset of the shards used to answer a query (<classname>IndexShardingStrategy.getIndexManagersForQuery</classname>) and thus speed up the query execution."
msgstr ""

#. Tag: para
#: configuration.xml:417
#, no-c-format
msgid "Each shard has an independent <classname>IndexManager</classname> and so can be configured to use a different directory provider and backend configurations. The <classname>IndexManager</classname> index names for the Animal entity in <xref linkend=\"example-sharding-configuration\"/> are <literal>Animal.0</literal> to <literal>Animal.4</literal>. In other words, each shard has the name of it's owning index followed by <constant>.</constant> (dot) and its index number (see also <xref linkend=\"search-configuration-directory\"/>)."
msgstr ""

#. Tag: title
#: configuration.xml:427
#, no-c-format
msgid "Sharding configuration for entity <classname>Animal</classname>"
msgstr ""

#. Tag: programlisting
#: configuration.xml:430
#, no-c-format
msgid ""
      "hibernate.search.default.indexBase /usr/lucene/indexes\n"
      "\n"
      "hibernate.search.Animal.sharding_strategy.nbr_of_shards 5\n"
      "hibernate.search.Animal.directory_provider filesystem\n"
      "hibernate.search.Animal.0.indexName Animal00\n"
      "hibernate.search.Animal.3.indexBase /usr/lucene/sharded\n"
      "hibernate.search.Animal.3.indexName Animal03"
msgstr ""

#. Tag: para
#: configuration.xml:433
#, no-c-format
msgid "In <xref linkend=\"example-sharding-configuration\"/>, the configuration uses the default id string hashing strategy and shards the <classname>Animal</classname> index into 5 sub-indexes. All sub-indexes are filesystem instances and the directory where each sub-index is stored is as followed:"
msgstr ""

#. Tag: para
#: configuration.xml:441
#, no-c-format
msgid "for sub-index 0: <filename>/usr/lucene/indexes/Animal00</filename> (shared indexBase but overridden indexName)"
msgstr ""

#. Tag: para
#: configuration.xml:447
#, no-c-format
msgid "for sub-index 1: <filename>/usr/lucene/indexes/Animal.1</filename> (shared indexBase, default indexName)"
msgstr ""

#. Tag: para
#: configuration.xml:453
#, no-c-format
msgid "for sub-index 2: <filename>/usr/lucene/indexes/Animal.2</filename> (shared indexBase, default indexName)"
msgstr ""

#. Tag: para
#: configuration.xml:459
#, no-c-format
msgid "for sub-index 3: <filename>/usr/lucene/shared/Animal03</filename> (overridden indexBase, overridden indexName)"
msgstr ""

#. Tag: para
#: configuration.xml:465
#, no-c-format
msgid "for sub-index 4: <filename>/usr/lucene/indexes/Animal.4</filename> (shared indexBase, default indexName)"
msgstr ""

#. Tag: title
#: configuration.xml:473
#, no-c-format
msgid "Sharing indexes"
msgstr ""

#. Tag: para
#: configuration.xml:475
#, no-c-format
msgid "It is technically possible to store the information of more than one entity into a single Lucene index. There are two ways to accomplish this:"
msgstr ""

#. Tag: para
#: configuration.xml:481
#, no-c-format
msgid "Configuring the underlying directory providers to point to the same physical index directory. In practice, you set the property <literal>hibernate.search.[fully qualified entity name].indexName</literal> to the same value. As an example let’s use the same index (directory) for the <classname>Furniture</classname> and <classname>Animal</classname> entity. We just set <literal>indexName</literal> for both entities to for example “Animal”. Both entities will then be stored in the Animal directory."
msgstr ""

#. Tag: programlisting
#: configuration.xml:491
#, no-c-format
msgid ""
      "hibernate.search.org.hibernate.search.test.shards.Furniture.indexName = Animal\n"
      "hibernate.search.org.hibernate.search.test.shards.Animal.indexName = Animal"
msgstr ""

#. Tag: para
#: configuration.xml:495
#, no-c-format
msgid "Setting the <code>@Indexed</code> annotation’s <methodname>index</methodname> attribute of the entities you want to merge to the same value. If we again wanted all <classname>Furniture</classname> instances to be indexed in the <classname>Animal</classname> index along with all instances of <classname>Animal</classname> we would specify <code>@Indexed(index=\"Animal\")</code> on both <classname>Animal</classname> and <classname>Furniture</classname> classes."
msgstr ""

#. Tag: para
#: configuration.xml:504
#, no-c-format
msgid "This is only presented here so that you know the option is available. There is really not much benefit in sharing indexes."
msgstr ""

#. Tag: title
#: configuration.xml:513
#, no-c-format
msgid "Worker configuration"
msgstr ""

#. Tag: para
#: configuration.xml:515
#, no-c-format
msgid "It is possible to refine how Hibernate Search interacts with Lucene through the worker configuration. There exist several architectural components and possible extension points. Let's have a closer look."
msgstr ""

#. Tag: para
#: configuration.xml:519
#, no-c-format
msgid "First there is a <classname>Worker</classname>. An implementation of the <classname>Worker</classname> interface is reponsible for receiving all entity changes, queuing them by context and applying them once a context ends. The most intuative context, especially in connection with ORM, is the transaction. For this reason Hibernate Search will per default use the <classname>TransactionalWorker</classname> to scope all changes per transaction. One can, however, imagine a scenario where the context depends for example on the number of entity changes or some other application (lifecycle) events. For this reason the <classname>Worker</classname> implementation is configurable as shown in <xref linkend=\"table-worker-configuration\"/>."
msgstr ""

#. Tag: title
#: configuration.xml:532
#, no-c-format
msgid "Scope configuration"
msgstr ""

#. Tag: emphasis
#: configuration.xml:537 configuration.xml:595 configuration.xml:643 configuration.xml:684 configuration.xml:722
#, no-c-format
msgid "<emphasis>Property</emphasis>"
msgstr ""

#. Tag: emphasis
#: configuration.xml:539 configuration.xml:597 configuration.xml:645 configuration.xml:686 configuration.xml:724
#, no-c-format
msgid "<emphasis>Description</emphasis>"
msgstr ""

#. Tag: literal
#: configuration.xml:543
#, no-c-format
msgid "hibernate.search.worker.scope"
msgstr ""

#. Tag: entry
#: configuration.xml:545
#, no-c-format
msgid "The fully qualifed class name of the <classname>Worker</classname> implementation to use. If this property is not set, empty or <literal>transaction</literal> the default <classname>TransactionalWorker</classname> is used."
msgstr ""

#. Tag: literal
#: configuration.xml:553
#, no-c-format
msgid "hibernate.search.worker.*"
msgstr ""

#. Tag: entry
#: configuration.xml:555
#, no-c-format
msgid "All configuration properties prefixed with <literal>hibernate.search.worker</literal> are passed to the Worker during initialization. This allows adding custom, worker specific parameters."
msgstr ""

#. Tag: literal
#: configuration.xml:562
#, no-c-format
msgid "hibernate.search.worker.batch_size"
msgstr ""

#. Tag: entry
#: configuration.xml:564
#, no-c-format
msgid "Defines the maximum number of indexing operation batched per context. Once the limit is reached indexing will be triggered even though the context has not ended yet. This property only works if the <classname>Worker</classname> implementation delegates the queued work to BatchedQueueingProcessor (which is what the <classname>TransactionalWorker</classname> does)"
msgstr ""

#. Tag: para
#: configuration.xml:575
#, no-c-format
msgid "Once a context ends it is time to prepare and apply the index changes. This can be done synchronously or asynchronously from within a new thread. Synchronous updates have the advantage that the index is at all times in sync with the databases. Asynchronous updates, on the other hand, can help to minimize the user response time. The drawback is potential discrepancies between database and index states. Lets look at the configuration options shown in <xref linkend=\"table-work-execution-configuration\"/>."
msgstr ""

#. Tag: para
#: configuration.xml:584
#, no-c-format
msgid "Please note that the following options can be different on each index; in fact they need the indexName prefix or use <literal>default</literal> to set the default value for all indexes."
msgstr ""

#. Tag: title
#: configuration.xml:590
#, no-c-format
msgid "Execution configuration"
msgstr ""

#. Tag: literal
#: configuration.xml:601
#, no-c-format
msgid "hibernate.search.&lt;indexName&gt;.worker.execution"
msgstr ""

#. Tag: para
#: configuration.xml:603
#, no-c-format
msgid "<literal>sync</literal>: synchronous execution (default)"
msgstr ""

#. Tag: para
#: configuration.xml:604
#, no-c-format
msgid "<literal>async</literal>: asynchronous execution"
msgstr ""

#. Tag: literal
#: configuration.xml:609
#, no-c-format
msgid "hibernate.search.&lt;indexName&gt;.worker.thread_pool.size"
msgstr ""

#. Tag: entry
#: configuration.xml:611
#, no-c-format
msgid "The backend can apply updates from the same transaction context (or batch) in parallel, using a threadpool. The default value is 1. You can experiment with larger values if you have many operations per transaction."
msgstr ""

#. Tag: literal
#: configuration.xml:618
#, no-c-format
msgid "hibernate.search.&lt;indexName&gt;.worker.buffer_queue.max"
msgstr ""

#. Tag: entry
#: configuration.xml:620
#, no-c-format
msgid "Defines the maximal number of work queue if the thread poll is starved. Useful only for asynchronous execution. Default to infinite. If the limit is reached, the work is done by the main thread."
msgstr ""

#. Tag: para
#: configuration.xml:629
#, no-c-format
msgid "So far all work is done within the same Virtual Machine (VM), no matter which execution mode. The total amount of work has not changed for the single VM. Luckily there is a better approach, namely delegation. It is possible to send the indexing work to a different server by configuring hibernate.search.worker.backend - see <xref linkend=\"table-backend-configuration\"/>. Again this option can be configured differently for each index."
msgstr ""

#. Tag: title
#: configuration.xml:638
#, no-c-format
msgid "Backend configuration"
msgstr ""

#. Tag: literal
#: configuration.xml:649
#, no-c-format
msgid "hibernate.search.&lt;indexName&gt;.worker.backend"
msgstr ""

#. Tag: para
#: configuration.xml:651
#, no-c-format
msgid "<literal>lucene</literal>: The default backend which runs index updates in the same VM. Also used when the property is undefined or empty."
msgstr ""

#. Tag: para
#: configuration.xml:653
#, no-c-format
msgid "<literal>jms</literal>: JMS backend. Index updates are send to a JMS queue to be processed by an indexing master. See <xref linkend=\"table-jms-backend-configuration\"/> for additional configuration options and <xref linkend=\"jms-backend\"/> for a more detailed descripton of this setup."
msgstr ""

#. Tag: para
#: configuration.xml:659
#, no-c-format
msgid "<literal>jgroupsMaster</literal> or <literal>jgroupsSlave</literal>: Backend using <ulink url=\"http://www.jgroups.org/\">JGroups</ulink> as communication layer. See <xref linkend=\"table-jgroups-backend-configuration\"/> for additional configuration options and <xref linkend=\"jgroups-backend\"/> for a more detailed description of this setup."
msgstr ""

#. Tag: para
#: configuration.xml:665
#, no-c-format
msgid "<literal>blackhole</literal>: Mainly a test/developer setting which ignores all indexing work"
msgstr ""

#. Tag: para
#: configuration.xml:667
#, no-c-format
msgid "You can also specify the fully qualified name of a class implementing <classname>BackendQueueProcessor</classname>. This way you can implement your own communication layer. The implementation is responsilbe for returning a <classname>Runnable</classname> instance which on execution will process the index work."
msgstr ""

#. Tag: title
#: configuration.xml:679
#, no-c-format
msgid "JMS backend configuration"
msgstr ""

#. Tag: literal
#: configuration.xml:690
#, no-c-format
msgid "hibernate.search.&lt;indexName&gt;.worker.jndi.*"
msgstr ""

#. Tag: entry
#: configuration.xml:692
#, no-c-format
msgid "Defines the JNDI properties to initiate the InitialContext (if needed). JNDI is only used by the JMS back end."
msgstr ""

#. Tag: literal
#: configuration.xml:697
#, no-c-format
msgid "hibernate.search.&lt;indexName&gt;.worker.jms.connection_factory"
msgstr ""

#. Tag: entry
#: configuration.xml:699
#, no-c-format
msgid "Mandatory for the JMS back end. Defines the JNDI name to lookup the JMS connection factory from (<literal>/ConnectionFactory</literal> by default in JBoss AS)"
msgstr ""

#. Tag: literal
#: configuration.xml:706
#, no-c-format
msgid "hibernate.search.&lt;indexName&gt;.worker.jms.queue"
msgstr ""

#. Tag: entry
#: configuration.xml:708
#, no-c-format
msgid "Mandatory for the JMS back end. Defines the JNDI name to lookup the JMS queue from. The queue will be used to post work messages."
msgstr ""

#. Tag: title
#: configuration.xml:717
#, no-c-format
msgid "JGroups backend configuration"
msgstr ""

#. Tag: literal
#: configuration.xml:728
#, no-c-format
msgid "hibernate.search.&lt;indexName&gt;.worker.jgroups.clusterName"
msgstr ""

#. Tag: entry
#: configuration.xml:730
#, no-c-format
msgid "Optional for JGroups back end. Defines the name of JGroups channel."
msgstr ""

#. Tag: literal
#: configuration.xml:735
#, no-c-format
msgid "hibernate.search.&lt;indexName&gt;.worker.jgroups.configurationFile"
msgstr ""

#. Tag: entry
#: configuration.xml:737
#, no-c-format
msgid "Optional JGroups network stack configuration. Defines the name of a JGroups configuration file, which must exist on classpath."
msgstr ""

#. Tag: literal
#: configuration.xml:743
#, no-c-format
msgid "hibernate.search.&lt;indexName&gt;.worker.jgroups.configurationXml"
msgstr ""

#. Tag: entry
#: configuration.xml:745
#, no-c-format
msgid "Optional JGroups network stack configuration. Defines a String representing JGroups configuration as XML."
msgstr ""

#. Tag: literal
#: configuration.xml:750
#, no-c-format
msgid "hibernate.search.&lt;indexName&gt;.worker.jgroups.configurationString"
msgstr ""

#. Tag: entry
#: configuration.xml:752
#, no-c-format
msgid "Optional JGroups network stack configuration. Provides JGroups configuration in plain text."
msgstr ""

#. Tag: para
#: configuration.xml:760
#, no-c-format
msgid "As you probably noticed, some of the shown properties are correlated which means that not all combinations of property values make sense. In fact you can end up with a non-functional configuration. This is especially true for the case that you provide your own implementations of some of the shown interfaces. Make sure to study the existing code before you write your own <classname>Worker</classname> or <classname>BackendQueueProcessor</classname> implementation."
msgstr ""

#. Tag: title
#: configuration.xml:771
#, no-c-format
msgid "JMS Master/Slave configuration"
msgstr ""

#. Tag: para
#: configuration.xml:773
#, no-c-format
msgid "This section describes in greater detail how to configure the Master/Slave Hibernate Search architecture."
msgstr ""

#. Tag: para
#: configuration.xml:786
#, no-c-format
msgid "JMS back end configuration."
msgstr ""

#. Tag: title
#: configuration.xml:790 configuration.xml:860
#, no-c-format
msgid "Slave nodes"
msgstr ""

#. Tag: para
#: configuration.xml:792
#, no-c-format
msgid "Every index update operation is sent to a JMS queue. Index querying operations are executed on a local index copy."
msgstr ""

#. Tag: title
#: configuration.xml:796
#, no-c-format
msgid "JMS Slave configuration"
msgstr ""

#. Tag: programlisting
#: configuration.xml:798
#, no-c-format
msgid ""
      "### slave configuration\n"
      "\n"
      "## DirectoryProvider\n"
      "# (remote) master location\n"
      "hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy\n"
      "\n"
      "# local copy location\n"
      "hibernate.search.default.indexBase = /Users/prod/lucenedirs\n"
      "\n"
      "# refresh every half hour\n"
      "hibernate.search.default.refresh = 1800\n"
      "\n"
      "# appropriate directory provider\n"
      "hibernate.search.default.directory_provider = filesystem-slave\n"
      "\n"
      "## Backend configuration\n"
      "hibernate.search.default.worker.backend = jms\n"
      "hibernate.search.default.worker.jms.connection_factory = /ConnectionFactory\n"
      "hibernate.search.default.worker.jms.queue = queue/hibernatesearch\n"
      "#optional jndi configuration (check your JMS provider for more information)\n"
      "\n"
      "## Optional asynchronous execution strategy\n"
      "# hibernate.search.default.worker.execution = async\n"
      "# hibernate.search.default.worker.thread_pool.size = 2\n"
      "# hibernate.search.default.worker.buffer_queue.max = 50"
msgstr ""

#. Tag: para
#: configuration.xml:802
#, no-c-format
msgid "A file system local copy is recommended for faster search results."
msgstr ""

#. Tag: para
#: configuration.xml:807
#, no-c-format
msgid "The refresh period should be higher that the expected copy time."
msgstr ""

#. Tag: title
#: configuration.xml:813 configuration.xml:874
#, no-c-format
msgid "Master node"
msgstr ""

#. Tag: para
#: configuration.xml:815
#, no-c-format
msgid "Every index update operation is taken from a JMS queue and executed. The master index is copied on a regular basis."
msgstr ""

#. Tag: title
#: configuration.xml:819
#, no-c-format
msgid "JMS Master configuration"
msgstr ""

#. Tag: programlisting
#: configuration.xml:821
#, no-c-format
msgid ""
      "### master configuration\n"
      "\n"
      "## DirectoryProvider\n"
      "# (remote) master location where information is copied to\n"
      "hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy\n"
      "\n"
      "# local master location\n"
      "hibernate.search.default.indexBase = /Users/prod/lucenedirs\n"
      "\n"
      "# refresh every half hour\n"
      "hibernate.search.default.refresh = 1800\n"
      "\n"
      "# appropriate directory provider\n"
      "hibernate.search.default.directory_provider = filesystem-master\n"
      "\n"
      "## Backend configuration\n"
      "#Backend is the default lucene one"
msgstr ""

#. Tag: para
#: configuration.xml:825
#, no-c-format
msgid "The refresh period should be higher that the expected time copy."
msgstr ""

#. Tag: para
#: configuration.xml:829
#, no-c-format
msgid "In addition to the Hibernate Search framework configuration, a Message Driven Bean has to be written and set up to process the index works queue through JMS."
msgstr ""

#. Tag: title
#: configuration.xml:834
#, no-c-format
msgid "Message Driven Bean processing the indexing queue"
msgstr ""

#. Tag: programlisting
#: configuration.xml:836
#, no-c-format
msgid ""
      "@MessageDriven(activationConfig = {\n"
      "      @ActivationConfigProperty(propertyName=\"destinationType\", \n"
      "                                propertyValue=\"javax.jms.Queue\"),\n"
      "      @ActivationConfigProperty(propertyName=\"destination\", \n"
      "                                propertyValue=\"queue/hibernatesearch\"),\n"
      "      @ActivationConfigProperty(propertyName=\"DLQMaxResent\", propertyValue=\"1\")\n"
      "   } )\n"
      "public class MDBSearchController extends AbstractJMSHibernateSearchController \n"
      "                                 implements MessageListener {\n"
      "    @PersistenceContext EntityManager em;\n"
      "    \n"
      "    //method retrieving the appropriate session\n"
      "    protected Session getSession() {\n"
      "        return (Session) em.getDelegate();\n"
      "    }\n"
      "\n"
      "    //potentially close the session opened in #getSession(), not needed here\n"
      "    protected void cleanSessionIfNeeded(Session session) \n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: configuration.xml:839
#, no-c-format
msgid "This example inherits from the abstract JMS controller class available in the Hibernate Search source code and implements a JavaEE MDB. This implementation is given as an example and can be adjusted to make use of non Java EE Message Driven Beans. For more information about the <methodname>getSession()</methodname> and <methodname>cleanSessionIfNeeded()</methodname>, please check <classname>AbstractJMSHibernateSearchController</classname>'s javadoc."
msgstr ""

#. Tag: title
#: configuration.xml:851
#, no-c-format
msgid "JGroups Master/Slave configuration"
msgstr ""

#. Tag: para
#: configuration.xml:853
#, no-c-format
msgid "This section describes how to configure the JGroups Master/Slave back end. The configuration examples illustrated in <xref linkend=\"jms-backend\"/> also apply here, only a different backend (<constant>hibernate.search.worker.backend</constant>) needs to be set."
msgstr ""

#. Tag: para
#: configuration.xml:862
#, no-c-format
msgid "Every index update operation is sent through a JGroups channel to the master node. Index querying operations are executed on a local index copy."
msgstr ""

#. Tag: title
#: configuration.xml:867
#, no-c-format
msgid "JGroups Slave configuration"
msgstr ""

#. Tag: programlisting
#: configuration.xml:869
#, no-c-format
msgid ""
      "### slave configuration\n"
      "hibernate.search.default.worker.backend = jgroupsSlave"
msgstr ""

#. Tag: para
#: configuration.xml:876
#, no-c-format
msgid "Every index update operation is taken from a JGroups channel and executed. The master index is copied on a regular basis."
msgstr ""

#. Tag: title
#: configuration.xml:880
#, no-c-format
msgid "JGroups Master configuration"
msgstr ""

#. Tag: programlisting
#: configuration.xml:882
#, no-c-format
msgid ""
      "### master configuration\n"
      "hibernate.search.default.worker.backend = jgroupsMaster"
msgstr ""

#. Tag: title
#: configuration.xml:887
#, no-c-format
msgid "JGroups channel configuration"
msgstr ""

#. Tag: para
#: configuration.xml:889
#, no-c-format
msgid "Optionally the configuration for the JGroups transport protocols and channel name can be defined and applied to master and slave nodes. There are several ways to configure the JGroups transport details. You can either set the <constant>hibernate.search.default.worker.backend.jgroups.configurationFile</constant> property and specify a file containing the JGroups configuration or you can use the property <constant>hibernate.search.default.worker.backend.jgroups.configurationXml</constant> or <constant>hibernate.search.default.worker.backend.jgroups.configurationString</constant> to directly embed either the xml or string JGroups configuration into your Hibernate configuration file. All three options are shown in <xref linkend=\"example-jgroup-xml-configuration\"/>."
msgstr ""

#. Tag: para
#: configuration.xml:904
#, no-c-format
msgid "If no property is explicitly specified it is assumed that the JGroups default configuration file <literal>flush-udp.xml</literal> is used."
msgstr ""

#. Tag: title
#: configuration.xml:910
#, no-c-format
msgid "JGroups transport protocol configuration"
msgstr ""

#. Tag: programlisting
#: configuration.xml:912
#, no-c-format
msgid ""
      "## JGroups configuration options\n"
      "# OPTION 1 - udp.xml file needs to be located in the classpath\n"
      "hibernate.search.default.worker.backend.jgroups.configurationFile = udp.xml\n"
      "\n"
      "# OPTION 2 - protocol stack configuration provided in XML format\n"
      "hibernate.search.default.worker.backend.jgroups.configurationXml =\n"
      "\n"
      "&lt;config xmlns=\"urn:org:jgroups\"\n"
      "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
      "xsi:schemaLocation=\"urn:org:jgroups file:schema/JGroups-2.8.xsd\"&gt;\n"
      "&lt;UDP\n"
      "mcast_addr=\"${jgroups.udp.mcast_addr:228.10.10.10}\"\n"
      "mcast_port=\"${jgroups.udp.mcast_port:45588}\"\n"
      "tos=\"8\"\n"
      "thread_naming_pattern=\"pl\"\n"
      "thread_pool.enabled=\"true\"\n"
      "thread_pool.min_threads=\"2\"\n"
      "thread_pool.max_threads=\"8\"\n"
      "thread_pool.keep_alive_time=\"5000\"\n"
      "thread_pool.queue_enabled=\"false\"\n"
      "thread_pool.queue_max_size=\"100\"\n"
      "thread_pool.rejection_policy=\"Run\"/&gt;\n"
      "&lt;PING timeout=\"1000\" num_initial_members=\"3\"/&gt;\n"
      "&lt;MERGE2 max_interval=\"30000\" min_interval=\"10000\"/&gt;\n"
      "&lt;FD_SOCK/&gt;\n"
      "&lt;FD timeout=\"3000\" max_tries=\"3\"/&gt;\n"
      "&lt;VERIFY_SUSPECT timeout=\"1500\"/&gt;\n"
      "&lt;pbcast.STREAMING_STATE_TRANSFER/&gt;\n"
      "&lt;pbcast.FLUSH timeout=\"0\"/&gt;\n"
      "&lt;/config&gt;\n"
      "\n"
      "# OPTION 3 - protocol stack configuration provided in \"old style\" jgroups format\n"
      "hibernate.search.default.worker.backend.jgroups.configurationString =\n"
      "\n"
      "UDP(mcast_addr=228.1.2.3;mcast_port=45566;ip_ttl=32):PING(timeout=3000;\n"
      "num_initial_members=6):FD(timeout=5000):VERIFY_SUSPECT(timeout=1500):\n"
      "pbcast.NAKACK(gc_lag=10;retransmit_timeout=3000):UNICAST(timeout=5000):\n"
      "FRAG:pbcast.GMS(join_timeout=3000;shun=false;print_local_addr=true)"
msgstr ""

#. Tag: para
#: configuration.xml:915
#, no-c-format
msgid "In this JGroups master/slave configuration nodes communicate over a JGroups channel. The default channel name is <literal>HSearchCluster</literal> which can be configured as seen in <xref linkend=\"example-jgroups-channel-name\"/>."
msgstr ""

#. Tag: title
#: configuration.xml:921
#, no-c-format
msgid "JGroups channel name configuration"
msgstr ""

#. Tag: programlisting
#: configuration.xml:923
#, no-c-format
msgid "hibernate.search.default.worker.backend.jgroups.clusterName = Hibernate-Search-Cluster"
msgstr ""

#. Tag: title
#: configuration.xml:929
#, no-c-format
msgid "Infinispan Directory configuration"
msgstr ""

#. Tag: para
#: configuration.xml:931
#, no-c-format
msgid "Infinispan is a distributed, scalable, highly available data grid platform which supports autodiscovery of peer nodes. Using Infinispan and Hibernate Search in combination, it is possible to store the Lucene index in a distributed environment where index updates are quickly available on all nodes."
msgstr ""

#. Tag: para
#: configuration.xml:937
#, no-c-format
msgid "This section describes in greater detail how to configure Hibernate Search to use an Infinispan Lucene Directory."
msgstr ""

#. Tag: para
#: configuration.xml:940
#, no-c-format
msgid "When using an Infinispan Directory the index is stored in memory and shared across multiple nodes. It is considered a single directory across all participating nodes. If a node updates the index, all other nodes are updated as well. Updates on one node can be immediately searched for in the whole cluster."
msgstr ""

#. Tag: para
#: configuration.xml:946
#, no-c-format
msgid "The default configuration replicates all data defining the index across all nodes, thus consuming a significant amount of memory. For large indexes it's suggested to enable data distribution, so that each piece of information is replicated to a subset of all cluster members."
msgstr ""

#. Tag: para
#: configuration.xml:951
#, no-c-format
msgid "It is also possible to offload part or most information to a <literal>CacheStore</literal>, such as plain filesystem, Amazon S3, Cassandra, Berkley DB or standard relational databases. You can configure it to have a <literal>CacheStore</literal> on each node or have a single centralized one shared by each node."
msgstr ""

#. Tag: para
#: configuration.xml:957
#, no-c-format
msgid "See the <ulink url=\"http://www.jboss.org/infinispan/\"> Infinispan documentation</ulink> for all Infinispan configuration options."
msgstr ""

#. Tag: title
#: configuration.xml:961
#, no-c-format
msgid "Requirements"
msgstr ""

#. Tag: para
#: configuration.xml:963
#, no-c-format
msgid "To use the Infinispan directory via Maven, add the following dependencies:"
msgstr ""

#. Tag: title
#: configuration.xml:967
#, no-c-format
msgid "Maven dependencies for Hibernate Search"
msgstr ""

#. Tag: programlisting
#: configuration.xml:969
#, no-c-format
msgid ""
      "&lt;dependency&gt;\n"
      "   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;\n"
      "   &lt;artifactId&gt;hibernate-search&lt;/artifactId&gt;\n"
      "   &lt;version&gt;&version;&lt;/version&gt;\n"
      "&lt;/dependency&gt;\n"
      "&lt;dependency&gt;\n"
      "   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;\n"
      "   &lt;artifactId&gt;hibernate-search-infinispan&lt;/artifactId&gt;\n"
      "   &lt;version&gt;&version;&lt;/version&gt;\n"
      "&lt;/dependency&gt;"
msgstr ""

#. Tag: para
#: configuration.xml:972
#, no-c-format
msgid "For the non-maven users, add <literal>hibernate-search-infinispan.jar</literal>, <literal>infinispan-lucene-directory.jar</literal> and <literal>infinispan-core.jar</literal> to your application classpath. These last two jars are distributed by <ulink url=\"http://sourceforge.net/projects/infinispan/files/\">Infinispan</ulink>."
msgstr ""

#. Tag: title
#: configuration.xml:981
#, no-c-format
msgid "Architecture"
msgstr ""

#. Tag: para
#: configuration.xml:983
#, no-c-format
msgid "Even when using an Infinispan directory it's still recommended to use the JMS Master/Slave or JGroups backend, because in Infinispan all nodes will share the same index and it is likely that <classname>IndexWriter</classname>s being active on different nodes will try to acquire the lock on the same index. So instead of sending updates directly to the index, send it to a JMS queue or JGroups channel and have a single node apply all changes on behalf of all other nodes."
msgstr ""

#. Tag: para
#: configuration.xml:992
#, no-c-format
msgid "Configuring a non-default backend is not a requirement but a performance optimization as locks are enabled to have a single node writing."
msgstr ""

#. Tag: para
#: configuration.xml:996
#, no-c-format
msgid "To configure a JMS slave only the backend must be replaced, the directory provider must be set to <literal>infinispan</literal>; set the same directory provider on the master, they will connect without the need to setup the copy job across nodes. Using the JGroups backend is very similar - just combine the backend configuration with the <literal>infinispan</literal> directory provider."
msgstr ""

#. Tag: title
#: configuration.xml:1005
#, no-c-format
msgid "Infinispan Configuration"
msgstr ""

#. Tag: para
#: configuration.xml:1007
#, no-c-format
msgid "The most simple configuration only requires to enable the backend:"
msgstr ""

#. Tag: programlisting
#: configuration.xml:1010
#, no-c-format
msgid "hibernate.search.[default|&lt;indexname&gt;].directory_provider infinispan"
msgstr ""

#. Tag: para
#: configuration.xml:1012
#, no-c-format
msgid "That's all what is needed to get a cluster-replicated index, but the default configuration does not enable any form of permanent persistence for the index; to enable such a feature an Infinispan configuration file should be provided."
msgstr ""

#. Tag: para
#: configuration.xml:1017
#, no-c-format
msgid "To use Infinispan, Hibernate Search requirest a <classname>CacheManager</classname>; it can lookup and reuse an existing <classname>CacheManager,</classname> via JNDI, or start and manage a new one. In the latter case Hibernate Search will start and stop it ( closing occurs when the Hibernate <classname>SessionFactory</classname> is closed)."
msgstr ""

#. Tag: para
#: configuration.xml:1024
#, no-c-format
msgid "To use and existing <classname>CacheManager</classname> via JNDI (optional parameter):"
msgstr ""

#. Tag: programlisting
#: configuration.xml:1027
#, no-c-format
msgid "hibernate.search.infinispan.cachemanager_jndiname = [jndiname]"
msgstr ""

#. Tag: para
#: configuration.xml:1029
#, no-c-format
msgid "To start a new <classname>CacheManager</classname> from a configuration file (optional parameter):"
msgstr ""

#. Tag: programlisting
#: configuration.xml:1032
#, no-c-format
msgid "hibernate.search.infinispan.configuration_resourcename = [infinispan configuration filename]"
msgstr ""

#. Tag: para
#: configuration.xml:1034
#, no-c-format
msgid "If both parameters are defined, JNDI will have priority. If none of these is defined, Hibernate Search will use the default Infinispan configuration included in <literal>hibernate-search-infinispan.jar</literal>. This configuration should work fine in most cases but does not store the index in a persistent cache store."
msgstr ""

#. Tag: para
#: configuration.xml:1041
#, no-c-format
msgid "As mentioned in <xref linkend=\"directory-provider-table\"/>, each index makes use of three caches, so three different caches should be configured as shown in the <literal>default-hibernatesearch-infinispan.xml</literal> provided in the <literal>hibernate-search-infinispan.jar</literal>. Several indexes can share the same caches."
msgstr ""

#. Tag: title
#: configuration.xml:1051
#, no-c-format
msgid "Reader strategy configuration"
msgstr ""

#. Tag: para
#: configuration.xml:1053
#, no-c-format
msgid "The different reader strategies are described in <xref linkend=\"search-architecture-readerstrategy\"/>. Out of the box strategies are:"
msgstr ""

#. Tag: para
#: configuration.xml:1059
#, no-c-format
msgid "<literal>shared</literal>: share index readers across several queries. This strategy is the most efficient."
msgstr ""

#. Tag: para
#: configuration.xml:1064
#, no-c-format
msgid "<literal>not-shared</literal>: create an index reader for each individual query"
msgstr ""

#. Tag: para
#: configuration.xml:1069
#, no-c-format
msgid "The default reader strategy is <literal>shared</literal>. This can be adjusted:"
msgstr ""

#. Tag: programlisting
#: configuration.xml:1072
#, no-c-format
msgid "hibernate.search.[default|&lt;indexname&gt;].reader.strategy = not-shared"
msgstr ""

#. Tag: para
#: configuration.xml:1074
#, no-c-format
msgid "Adding this property switches to the <literal>not-shared</literal> strategy."
msgstr ""

#. Tag: para
#: configuration.xml:1077
#, no-c-format
msgid "Or if you have a custom reader strategy:"
msgstr ""

#. Tag: programlisting
#: configuration.xml:1079
#, no-c-format
msgid "hibernate.search.[default|&lt;indexname&gt;].reader.strategy = my.corp.myapp.CustomReaderProvider"
msgstr ""

#. Tag: para
#: configuration.xml:1081
#, no-c-format
msgid "where <classname>my.corp.myapp.CustomReaderProvider</classname> is the custom strategy implementation."
msgstr ""

#. Tag: title
#: configuration.xml:1086
#, no-c-format
msgid "Overriding the Index Manager"
msgstr ""

#. Tag: para
#: configuration.xml:1088
#, no-c-format
msgid "The role of the index manager component is described at <xref linkend=\"search-architecture-indexmanager\"/>. Available implementations are:"
msgstr ""

#. Tag: para
#: configuration.xml:1094
#, no-c-format
msgid "<literal>transactional</literal>: the default implementation."
msgstr ""

#. Tag: para
#: configuration.xml:1099
#, no-c-format
msgid "<literal>near-real-time</literal>: avoid flushing writes to disk at each commit."
msgstr ""

#. Tag: para
#: configuration.xml:1104
#, no-c-format
msgid "The default implementation is <literal>transactional</literal>. To select an alternative:"
msgstr ""

#. Tag: programlisting
#: configuration.xml:1107
#, no-c-format
msgid "hibernate.search.[default|&lt;indexname&gt;].indexmanager = near-real-time"
msgstr ""

#. Tag: para
#: configuration.xml:1109
#, no-c-format
msgid "Alternatively to <literal>near-real-time</literal> you can mention the fully qualified class name of your custom implementation, which shall have a no-arguments constructor:"
msgstr ""

#. Tag: programlisting
#: configuration.xml:1113
#, no-c-format
msgid "hibernate.search.[default|&lt;indexname&gt;].indexmanager = my.corp.myapp.CustomIndexManager"
msgstr ""

#. Tag: title
#: configuration.xml:1117
#, no-c-format
msgid "Tuning Lucene indexing performance"
msgstr ""

#. Tag: para
#: configuration.xml:1119
#, no-c-format
msgid "Hibernate Search allows you to tune the Lucene indexing performance by specifying a set of parameters which are passed through to underlying Lucene <literal>IndexWriter</literal> such as <literal>mergeFactor</literal>, <literal>maxMergeDocs</literal> and <literal>maxBufferedDocs</literal>. You can specify these parameters either as default values applying for all indexes, on a per index basis, or even per shard."
msgstr ""

#. Tag: para
#: configuration.xml:1127
#, no-c-format
msgid "There are several low level <literal>IndexWriter</literal> settings which can be tuned for different use cases. These parameters are grouped by the <literal>indexwriter</literal> keyword:"
msgstr ""

#. Tag: programlisting
#: configuration.xml:1129
#, no-c-format
msgid "hibernate.search.[default|&lt;indexname&gt;].indexwriter.&lt;parameter_name&gt;"
msgstr ""

#. Tag: para
#: configuration.xml:1131
#, no-c-format
msgid ""
      "If no value is set for an <literal>indexwriter</literal> value in a specific shard configuration, Hibernate Search will look at the index section, then at the default section.<example id=\"example-performamce-option-configuration\"> <title>Example performance option configuration</title> <programlisting>hibernate.search.Animals.2.indexwriter.max_merge_docs 10\n"
      "hibernate.search.Animals.2.indexwriter.merge_factor 20\n"
      "hibernate.search.Animals.2.indexwriter.term_index_interval default\n"
      "hibernate.search.default.indexwriter.max_merge_docs 100\n"
      "hibernate.search.default.indexwriter.ram_buffer_size 64</programlisting> </example> The configuration in <xref linkend=\"example-performamce-option-configuration\"/> will result in these settings applied on the second shard of the <classname>Animal</classname> index:"
msgstr ""

#. Tag: para
#: configuration.xml:1145
#, no-c-format
msgid "<literal>max_merge_docs</literal> = 10"
msgstr ""

#. Tag: para
#: configuration.xml:1149
#, no-c-format
msgid "<literal>merge_factor</literal> = 20"
msgstr ""

#. Tag: para
#: configuration.xml:1153
#, no-c-format
msgid "<literal>ram_buffer_size</literal> = 64MB"
msgstr ""

#. Tag: para
#: configuration.xml:1157
#, no-c-format
msgid "<literal>term_index_interval</literal> = Lucene default"
msgstr ""

#. Tag: para
#: configuration.xml:1161
#, no-c-format
msgid "All other values will use the defaults defined in Lucene."
msgstr ""

#. Tag: para
#: configuration.xml:1163
#, no-c-format
msgid "The default for all values is to leave them at Lucene's own default. The values listed in <xref linkend=\"table-performance-parameters\"/> depend for this reason on the version of Lucene you are using. The values shown are relative to version <literal>2.4</literal>. For more information about Lucene indexing performance, please refer to the Lucene documentation."
msgstr ""

#. Tag: para
#: configuration.xml:1171
#, no-c-format
msgid "Previous versions of Search had the notion of <literal>batch</literal> and <literal>transaction</literal> properties. This is no longer the case as the backend will always perform work using the same settings."
msgstr ""

#. Tag: title
#: configuration.xml:1178
#, no-c-format
msgid "List of indexing performance and behavior properties"
msgstr ""

#. Tag: entry
#: configuration.xml:1183
#, no-c-format
msgid "<entry>Property</entry>"
msgstr ""

#. Tag: entry
#: configuration.xml:1187
#, no-c-format
msgid "Default Value"
msgstr ""

#. Tag: literallayout
#: configuration.xml:1194
#, no-c-format
msgid ""
      "hibernate.search.\n"
      "[default|&lt;indexname&gt;].   \n"
      "exclusive_index_use"
msgstr ""

#. Tag: para
#: configuration.xml:1198
#, no-c-format
msgid "Set to <literal>true</literal> when no other process will need to write to the same index. This will enable Hibernate Search to work in exlusive mode on the index and improve performance when writing changes to the index."
msgstr ""

#. Tag: entry
#: configuration.xml:1204
#, no-c-format
msgid "<literal>true</literal> (improved performance, releases locks only at shutdown)"
msgstr ""

#. Tag: literallayout
#: configuration.xml:1210
#, no-c-format
msgid ""
      "hibernate.search.\n"
      "[default|&lt;indexname&gt;].   \n"
      "max_queue_length"
msgstr ""

#. Tag: para
#: configuration.xml:1214
#, no-c-format
msgid "Each index has a separate \"pipeline\" which contains the updates to be applied to the index. When this queue is full adding more operations to the queue becomes a blocking operation. Configuring this setting doesn't make much sense unless the <literal>worker.execution</literal> is configured as <literal>async</literal>."
msgstr ""

#. Tag: literal
#: configuration.xml:1223
#, no-c-format
msgid "1000"
msgstr ""

#. Tag: literallayout
#: configuration.xml:1229
#, no-c-format
msgid ""
      "hibernate.search.\n"
      "[default|&lt;indexname&gt;].\n"
      "indexwriter.max_buffered_delete_terms"
msgstr ""

#. Tag: para
#: configuration.xml:1233
#, no-c-format
msgid "Determines the minimal number of delete terms required before the buffered in-memory delete terms are applied and flushed. If there are documents buffered in memory at the time, they are merged and a new segment is created."
msgstr ""

#. Tag: entry
#: configuration.xml:1239 configuration.xml:1252
#, no-c-format
msgid "Disabled (flushes by RAM usage)"
msgstr ""

#. Tag: literallayout
#: configuration.xml:1244
#, no-c-format
msgid ""
      "hibernate.search.\n"
      "[default|&lt;indexname&gt;].\n"
      "indexwriter.max_buffered_docs"
msgstr ""

#. Tag: para
#: configuration.xml:1248
#, no-c-format
msgid "Controls the amount of documents buffered in memory during indexing. The bigger the more RAM is consumed."
msgstr ""

#. Tag: literallayout
#: configuration.xml:1257
#, no-c-format
msgid ""
      "hibernate.search.\n"
      "[default|&lt;indexname&gt;].\n"
      "indexwriter.max_merge_docs"
msgstr ""

#. Tag: para
#: configuration.xml:1261
#, no-c-format
msgid "Defines the largest number of documents allowed in a segment. Smaller values perform better on frequently changing indexes, larger values provide better search performance if the index does not change often."
msgstr ""

#. Tag: entry
#: configuration.xml:1267
#, no-c-format
msgid "Unlimited (Integer.MAX_VALUE)"
msgstr ""

#. Tag: literallayout
#: configuration.xml:1272
#, no-c-format
msgid ""
      "hibernate.search.\n"
      "[default|&lt;indexname&gt;].\n"
      "indexwriter.merge_factor"
msgstr ""

#. Tag: para
#: configuration.xml:1276 configuration.xml:1298 configuration.xml:1320 configuration.xml:1343 configuration.xml:1363
#, no-c-format
msgid "Controls segment merge frequency and size."
msgstr ""

#. Tag: para
#: configuration.xml:1278
#, no-c-format
msgid "Determines how often segment indexes are merged when insertion occurs. With smaller values, less RAM is used while indexing, and searches on unoptimized indexes are faster, but indexing speed is slower. With larger values, more RAM is used during indexing, and while searches on unoptimized indexes are slower, indexing is faster. Thus larger values (&gt; 10) are best for batch index creation, and smaller values (&lt; 10) for indexes that are interactively maintained. The value must not be lower than 2."
msgstr ""

#. Tag: entry
#: configuration.xml:1289
#, no-c-format
msgid "<entry>10</entry>"
msgstr ""

#. Tag: literallayout
#: configuration.xml:1294
#, no-c-format
msgid ""
      "hibernate.search.\n"
      "[default|&lt;indexname&gt;].\n"
      "indexwriter.merge_min_size"
msgstr ""

#. Tag: para
#: configuration.xml:1300
#, no-c-format
msgid "Segments smaller than this size (in MB) are always considered for the next segment merge operation."
msgstr ""

#. Tag: para
#: configuration.xml:1303
#, no-c-format
msgid "Setting this too large might result in expensive merge operations, even tough they are less frequent."
msgstr ""

#. Tag: para
#: configuration.xml:1306
#, no-c-format
msgid "See also <classname>org.apache.lucene.index.LogDocMergePolicy</classname>. <literal>minMergeSize</literal>."
msgstr ""

#. Tag: entry
#: configuration.xml:1311
#, no-c-format
msgid "0 MB (actually ~1K)"
msgstr ""

#. Tag: literallayout
#: configuration.xml:1316
#, no-c-format
msgid ""
      "hibernate.search.\n"
      "[default|&lt;indexname&gt;].\n"
      "indexwriter.merge_max_size"
msgstr ""

#. Tag: para
#: configuration.xml:1322
#, no-c-format
msgid "Segments larger than this size (in MB) are never merged in bigger segments."
msgstr ""

#. Tag: para
#: configuration.xml:1325
#, no-c-format
msgid "This helps reduce memory requirements and avoids some merging operations at the cost of optimal search speed. When optimizing an index this value is ignored."
msgstr ""

#. Tag: para
#: configuration.xml:1329
#, no-c-format
msgid "See also <classname>org.apache.lucene.index.LogDocMergePolicy</classname>. <literal>maxMergeSize</literal>."
msgstr ""

#. Tag: entry
#: configuration.xml:1334 configuration.xml:1354
#, no-c-format
msgid "Unlimited"
msgstr ""

#. Tag: literallayout
#: configuration.xml:1339
#, no-c-format
msgid ""
      "hibernate.search.\n"
      "[default|&lt;indexname&gt;].\n"
      "indexwriter.merge_max_optimize_size"
msgstr ""

#. Tag: para
#: configuration.xml:1345
#, no-c-format
msgid "Segments larger than this size (in MB) are not merged in bigger segments even when optimizing the index (see <literal>merge_max_size</literal> setting as well)."
msgstr ""

#. Tag: para
#: configuration.xml:1349
#, no-c-format
msgid "Applied to <classname>org.apache.lucene.index.LogDocMergePolicy</classname>. <literal>maxMergeSizeForOptimize</literal>."
msgstr ""

#. Tag: literallayout
#: configuration.xml:1359
#, no-c-format
msgid ""
      "hibernate.search.\n"
      "[default|&lt;indexname&gt;].\n"
      "indexwriter.merge_calibrate_by_deletes"
msgstr ""

#. Tag: para
#: configuration.xml:1365
#, no-c-format
msgid "Set to <literal>false</literal> to not consider deleted documents when estimating the merge policy."
msgstr ""

#. Tag: para
#: configuration.xml:1368
#, no-c-format
msgid "Applied to <classname>org.apache.lucene.index.LogMergePolicy</classname>. <literal>calibrateSizeByDeletes</literal>."
msgstr ""

#. Tag: literal
#: configuration.xml:1374
#, no-c-format
msgid "<literal>true</literal>"
msgstr ""

#. Tag: literallayout
#: configuration.xml:1380
#, no-c-format
msgid ""
      "hibernate.search.\n"
      "[default|&lt;indexname&gt;].\n"
      "indexwriter.ram_buffer_size"
msgstr ""

#. Tag: para
#: configuration.xml:1384
#, no-c-format
msgid "Controls the amount of RAM in MB dedicated to document buffers. When used together max_buffered_docs a flush occurs for whichever event happens first."
msgstr ""

#. Tag: para
#: configuration.xml:1388
#, no-c-format
msgid "Generally for faster indexing performance it's best to flush by RAM usage instead of document count and use as large a RAM buffer as you can."
msgstr ""

#. Tag: entry
#: configuration.xml:1393
#, no-c-format
msgid "16 MB"
msgstr ""

#. Tag: literallayout
#: configuration.xml:1398
#, no-c-format
msgid ""
      "hibernate.search.\n"
      "[default|&lt;indexname&gt;].\n"
      "indexwriter.term_index_interval"
msgstr ""

#. Tag: para
#: configuration.xml:1402
#, no-c-format
msgid "Expert: Set the interval between indexed terms."
msgstr ""

#. Tag: para
#: configuration.xml:1404
#, no-c-format
msgid "Large values cause less memory to be used by IndexReader, but slow random-access to terms. Small values cause more memory to be used by an IndexReader, and speed random-access to terms. See Lucene documentation for more details."
msgstr ""

#. Tag: entry
#: configuration.xml:1410
#, no-c-format
msgid "<entry>128</entry>"
msgstr ""

#. Tag: literallayout
#: configuration.xml:1415
#, no-c-format
msgid ""
      "hibernate.search.\n"
      "[default|&lt;indexname&gt;].\n"
      "indexwriter.use_compound_file"
msgstr ""

#. Tag: entry
#: configuration.xml:1418
#, no-c-format
msgid "The advantage of using the compound file format is that less file descriptors are used. The disadvantage is that indexing takes more time and temporary disk space. You can set this parameter to <literal>false</literal> in an attempt to improve the indexing time, but you could run out of file descriptors if <literal>mergeFactor</literal> is also large."
msgstr ""

#. Tag: para
#: configuration.xml:1423 configuration.xml:1451
#, no-c-format
msgid "Boolean parameter, use \"<literal>true</literal>\" or \"<literal>false</literal>\". The default value for this option is <literal>true</literal>."
msgstr ""

#. Tag: entry
#: configuration.xml:1428 configuration.xml:1456
#, no-c-format
msgid "<entry>true</entry>"
msgstr ""

#. Tag: literallayout
#: configuration.xml:1433
#, no-c-format
msgid ""
      "hibernate.search.\n"
      "enable_dirty_check"
msgstr ""

#. Tag: para
#: configuration.xml:1437
#, no-c-format
msgid "Not all entity changes require an update of the Lucene index. If all of the updated entity properties (dirty properties) are not indexed Hibernate Search will skip the re-indexing work."
msgstr ""

#. Tag: para
#: configuration.xml:1442
#, no-c-format
msgid "Disable this option if you use custom <literal>FieldBridge</literal>s which need to be invoked at each update event (even though the property for which the field bridge is configured has not changed)."
msgstr ""

#. Tag: para
#: configuration.xml:1447
#, no-c-format
msgid "This optimization will not be applied on classes using a <literal>@ClassBridge</literal> or a <literal>@DynamicBoost</literal>."
msgstr ""

#. Tag: para
#: configuration.xml:1463
#, no-c-format
msgid "When your architecture permits it, always keep <literal>hibernate.search.default.exclusive_index_use=true</literal> as it greatly improves efficiency in index writing. This is the default since Hibernate Search version 4."
msgstr ""

#. Tag: para
#: configuration.xml:1470
#, no-c-format
msgid "To tune the indexing speed it might be useful to time the object loading from database in isolation from the writes to the index. To achieve this set the <literal>blackhole</literal> as worker backend and start your indexing routines. This backend does not disable Hibernate Search: it will still generate the needed changesets to the index, but will discard them instead of flushing them to the index. In contrast to setting the <literal>hibernate.search.indexing_strategy</literal> to <literal>manual</literal>, using <literal>blackhole</literal> will possibly load more data from the database. because associated entities are re-indexed as well."
msgstr ""

#. Tag: programlisting
#: configuration.xml:1481
#, no-c-format
msgid "hibernate.search.[default|&lt;indexname&gt;].worker.backend blackhole"
msgstr ""

#. Tag: para
#: configuration.xml:1483
#, no-c-format
msgid "The recommended approach is to focus first on optimizing the object loading, and then use the timings you achieve as a baseline to tune the indexing process."
msgstr ""

#. Tag: para
#: configuration.xml:1489
#, no-c-format
msgid "The <literal>blackhole</literal> backend is not meant to be used in production, only as a tool to identify indexing bottlenecks."
msgstr ""

#. Tag: title
#: configuration.xml:1494
#, no-c-format
msgid "Control segment size"
msgstr ""

#. Tag: para
#: configuration.xml:1496
#, no-c-format
msgid "The options <literal>merge_max_size</literal>, <literal>merge_max_optimize_size</literal>, <literal>merge_calibrate_by_deletes</literal> give you control on the maximum size of the segments being created, but you need to understand how they affect file sizes. If you need to hard limit the size, consider that merging a segment is about adding it together with another existing segment to form a larger one, so you might want to set the <literal>max_size</literal> for merge operations to less than half of your hard limit. Also segments might initially be generated larger than your expected size at first creation time: before they are ever merged. A segment is never created much larger than <literal>ram_buffer_size</literal>, but the threshold is checked as an estimate."
msgstr ""

#. Tag: para
#: configuration.xml:1510
#, no-c-format
msgid "Example:"
msgstr ""

#. Tag: programlisting
#: configuration.xml:1512
#, no-c-format
msgid ""
      "//to be fairly confident no files grow above 15MB, use:\n"
      "hibernate.search.default.indexwriter.ram_buffer_size 10\n"
      "hibernate.search.default.indexwriter.merge_max_optimize_size 7\n"
      "hibernate.search.default.indexwriter.merge_max_size 7"
msgstr ""

#. Tag: para
#: configuration.xml:1516
#, no-c-format
msgid "When using the Infinispan Directory to cluster indexes make sure that your segments are smaller than the <literal>chunk_size</literal> so that you avoid fragmenting segments in the grid. Note that the <literal>chunk_size</literal> of the Infinispan Directory is expressed in bytes, while the index tuning options are in MB."
msgstr ""

#. Tag: title
#: configuration.xml:1525
#, no-c-format
msgid "LockFactory configuration"
msgstr ""

#. Tag: para
#: configuration.xml:1527
#, no-c-format
msgid "Lucene <classname>Directory</classname>s have default locking strategies which work well for most cases, but it's possible to specify for each index managed by Hibernate Search which <classname>LockingFactory</classname> you want to use."
msgstr ""

#. Tag: para
#: configuration.xml:1532
#, no-c-format
msgid "Some of these locking strategies require a filesystem level lock and may be used even on RAM based indexes, but this is not recommended and of no practical use."
msgstr ""

#. Tag: para
#: configuration.xml:1536
#, no-c-format
msgid "To select a locking factory, set the <literal>hibernate.search.&lt;index&gt;.locking_strategy</literal> option to one of <literal>simple</literal>, <literal>native</literal>, <literal>single</literal> or <literal>none</literal>. Alternatively set it to the fully qualified name of an implementation of <literal>org.hibernate.search.store.LockFactoryProvider</literal>."
msgstr ""

#. Tag: title
#: configuration.xml:1544
#, no-c-format
msgid "List of available LockFactory implementations"
msgstr ""

#. Tag: entry
#: configuration.xml:1549
#, no-c-format
msgid "name"
msgstr ""

#. Tag: entry
#: configuration.xml:1551
#, no-c-format
msgid "Class"
msgstr ""

#. Tag: entry
#: configuration.xml:1559
#, no-c-format
msgid "simple"
msgstr ""

#. Tag: entry
#: configuration.xml:1561
#, no-c-format
msgid "org.apache.lucene.store.SimpleFSLockFactory"
msgstr ""

#. Tag: para
#: configuration.xml:1563
#, no-c-format
msgid "Safe implementation based on Java's File API, it marks the usage of the index by creating a marker file."
msgstr ""

#. Tag: para
#: configuration.xml:1565
#, no-c-format
msgid "If for some reason you had to kill your application, you will need to remove this file before restarting it."
msgstr ""

#. Tag: para
#: configuration.xml:1567
#, no-c-format
msgid "This is the default implementation for the <literal>filesystem</literal>, <literal>filesystem-master</literal> and <literal>filesystem-slave</literal> directory providers."
msgstr ""

#. Tag: entry
#: configuration.xml:1575
#, no-c-format
msgid "native"
msgstr ""

#. Tag: entry
#: configuration.xml:1577
#, no-c-format
msgid "org.apache.lucene.store.NativeFSLockFactory"
msgstr ""

#. Tag: para
#: configuration.xml:1579
#, no-c-format
msgid "As does <literal>simple</literal> this also marks the usage of the index by creating a marker file, but this one is using native OS file locks so that even if your application crashes the locks will be cleaned up."
msgstr ""

#. Tag: para
#: configuration.xml:1582
#, no-c-format
msgid "This implementation has known problems on NFS."
msgstr ""

#. Tag: entry
#: configuration.xml:1587
#, no-c-format
msgid "single"
msgstr ""

#. Tag: entry
#: configuration.xml:1589
#, no-c-format
msgid "org.apache.lucene.store.SingleInstanceLockFactory"
msgstr ""

#. Tag: para
#: configuration.xml:1591
#, no-c-format
msgid "This LockFactory doesn't use a file marker but is a Java object lock held in memory; therefore it's possible to use it only when you are sure the index is not going to be shared by any other process."
msgstr ""

#. Tag: para
#: configuration.xml:1594
#, no-c-format
msgid "This is the default implementation for the <literal>ram</literal> directory provider."
msgstr ""

#. Tag: entry
#: configuration.xml:1601
#, no-c-format
msgid "org.apache.lucene.store.NoLockFactory"
msgstr ""

#. Tag: para
#: configuration.xml:1603
#, no-c-format
msgid "All changes to this index are not coordinated by any lock; test your application carefully and make sure you know what it means."
msgstr ""

#. Tag: para
#: configuration.xml:1611
#, no-c-format
msgid "Configuration example:"
msgstr ""

#. Tag: programlisting
#: configuration.xml:1613
#, no-c-format
msgid ""
      "hibernate.search.default.locking_strategy simple\n"
      "hibernate.search.Animals.locking_strategy native\n"
      "hibernate.search.Books.locking_strategy org.custom.components.MyLockingFactory"
msgstr ""

#. Tag: title
#: configuration.xml:1617
#, no-c-format
msgid "Exception Handling Configuration"
msgstr ""

#. Tag: para
#: configuration.xml:1619
#, no-c-format
msgid "Hibernate Search allows you to configure how exceptions are handled during the indexing process. If no configuration is provided then exceptions are logged to the log output by default. It is possible to explicitly declare the exception logging mechanism as seen below:"
msgstr ""

#. Tag: programlisting
#: configuration.xml:1624
#, no-c-format
msgid "hibernate.search.error_handler log"
msgstr ""

#. Tag: para
#: configuration.xml:1626
#, no-c-format
msgid "The default exception handling occurs for both synchronous and asynchronous indexing. Hibernate Search provides an easy mechanism to override the default error handling implementation."
msgstr ""

#. Tag: para
#: configuration.xml:1630
#, no-c-format
msgid "In order to provide your own implementation you must implement the <classname>ErrorHandler</classname> interface, which provides the <code>handle(ErrorContext context)</code> method. <code>ErrorContext</code> provides a reference to the primary <code>LuceneWork</code> instance, the underlying exception and any subsequent <code>LuceneWork</code> instances that could not be processed due to the primary exception."
msgstr ""

#. Tag: programlisting
#: configuration.xml:1638
#, no-c-format
msgid ""
      "public interface ErrorContext  {\n"
      "   List&lt;LuceneWork&gt; getFailingOperations();\n"
      "   LuceneWork getOperationAtFault();\n"
      "   Throwable getThrowable();\n"
      "   boolean hasErrors();\n"
      "}"
msgstr ""

#. Tag: para
#: configuration.xml:1640
#, no-c-format
msgid "To register this error handler with Hibernate Search you must declare the fully qualified classname of your <classname>ErrorHandler</classname> implementation in the configuration properties:"
msgstr ""

#. Tag: programlisting
#: configuration.xml:1645
#, no-c-format
msgid "hibernate.search.error_handler CustomerErrorHandler"
msgstr ""

#. Tag: title
#: configuration.xml:1649
#, no-c-format
msgid "Index format compatibility"
msgstr ""

#. Tag: para
#: configuration.xml:1651
#, no-c-format
msgid "While Hibernate Search strives to offer a backwards compatible API to make it easy to port your application to newer versions, it delegates to Apache Lucene to handle the index writing and searching. The Lucene developers too attempt to keep a stable index format, but sometimes an update in the index format can not be avoided; in those rare cases you either have to reindex all your data, or use an index upgrade tool, or sometimes Lucene is able to read the old format so you don't need to take specific actions (besides making backup of your index)."
msgstr ""

#. Tag: para
#: configuration.xml:1660
#, no-c-format
msgid "While an index format incompatibility is an exceptional event, more often when upgrading Lucene the Analyzer implementations might slightly change behaviour, and this could lead to a poor recall score, possibly missing many hits from the results."
msgstr ""

#. Tag: para
#: configuration.xml:1665
#, no-c-format
msgid "Hibernate Search exposes a configuration property <literal>hibernate.search.lucene_version</literal> which instructs the Analyzers and other Lucene classes to conform to their behaviour as defined in an (older) specific version of Lucene. See also <classname>org.apache.lucene.util.Version</classname> contained in the lucene-core.jar, depending on the specific version of Lucene you're using you might have different options available. When this option is not specified, Hibernate Search will instruct Lucene to use the default of it's current version, which is usually the best option for new projects. Still it's recommended to define the version you're using explicitly in the configuration so that when you happen to upgrade Lucene the Analyzers will not change behaviour; you can then choose to update this value in a second time, maybe when you have the chance to rebuild the index from scratch."
msgstr ""

#. Tag: title
#: configuration.xml:1681
#, no-c-format
msgid "Force Analyzers to be compatible with a Lucene 3.0 created index"
msgstr ""

#. Tag: programlisting
#: configuration.xml:1684
#, no-c-format
msgid "hibernate.search.lucene_version LUCENE_30"
msgstr ""

#. Tag: para
#: configuration.xml:1687
#, no-c-format
msgid "This option is global for the configured <classname>SearchFactory</classname> and affects all Lucene APIs having such a parameter, as this should be applied consistently. So if you are also making use of Lucene bypassing Hibernate Search, make sure to apply the same value too."
msgstr ""

