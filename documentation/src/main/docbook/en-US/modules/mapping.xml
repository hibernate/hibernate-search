<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Hibernate, Relational Persistence for Idiomatic Java
  ~
  ~  Copyright (c) 2010, Red Hat, Inc. and/or its affiliates or third-party contributors as
  ~  indicated by the @author tags or express copyright attribution
  ~  statements applied by the authors.  All third-party contributions are
  ~  distributed under license by Red Hat, Inc.
  ~
  ~  This copyrighted material is made available to anyone wishing to use, modify,
  ~  copy, or redistribute it subject to the terms and conditions of the GNU
  ~  Lesser General Public License, as published by the Free Software Foundation.
  ~
  ~  This program is distributed in the hope that it will be useful,
  ~  but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~  for more details.
  ~
  ~  You should have received a copy of the GNU Lesser General Public License
  ~  along with this distribution; if not, write to:
  ~  Free Software Foundation, Inc.
  ~  51 Franklin Street, Fifth Floor
  ~  Boston, MA  02110-1301  USA
  -->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "../hsearch.ent">
%BOOK_ENTITIES;
]>
<chapter id="search-mapping" revision="3">
  <title>Mapping entities to the index structure</title>

  <section id="search-mapping-entity" revision="3">
    <title>Mapping an entity</title>

    <para>In <xref linkend="getting-started"/> you have already learned that
    all the metadata information needed to index entities is described through
    annotations. There is no need for xml mapping files. You can still use
    Hibernate mapping files for the basic Hibernate configuration, but the
    Hibernate Search specific configuration has to be expressed via
    annotations.</para>

    <note>
      <para>There is no XML configuration available for Hibernate Search but
      we provide a powerful programmatic mapping API that elegantly replaces
      this kind of deployment form (see <xref
      linkend="hsearch-mapping-programmaticapi"/> for more
      information).</para>

      <para>If you want to contribute the XML mapping implementation, see
      <ulink
      url="https://hibernate.onjira.com/browse/HSEARCH-210">HSEARCH-210</ulink>.</para>
    </note>

    <section id="basic-mapping">
      <title>Basic mapping</title>

      <para>Lets start with the most commonly used annotations when mapping an
      entity.</para>

      <section id="indexed-annotation">
        <title>@Indexed</title>

        <para>Foremost you must declare a persistent class as indexable by
        annotating the class with <literal>@Indexed.</literal> All entities
        not annotated with <literal>@Indexed</literal> will be ignored by the
        indexing process.</para>

        <example>
          <title>Making a class indexable with
          <classname>@Indexed</classname></title>

          <programlisting>@Entity
<emphasis role="bold">@Indexed</emphasis>
public class Essay {
    ...
}</programlisting>
        </example>

        <para>You can optionally specify the
        <literal><methodname>Indexed.index</methodname></literal> attribute to
        change the default name of the index. For more information regarding
        index naming see <xref
        linkend="search-configuration-directory"/>.</para>

        <para>You can also specify an optional indexing interceptor. For more
        information see <xref
        linkend="search-mapping-indexinginterceptor"/>.</para>
      </section>

      <section id="field-annotation">
        <title>@Field</title>

        <para>For each property (or attribute) of your entity, you have the
        ability to describe how it will be indexed. The default (no annotation
        present) means that the property is ignored by the indexing process.
        <literal>@Field</literal> does declare a property as indexed and
        allows you to configure several aspects of the indexing process by
        setting one or more of the following attributes:</para>

        <itemizedlist>
          <listitem>
            <para><literal>name</literal>: describe under which name the
            property should be stored in the Lucene Document. The default
            value is the property name (following the JavaBeans
            convention)</para>
          </listitem>

          <listitem>
            <para><literal>store</literal>: describe whether or not the
            property is stored in the Lucene index. You can store the value
            <literal>Store.YES</literal> (consuming more space in the index
            but allowing projection, see <xref linkend="projections"/>), store
            it in a compressed way <literal>Store.COMPRESS</literal> (this
            does consume more CPU), or avoid any storage
            <literal>Store.NO</literal> (this is the default value). When a
            property is stored, you can retrieve its original value from the
            Lucene Document. Storing the property has no impact though on
            whether the value is searchable or not.</para>
          </listitem>

          <listitem>
            <para><literal>index</literal>: describe whether the property is
            indexed or not. The different values are
            <literal>Index.NO</literal> (no indexing, i.e. cannot be found by
            a query), <literal>Index.YES</literal> (the element gets indexed
            and is searchable). The default value is
            <literal>Index.YES</literal>. <literal>Index.NO</literal> can be
            useful for cases where a property is not required to be
            searchable, but should be available for projection.</para>

            <tip>
              <para><literal>Index.NO</literal> in combination with
              <literal>Analyze.YES</literal> or <literal>Norms.YES</literal>
              is not useful, since <literal>analyze</literal> and
              <literal>norms</literal> require the property to be
              indexed</para>
            </tip>
          </listitem>

          <listitem>
            <para><literal>analyze</literal>: determines whether the property
            is analyzed (<literal>Analyze.YES</literal>) or not
            (<literal>Analyze.NO</literal>). The default value is
            <literal>Analyze.YES</literal>.<tip>
                <para>Whether or not you want to analyze a property depends on
                whether you wish to search the element as is, or by the words
                it contains. It make sense to analyze a text field, but
                probably not a date field.</para>
              </tip><tip>
                <para>Fields used for sorting or faceting <emphasis>must
                not</emphasis> be analyzed.</para>
              </tip></para>
          </listitem>

          <listitem>
            <para><literal>norms</literal>: describes whether index time
            boosting information should be stored
            (<literal>Norms.YES</literal>) or not
            (<literal>Norms.NO</literal>). Not storing the norms can save a
            considerable amount of memory, but index time boosting will not be
            available in this case. The default value is
            <literal>Norms.YES</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>termVector</literal>: describes collections of
            term-frequency pairs. This attribute enables the storing of the
            term vectors within the documents during indexing. The default
            value is <literal>TermVector.NO</literal>.</para>

            <para>The different values of this attribute are:</para>

            <informaltable align="left" width="">
              <tgroup cols="2">
                <thead>
                  <row>
                    <entry align="center">Value</entry>

                    <entry align="center">Definition</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry align="left">TermVector.YES</entry>

                    <entry>Store the term vectors of each document. This
                    produces two synchronized arrays, one contains document
                    terms and the other contains the term's frequency.</entry>
                  </row>

                  <row>
                    <entry align="left">TermVector.NO</entry>

                    <entry>Do not store term vectors.</entry>
                  </row>

                  <row>
                    <entry align="left">TermVector.WITH_OFFSETS</entry>

                    <entry>Store the term vector and token offset information.
                    This is the same as TermVector.YES plus it contains the
                    starting and ending offset position information for the
                    terms.</entry>
                  </row>

                  <row>
                    <entry align="left">TermVector.WITH_POSITIONS</entry>

                    <entry>Store the term vector and token position
                    information. This is the same as TermVector.YES plus it
                    contains the ordinal positions of each occurrence of a
                    term in a document.</entry>
                  </row>

                  <row>
                    <entry
                    align="left">TermVector.WITH_POSITION_OFFSETS</entry>

                    <entry>Store the term vector, token position and offset
                    information. This is a combination of the YES,
                    WITH_OFFSETS and WITH_POSITIONS.</entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </listitem>

          <listitem>
            <para><literal>indexNullAs</literal>: Per default
            <constant>null</constant> values are ignored and not indexed.
            However, using <parameter>indexNullAs</parameter> you can specify
            a string which will be inserted as token for the
            <constant>null</constant> value. Per default this value is set to
            <constant>org.hibernate.search.annotations.Field.DO_NOT_INDEX_NULL</constant>
            indicating that <constant>null</constant> values should not be
            indexed. You can set this value to <constant>DEFAULT_NULL_TOKEN
            </constant>to indicate that a default <constant>null</constant>
            token should be used. This default <constant>null</constant> token
            can be specified in the configuration using
            <literal>hibernate.search.default_null_token</literal>. If this
            property is not set the string "_null_" will be used as default.
            <note>
                <para>When <parameter>indexNullAs</parameter> is used, it is
                important to use the chosen <constant>null</constant> token in
                search queries (see <xref linkend="search-query"/>) in order
                to find <constant>null</constant> values. It is also advisable
                to use this feature only with un-analyzed fields
                (<literal><literal>analyze=</literal>Analyze.NO</literal>).</para>
              </note><warning>
                <para>When implementing a custom
                <classname>FieldBridge</classname> or
                <classname>TwoWayFieldBridge</classname> it is up to the
                developer to handle the indexing of null values (see JavaDocs
                of
                <methodname>LuceneOptions.indexNullAs()</methodname>).</para>
              </warning></para>
          </listitem>
        </itemizedlist>
      </section>

      <section id="numeric-field-annotation">
        <title>@NumericField</title>

        <para>There exists also a companion annotation to
        <classname>@Field,</classname> called
        <classname>@NumericField.</classname> It can be specified in the same
        scope as <classname>@Field</classname> or
        <classname>@DocumentId</classname>, but only on
        <classname>Integer</classname>, <classname>Long</classname>,
        <classname>Float</classname> or <classname>Double</classname>
        properties. When used, the annoated property will be indexed using a
        <ulink url="http://en.wikipedia.org/wiki/Trie">Trie structure</ulink>.
        This enables efficient range queries and sorting, resulting in query
        response times being orders of magnitude faster than the same query
        with plain <classname>@Field</classname>. The
        <classname>@NumericField</classname> annotation accepts the following
        parameters: <informaltable align="left" width="">
            <tgroup cols="2">
              <thead>
                <row>
                  <entry align="center">Value</entry>

                  <entry align="center">Definition</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry align="left">forField</entry>

                  <entry>(Optional) Specify the name of of the related @Field
                  that will be indexed as numeric. It's only mandatory when
                  the property contains more than a @Field declaration</entry>
                </row>

                <row>
                  <entry align="left">precisionStep</entry>

                  <entry>(Optional) Change the way that the Trie structure is
                  stored in the index. Smaller precisionSteps lead to more
                  disk space usage and faster range and sort queries. Larger
                  values lead to less space used and range query performance
                  more close to the range query in normal @Fields. Default
                  value is 4.</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>Lucene supports the numeric types: Double, Long,
        Integer and Float. Other numeric types should use the default string
        encoding (via <classname>@Field</classname>), unless the application
        can deal with a potential loss in precision, in which case a custom
        <classname>NumericFieldBridge</classname> can be used. See <xref
        linkend="example-custom-numericfieldbridge"/>.</para>

        <example id="example-custom-numericfieldbridge">
          <title>Defining a custom <classname>NumericFieldBridge for
          BigDecimal</classname></title>

          <programlisting language="JAVA" role="JAVA">public class BigDecimalNumericFieldBridge extends NumericFieldBridge {
   private static final BigDecimal storeFactor = BigDecimal.valueOf(100);

   @Override
   public void set(String name, Object value, Document document, LuceneOptions luceneOptions) {
      if ( value != null ) {
         BigDecimal decimalValue = (BigDecimal) value;
         Long indexedValue = Long.valueOf( decimalValue.multiply( storeFactor ).longValue() );
         luceneOptions.addNumericFieldToDocument( name, indexedValue, document );
      }
   }

    @Override
    public Object get(String name, Document document) {
        String fromLucene = document.get( name );
        BigDecimal storedBigDecimal = new BigDecimal( fromLucene );
        return storedBigDecimal.divide( storeFactor );
    }

}
</programlisting>
        </example>

        <para>You would use this custom bridge like seen in <xref
        linkend="example-useof-custom-numericfieldbridge"/>. In this case
        three annotations are used - <classname>@Field</classname>,
        <classname>@NumericField</classname> and
        <classname>@FieldBridge</classname>. <classname>@Field</classname> is
        required to mark the property for being indexed (a standalone
        <classname>@NumericField</classname> is never allowed).
        <classname>@NumericField</classname> might be ommited in this specific
        case, because the used <classname>@FieldBridge</classname> annotation
        refers already to a <classname>NumericFieldBridge</classname>
        instance. However, the use of <classname>@NumericField</classname> is
        recommended to make the use of the property as numeric value
        explicit.</para>

        <example id="example-useof-custom-numericfieldbridge">
          <title>Use of BigDecimalNumericFieldBridge</title>

          <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public static class Item {
    @Id
    @GeneratedValue
    private int id;

    @Field
    @NumericField
    @FieldBridge(impl = BigDecimalNumericFieldBridge.class)
    private BigDecimal price;

    public int getId() {
        return id;
    }

    public BigDecimal getPrice() {
       return price;
    }

    public void setPrice(BigDecimal price) {
        this.price = price;
    }
}</programlisting>
        </example>
      </section>

      <section id="id-annotation">
        <title>@Id</title>

        <para>Finally, the id property of an entity is a special property used
        by Hibernate Search to ensure index unicity of a given entity. By
        design, an id has to be stored and must not be tokenized. To mark a
        property as index id, use the <literal>@DocumentId</literal>
        annotation. If you are using JPA and you have specified
        <classname>@Id</classname> you can omit
        <classname>@DocumentId</classname>. The chosen entity id will also be
        used as document id.</para>

        <example id="example-annotated-entity">
          <title>Specifying indexed properties</title>

          <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public class Essay {
    ...

    @Id
    <emphasis role="bold">@DocumentId</emphasis>
    public Long getId() { return id; }

    <emphasis role="bold">@Field(name="Abstract", store=Store.YES)</emphasis>
    public String getSummary() { return summary; }

    @Lob
    <emphasis role="bold">@Field</emphasis>
    public String getText() { return text; }

    <emphasis role="bold">@Field 
    @NumericField(precisionStep = 6)</emphasis>
    public float getGrade() { return grade; }
}</programlisting>
        </example>

        <para><xref linkend="example-annotated-entity"/> defines an index with
        four fields: <literal>id</literal> , <literal>Abstract</literal>,
        <literal>text</literal> and <literal>grade</literal> . Note that by
        default the field name is decapitalized, following the JavaBean
        specification. The <literal>grade</literal> field is annotated as
        Numeric with a slightly larger precisionStep than the default.</para>
      </section>
    </section>

    <section>
      <title>Mapping properties multiple times</title>

      <para>Sometimes one has to map a property multiple times per index, with
      slightly different indexing strategies. For example, sorting a query by
      field requires the field to be un-analyzed. If one wants to search by
      words in this property and still sort it, one need to index it twice -
      once analyzed and once un-analyzed. @Fields allows to achieve this
      goal.</para>

      <example id="example-fields-annotation">
        <title>Using @Fields to map a property multiple times</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed(index = "Book")
public class Book {
    <emphasis role="bold">@Fields( {</emphasis>
            @Field,
            @Field(name = "summary_forSort", analyze = Analyze.NO, store = Store.YES)
            <emphasis role="bold">} )</emphasis>
    public String getSummary() {
        return summary;
    }

    ...
}</programlisting>
      </example>

      <para>In <xref linkend="example-fields-annotation"/> the field
      <literal>summary</literal> is indexed twice, once as
      <literal>summary</literal> in a tokenized way, and once as
      <literal>summary_forSort</literal> in an untokenized way. @Field
      supports 2 attributes useful when @Fields is used:</para>

      <itemizedlist>
        <listitem>
          <para>analyzer: defines a @Analyzer annotation per field rather than
          per property</para>
        </listitem>

        <listitem>
          <para>bridge: defines a @FieldBridge annotation per field rather
          than per property</para>
        </listitem>
      </itemizedlist>

      <para>See below for more information about analyzers and field
      bridges.</para>
    </section>

    <section id="search-mapping-associated">
      <title>Embedded and associated objects</title>

      <para>Associated objects as well as embedded objects can be indexed as
      part of the root entity index. This is useful if you expect to search a
      given entity based on properties of associated objects. In <xref
      linkend="example-indexing-associations"/>t the aim is to return places
      where the associated city is Atlanta (In the Lucene query parser
      language, it would translate into <code>address.city:Atlanta</code>).
      The place fields will be indexed in the <literal>Place</literal> index.
      The <literal>Place</literal> index documents will also contain the
      fields <literal>address.id</literal>, <literal>address.street</literal>,
      and <literal>address.city</literal> which you will be able to
      query.</para>

      <example id="example-indexing-associations">
        <title>Indexing associations</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public class Place {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field
    private String name;

    @OneToOne(cascade = { CascadeType.PERSIST, CascadeType.REMOVE })
    <emphasis role="bold">@IndexedEmbedded</emphasis>
    private Address address;
    ....
}

@Entity
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String street;

    @Field
    private String city;

    <emphasis role="bold">@ContainedIn</emphasis>
    @OneToMany(mappedBy="address")
    private Set&lt;Place&gt; places;
    ...
}</programlisting>
      </example>

      <para>Be careful. Because the data is denormalized in the Lucene index
      when using the <classname>@IndexedEmbedded</classname> technique,
      Hibernate Search needs to be aware of any change in the
      <classname>Place</classname> object and any change in the
      <classname>Address</classname> object to keep the index up to date. To
      make sure the <literal><classname>Place</classname></literal> Lucene
      document is updated when it's <classname>Address</classname> changes,
      you need to mark the other side of the bidirectional relationship with
      <classname>@ContainedIn</classname>.</para>

      <tip>
        <para><literal>@ContainedIn</literal> is useful on both associations
        pointing to entities and on embedded (collection of) objects.</para>
      </tip>

      <para>Let's make <xref linkend="example-indexing-associations"/> a bit
      more complex by nesting @IndexedEmbedded as seen in <xref
      linkend="example-nested-index-embedded"/>.</para>

      <example id="example-nested-index-embedded">
        <title>Nested usage of <classname>@IndexedEmbedded</classname> and
        <classname>@ContainedIn</classname></title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public class Place {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field
    private String name;

    @OneToOne(cascade = { CascadeType.PERSIST, CascadeType.REMOVE })
    <emphasis role="bold">@IndexedEmbedded</emphasis>
    private Address address;
    ....
}

@Entity
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String street;

    @Field
    private String city;

    <emphasis role="bold">@IndexedEmbedded(depth = 1, prefix = "ownedBy_")</emphasis>
    private Owner ownedBy;

    <emphasis role="bold">@ContainedIn</emphasis>
    @OneToMany(mappedBy="address")
    private Set&lt;Place&gt; places;
    ...
}

@Embeddable
public class Owner {
    @Field
    private String name;
   ...
}</programlisting>
      </example>

      <para>As you can see, any <literal>@*ToMany, @*ToOne</literal> and
      <literal>@Embedded</literal> attribute can be annotated with
      <literal>@IndexedEmbedded</literal>. The attributes of the associated
      class will then be added to the main entity index. In <xref
      linkend="example-nested-index-embedded"/> the index will contain the
      following fields</para>

      <itemizedlist>
        <listitem>
          <para>id</para>
        </listitem>

        <listitem>
          <para>name</para>
        </listitem>

        <listitem>
          <para>address.street</para>
        </listitem>

        <listitem>
          <para>address.city</para>
        </listitem>

        <listitem>
          <para>address.ownedBy_name</para>
        </listitem>
      </itemizedlist>

      <para>The default prefix is <literal>propertyName.</literal>, following
      the traditional object navigation convention. You can override it using
      the <literal>prefix</literal> attribute as it is shown on the
      <literal>ownedBy</literal> property.</para>

      <note>
        <para>The prefix cannot be set to the empty string.</para>
      </note>

      <para>The <literal>depth</literal> property is necessary when the object
      graph contains a cyclic dependency of classes (not instances). For
      example, if <classname>Owner</classname> points to
      <classname>Place</classname>. Hibernate Search will stop including
      Indexed embedded attributes after reaching the expected depth (or the
      object graph boundaries are reached). A class having a self reference is
      an example of cyclic dependency. In our example, because
      <literal>depth</literal> is set to 1, any
      <literal>@IndexedEmbedded</literal> attribute in Owner (if any) will be
      ignored.</para>

      <para>Using <literal>@IndexedEmbedded</literal> for object associations
      allows you to express queries (using Lucene's query syntax) such
      as:</para>

      <itemizedlist>
        <listitem>
          <para>Return places where name contains JBoss and where address city
          is Atlanta. In Lucene query this would be</para>

          <programlisting>+name:jboss +address.city:atlanta</programlisting>
        </listitem>

        <listitem>
          <para>Return places where name contains JBoss and where owner's name
          contain Joe. In Lucene query this would be</para>

          <programlisting>+name:jboss +address.ownedBy_name:joe</programlisting>
        </listitem>
      </itemizedlist>

      <para>In a way it mimics the relational join operation in a more
      efficient way (at the cost of data duplication). Remember that, out of
      the box, Lucene indexes have no notion of association, the join
      operation is simply non-existent. It might help to keep the relational
      model normalized while benefiting from the full text index speed and
      feature richness.</para>

      <para><note>
          <para>An associated object can itself (but does not have to) be
          <literal>@Indexed</literal></para>
        </note></para>

      <para>When @IndexedEmbedded points to an entity, the association has to
      be directional and the other side has to be annotated
      <literal>@ContainedIn</literal> (as seen in the previous example). If
      not, Hibernate Search has no way to update the root index when the
      associated entity is updated (in our example, a <literal>Place</literal>
      index document has to be updated when the associated
      <classname>Address</classname> instance is updated).</para>

      <para>Sometimes, the object type annotated by
      <classname>@IndexedEmbedded</classname> is not the object type targeted
      by Hibernate and Hibernate Search. This is especially the case when
      interfaces are used in lieu of their implementation. For this reason you
      can override the object type targeted by Hibernate Search using the
      <methodname>targetElement</methodname> parameter.</para>

      <example>
        <title>Using the <literal>targetElement</literal> property of
        <classname>@IndexedEmbedded</classname></title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public class Address {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field
    private String street;

    @IndexedEmbedded(depth = 1, prefix = "ownedBy_", <emphasis role="bold">targetElement = Owner.class</emphasis>)
    @Target(Owner.class)
    private Person ownedBy;

    ...
}

@Embeddable
public class Owner implements Person { ... }</programlisting>
      </example>

      <section id="search-mapping-associated-viapaths">
        <title>Limiting object embedding to specific paths</title>

        <para>The <classname>@IndexedEmbedded</classname> annotation provides
        also an attribute <methodname>includePaths</methodname> which can be
        used as an alternative to <methodname>depth</methodname>, or be
        combined with it.</para>

        <para>When using only <methodname>depth</methodname> all indexed
        fields of the embedded type will be added recursively at the same
        depth; this makes it harder to pick only a specific path without
        adding all other fields as well, which might not be needed.</para>

        <para>To avoid unnecessarily loading and indexing entities you can
        specify exactly which paths are needed. A typical application might
        need different depths for different paths, or in other words it might
        need to specify paths explicitly, as shown in <xref
        linkend="indexedembedded-includePath"/></para>

        <example id="indexedembedded-includePath">
          <title>Using the <literal>includePaths</literal> property of
          <classname>@IndexedEmbedded</classname></title>

          <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public class Person {

   @Id
   public int getId() {
      return id;
   }

   @Field
   public String getName() {
      return name;
   }

   @Field
   public String getSurname() {
      return surname;
   }

   @OneToMany
   <emphasis role="bold">@IndexedEmbedded(includePaths = { "name" })</emphasis>
   public Set&lt;Person&gt; getParents() {
      return parents;
   }

   @ContainedIn
   @ManyToOne
   public Human getChild() {
      return child;
   }

    ...//other fields omitted</programlisting>
        </example>

        <para>Using a mapping as in <xref
        linkend="indexedembedded-includePath"/>, you would be able to search
        on a <classname>Person</classname> by <literal>name</literal> and/or
        <literal>surname</literal>, and/or the <literal>name</literal> of the
        parent. It will not index the <literal>surname</literal> of the
        parent, so searching on parent's surnames will not be possible but
        speeds up indexing, saves space and improve overall
        performance.</para>

        <para>The <classname>@IndexedEmbedded</classname>
        <methodname>includePaths</methodname> will include the specified paths
        <emphasis>in addition to</emphasis> what you would index normally
        specifying a limited value for <methodname>depth</methodname>. When
        using <methodname>includePaths</methodname>, and leaving
        <methodname>depth</methodname> undefined, behavior is equivalent to
        setting <methodname>depth</methodname><literal>=0</literal>: only the
        included paths are indexed.</para>

        <example id="indexedembedded-includePathsAndDepth">
          <title>Using the <literal>includePaths</literal> property of
          <classname>@IndexedEmbedded</classname></title>

          <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public class Human {

   @Id
   public int getId() {
      return id;
   }

   @Field
   public String getName() {
      return name;
   }

   @Field
   public String getSurname() {
      return surname;
   }

   @OneToMany
   <emphasis role="bold">@IndexedEmbedded(depth = 2, includePaths = { "parents.parents.name" })</emphasis>
   public Set&lt;Human&gt; getParents() {
      return parents;
   }

   @ContainedIn
   @ManyToOne
   public Human getChild() {
      return child;
   }

    ...//other fields omitted</programlisting>
        </example>

        <para>In <xref linkend="indexedembedded-includePathsAndDepth"/>, every
        human will have it's name and surname attributes indexed. The name and
        surname of parents will be indexed too, recursively up to second line
        because of the <methodname>depth</methodname> attribute. It will be
        possible to search by name or surname, of the person directly, his
        parents or of his grand parents. Beyond the second level, we will in
        addition index one more level but only the name, not the
        surname.</para>

        <para>This results in the following fields in the index:</para>

        <itemizedlist>
          <listitem>
            <para><literal>id</literal> - as primary key</para>
          </listitem>

          <listitem>
            <para><literal>_hibernate_class</literal> - stores entity
            type</para>
          </listitem>

          <listitem>
            <para><literal>name</literal> - as direct field</para>
          </listitem>

          <listitem>
            <para><literal>surname</literal> - as direct field</para>
          </listitem>

          <listitem>
            <para><literal>parents.name</literal> - as embedded field at depth
            1</para>
          </listitem>

          <listitem>
            <para><literal>parents.surname</literal> - as embedded field at
            depth 1</para>
          </listitem>

          <listitem>
            <para><literal>parents.parents.name</literal> - as embedded field
            at depth 2</para>
          </listitem>

          <listitem>
            <para><literal>parents.parents.surname</literal> - as embedded
            field at depth 2</para>
          </listitem>

          <listitem>
            <para><literal>parents.parents.parents.name</literal> - as
            additional path as specifyed by
            <methodname>includePaths</methodname>. The first
            <literal>parents.</literal> is inferred from the field name, the
            remaining path is the attribute of
            <methodname>includePaths</methodname></para>
          </listitem>
        </itemizedlist>

        <para>Having explicit control of the indexed paths might be easier if
        you're designing your application by defining the needed queries
        first, as at that point you might know exactly which fields you need,
        and which other fields are unnecessary to implement your use
        case.</para>
      </section>
    </section>
  </section>

  <section>
    <title>Boosting</title>

    <para>Lucene has the notion of <emphasis>boosting</emphasis> which allows
    you to give certain documents or fields more or less importance than
    others. Lucene differentiates between index and search time boosting. The
    following sections show you how you can achieve index time boosting using
    Hibernate Search.</para>

    <section id="section-boost-annotation">
      <title>Static index time boosting</title>

      <para>To define a static boost value for an indexed class or property
      you can use the <classname>@Boost</classname> annotation. You can use
      this annotation within @Field or specify it directly on method or class
      level.</para>

      <example id="example-boost">
        <title>Different ways of using @Boost</title>

        <programlisting>@Entity
@Indexed
<emphasis role="bold">@Boost(1.7f)</emphasis>
public class Essay {
    ...

    @Id
    @DocumentId
    public Long getId() { return id; }

    @Field(name="Abstract", store=Store.YES, boost=<emphasis role="bold">@Boost(2f)</emphasis>)
    <emphasis role="bold">@Boost(1.5f)</emphasis>
    public String getSummary() { return summary; }

    @Lob
    @Field(boost=<emphasis role="bold">@Boost(1.2f)</emphasis>)
    public String getText() { return text; }

    @Field
    public String getISBN() { return isbn; }

}        </programlisting>
      </example>

      <para>In <xref linkend="example-boost"/>, <classname>Essay</classname>'s
      probability to reach the top of the search list will be multiplied by
      1.7. The <methodname>summary</methodname> field will be 3.0 (2 * 1.5,
      because <methodname>@Field.boost</methodname> and
      <classname>@Boost</classname> on a property are cumulative) more
      important than the <methodname>isbn</methodname> field. The
      <methodname>text</methodname> field will be 1.2 times more important
      than the <methodname>isbn</methodname> field. Note that this explanation
      is wrong in strictest terms, but it is simple and close enough to
      reality for all practical purposes. Please check the Lucene
      documentation or the excellent <citetitle>Lucene In Action </citetitle>
      from Otis Gospodnetic and Erik Hatcher.</para>
    </section>

    <section>
      <title id="section-dynamic-boost">Dynamic index time boosting</title>

      <para>The <literal>@Boost </literal>annotation used in <xref
      linkend="section-boost-annotation"/> defines a static boost factor which
      is independent of the state of of the indexed entity at runtime.
      However, there are usecases in which the boost factor may depend on the
      actual state of the entity. In this case you can use the
      <literal>@DynamicBoost </literal>annotation together with an
      accompanying custom <classname>BoostStrategy</classname>.</para>

      <example id="example-dynamic-boosting">
        <title>Dynamic boost example</title>

        <programlisting language="JAVA" role="JAVA">public enum PersonType {
    NORMAL,
    VIP
}

@Entity
@Indexed
<emphasis role="bold">@DynamicBoost(impl = VIPBoostStrategy.class)</emphasis>
public class Person {
    private PersonType type;   
    
    // ....
}

public class VIPBoostStrategy implements BoostStrategy {
    <emphasis role="bold">public float defineBoost(Object value)</emphasis> {
        Person person = ( Person ) value;
        if ( person.getType().equals( PersonType.VIP ) ) {
            return 2.0f;
        }
        else {
            return 1.0f;
        }
    }
}</programlisting>
      </example>

      <para>In <xref linkend="example-dynamic-boosting"/> a dynamic boost is
      defined on class level specifying
      <classname>VIPBoostStrategy</classname> as implementation of the
      <classname>BoostStrategy</classname> interface to be used at indexing
      time. You can place the <literal>@DynamicBoost</literal> either at class
      or field level. Depending on the placement of the annotation either the
      whole entity is passed to the <methodname>defineBoost</methodname>
      method or just the annotated field/property value. It's up to you to
      cast the passed object to the correct type. In the example all indexed
      values of a VIP person would be double as important as the values of a
      normal person.<note>
          <para>The specified <classname>BoostStrategy</classname>
          implementation must define a public no-arg constructor.</para>
        </note>Of course you can mix and match <literal>@Boost</literal> and
      <literal>@DynamicBoost</literal> annotations in your entity. All defined
      boost factors are cumulative.</para>
    </section>
  </section>

  <section>
    <title>Analysis</title>

    <para><literal>Analysis</literal> is the process of converting text into
    single terms (words) and can be considered as one of the key features of a
    fulltext search engine. Lucene uses the concept of
    <classname>Analyzer</classname>s to control this process. In the following
    section we cover the multiple ways Hibernate Search offers to configure
    the analyzers.</para>

    <section id="analyzer">
      <title>Default analyzer and analyzer by class</title>

      <para>The default analyzer class used to index tokenized fields is
      configurable through the <literal>hibernate.search.analyzer</literal>
      property. The default value for this property is
      <classname>org.apache.lucene.analysis.standard.StandardAnalyzer</classname>.</para>

      <para>You can also define the analyzer class per entity, property and
      even per @Field (useful when multiple fields are indexed from a single
      property).</para>

      <example>
        <title>Different ways of using @Analyzer</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
<emphasis role="bold">@Analyzer(impl = EntityAnalyzer.class)</emphasis>
public class MyEntity {
    @Id
    @GeneratedValue
    @DocumentId
    private Integer id;

    @Field
    private String name;

    @Field
    <emphasis role="bold">@Analyzer(impl = PropertyAnalyzer.class)</emphasis>
    private String summary;

    @Field(<emphasis role="bold">analyzer = @Analyzer(impl = FieldAnalyzer.class</emphasis>)
    private String body;

    ...
}</programlisting>
      </example>

      <para>In this example, <classname>EntityAnalyzer</classname> is used to
      index all tokenized properties (eg. <literal>name</literal>), except
      <literal>summary</literal> and <literal>body</literal> which are indexed
      with <classname>PropertyAnalyzer</classname> and
      <classname>FieldAnalyzer</classname> respectively.</para>

      <caution>
        <para>Mixing different analyzers in the same entity is most of the
        time a bad practice. It makes query building more complex and results
        less predictable (for the novice), especially if you are using a
        QueryParser (which uses the same analyzer for the whole query). As a
        rule of thumb, for any given field the same analyzer should be used
        for indexing and querying.</para>
      </caution>
    </section>

    <section>
      <title>Named analyzers</title>

      <para>Analyzers can become quite complex to deal with. For this reason
      introduces Hibernate Search the notion of analyzer definitions. An
      analyzer definition can be reused by many
      <classname>@Analyzer</classname> declarations and is composed of:</para>

      <itemizedlist>
        <listitem>
          <para>a name: the unique string used to refer to the
          definition</para>
        </listitem>

        <listitem>
          <para>a list of char filters: each char filter is responsible to
          pre-process input characters before the tokenization. Char filters
          can add, change or remove characters; one common usage is for
          characters normalization</para>
        </listitem>

        <listitem>
          <para>a tokenizer: responsible for tokenizing the input stream into
          individual words</para>
        </listitem>

        <listitem>
          <para>a list of filters: each filter is responsible to remove,
          modify or sometimes even add words into the stream provided by the
          tokenizer</para>
        </listitem>
      </itemizedlist>

      <para>This separation of tasks - a list of char filters, and a tokenizer
      followed by a list of filters - allows for easy reuse of each individual
      component and let you build your customized analyzer in a very flexible
      way (just like Lego). Generally speaking the char filters do some
      pre-processing in the character input, then the
      <classname>Tokenizer</classname> starts the tokenizing process by
      turning the character input into tokens which are then further processed
      by the <classname>TokenFilter</classname>s. Hibernate Search supports
      this infrastructure by utilizing the Solr analyzer framework.</para>

      <note>
        <para>Some of the analyzers and filters will require additional
        dependencies. For example to use the snowball stemmer you have to also
        include the <literal>lucene-snowball</literal> jar and for the
        <classname>PhoneticFilterFactory</classname> you need the <ulink
        url="http://commons.apache.org/codec">commons-codec</ulink> jar. Your
        distribution of Hibernate Search provides these dependencies in its
        <filename>lib/optional</filename> directory. Have a look at <xref
        linkend="table-available-tokenizers"/> and <xref
        linkend="table-available-filters"/> to see which anaylzers and filters
        have additional dependencies</para>

        <para>Prior to Search version 3.3.0.Beta2 it was required to add the
        Solr dependency <emphasis>org.apache.solr:solr-core</emphasis> when
        you wanted to use the analyzer definition framework. In case you are
        using Maven this is no longer needed: all required Solr dependencies
        are now defined as dependencies of the artifact
        <emphasis>org.hibernate:hibernate-search-analyzers</emphasis>; just
        add the following dependency :<programlisting>&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-search-analyzers&lt;/artifactId&gt;
   &lt;version&gt;&version;&lt;/version&gt;
&lt;dependency&gt;</programlisting></para>
      </note>

      <para>Let's have a look at a concrete example now - <xref
      linkend="example-analyzer-def"/>. First a char filter is defined by its
      factory. In our example, a mapping char filter is used, and will replace
      characters in the input based on the rules specified in the mapping
      file. Next a tokenizer is defined. This example uses the standard
      tokenizer. Last but not least, a list of filters is defined by their
      factories. In our example, the <classname>StopFilter</classname> filter
      is built reading the dedicated words property file. The filter is also
      expected to ignore case.</para>

      <example id="example-analyzer-def">
        <title><classname>@AnalyzerDef</classname> and the Solr
        framework</title>

        <programlisting language="JAVA" role="JAVA">@AnalyzerDef(name="customanalyzer",
  charFilters = {
    @CharFilterDef(factory = MappingCharFilterFactory.class, params = {
      @Parameter(name = "mapping",
        value = "org/hibernate/search/test/analyzer/solr/mapping-chars.properties")
    })
  },
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = ISOLatin1AccentFilterFactory.class),
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = StopFilterFactory.class, params = {
      @Parameter(name="words",
        value= "org/hibernate/search/test/analyzer/solr/stoplist.properties" ),
      @Parameter(name="ignoreCase", value="true")
    })
})
public class Team {
    ...
}</programlisting>
      </example>

      <tip>
        <para>Filters and char filters are applied in the order they are
        defined in the <classname>@AnalyzerDef</classname> annotation. Order
        matters!</para>
      </tip>

      <para>Some tokenizers, token filters or char filters load resources like
      a configuration or metadata file. This is the case for the stop filter
      and the synonym filter. If the resource charset is not using the VM
      default, you can explicitly specify it by adding a
      <literal>resource_charset</literal> parameter.</para>

      <example id="example-analyzer-def-charset">
        <title>Use a specific charset to load the property file</title>

        <programlisting language="JAVA" role="JAVA">@AnalyzerDef(name="customanalyzer",
  charFilters = {
    @CharFilterDef(factory = MappingCharFilterFactory.class, params = {
      @Parameter(name = "mapping",
        value = "org/hibernate/search/test/analyzer/solr/mapping-chars.properties")
    })
  },
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = ISOLatin1AccentFilterFactory.class),
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = StopFilterFactory.class, params = {
      @Parameter(name="words",
        value= "org/hibernate/search/test/analyzer/solr/stoplist.properties" ),
      @Parameter(name="resource_charset", value = "UTF-16BE"),
      @Parameter(name="ignoreCase", value="true")
  })
})
public class Team {
    ...
}</programlisting>
      </example>

      <para>Once defined, an analyzer definition can be reused by an
      <classname>@Analyzer</classname> declaration as seen in <xref
      linkend="example-referencing-analyzer-def"/>.</para>

      <example>
        <title id="example-referencing-analyzer-def" remap="">Referencing an
        analyzer by name</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
@AnalyzerDef(name="customanalyzer", ... )
public class Team {
    @Id
    @DocumentId
    @GeneratedValue
    private Integer id;

    @Field
    private String name;

    @Field
    private String location;

    @Field 
    <emphasis role="bold">@Analyzer(definition = "customanalyzer")</emphasis>
    private String description;
}</programlisting>
      </example>

      <para>Analyzer instances declared by <classname>@AnalyzerDef</classname>
      are also available by their name in the
      <classname>SearchFactory</classname> which is quite useful wen building
      queries.</para>

      <programlisting language="JAVA" role="JAVA">Analyzer analyzer = fullTextSession.getSearchFactory().getAnalyzer("customanalyzer");</programlisting>

      <para>Fields in queries should be analyzed with the same analyzer used
      to index the field so that they speak a common "language": the same
      tokens are reused between the query and the indexing process. This rule
      has some exceptions but is true most of the time. Respect it unless you
      know what you are doing.</para>

      <section>
        <title>Available analyzers</title>

        <para>Solr and Lucene come with a lot of useful default char filters,
        tokenizers and filters. You can find a complete list of char filter
        factories, tokenizer factories and filter factories at <ulink
        url="http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters">http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters</ulink>.
        Let's check a few of them.</para>

        <table id="table-available-char-filters">
          <title>Example of available char filters</title>

          <tgroup cols="4">
            <thead>
              <row>
                <entry align="center">Factory</entry>

                <entry align="center">Description</entry>

                <entry align="center">Parameters</entry>

                <entry align="center">Additional dependencies</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><classname>MappingCharFilterFactory</classname></entry>

                <entry>Replaces one or more characters with one or more
                characters, based on mappings specified in the resource
                file</entry>

                <entry><para><literal>mapping</literal>: points to a resource
                file containing the mappings using the format: <literallayout>
                    "" =&gt; "a"
                    "" =&gt; "n"
                    "" =&gt; "o"
                </literallayout> </para></entry>

                <entry>none</entry>
              </row>

              <row>
                <entry><classname>HTMLStripCharFilterFactory</classname></entry>

                <entry>Remove HTML standard tags, keeping the text</entry>

                <entry>none</entry>

                <entry>none</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table id="table-available-tokenizers">
          <title>Example of available tokenizers</title>

          <tgroup cols="4">
            <thead>
              <row>
                <entry align="center">Factory</entry>

                <entry align="center">Description</entry>

                <entry align="center">Parameters</entry>

                <entry align="center">Additional dependencies</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><classname>StandardTokenizerFactory</classname></entry>

                <entry>Use the Lucene StandardTokenizer</entry>

                <entry>none</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry><classname>HTMLStripCharFilterFactory</classname></entry>

                <entry>Remove HTML tags, keep the text and pass it to a
                StandardTokenizer.</entry>

                <entry>none</entry>

                <entry><literal>solr-core</literal></entry>
              </row>

              <row>
                <entry><classname>PatternTokenizerFactory</classname></entry>

                <entry>Breaks text at the specified regular expression
                pattern.</entry>

                <entry><para><literal>pattern</literal>: the regular
                expression to use for tokenizing</para><para>group: says which
                pattern group to extract into tokens</para></entry>

                <entry><literal>solr-core</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table id="table-available-filters">
          <title>Examples of available filters</title>

          <tgroup cols="4">
            <thead>
              <row>
                <entry align="center">Factory</entry>

                <entry align="center">Description</entry>

                <entry align="center">Parameters</entry>

                <entry align="center">Additional dependencies</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><classname>StandardFilterFactory</classname></entry>

                <entry>Remove dots from acronyms and 's from words</entry>

                <entry>none</entry>

                <entry><literal>solr-core</literal></entry>
              </row>

              <row>
                <entry><classname>LowerCaseFilterFactory</classname></entry>

                <entry>Lowercases all words</entry>

                <entry>none</entry>

                <entry><literal>solr-core</literal></entry>
              </row>

              <row>
                <entry><classname>StopFilterFactory</classname></entry>

                <entry>Remove words (tokens) matching a list of stop
                words</entry>

                <entry><para><literal>words</literal>: points to a resource
                file containing the stop words</para><para>ignoreCase: true if
                <literal>case</literal> should be ignore when comparing stop
                words, <literal>false</literal> otherwise </para></entry>

                <entry><literal>solr-core</literal></entry>
              </row>

              <row>
                <entry><classname>SnowballPorterFilterFactory</classname></entry>

                <entry>Reduces a word to it's root in a given language. (eg.
                protect, protects, protection share the same root). Using such
                a filter allows searches matching related words.</entry>

                <entry><literal>language</literal>: Danish, Dutch, English,
                Finnish, French, German, Italian, Norwegian, Portuguese,
                Russian, Spanish, Swedish and a few more</entry>

                <entry><literal>solr-core</literal></entry>
              </row>

              <row>
                <entry><classname>ISOLatin1AccentFilterFactory</classname></entry>

                <entry>Remove accents for languages like French</entry>

                <entry>none</entry>

                <entry><literal>solr-core</literal></entry>
              </row>

              <row>
                <entry><classname>PhoneticFilterFactory</classname></entry>

                <entry>Inserts phonetically similar tokens into the token
                stream</entry>

                <entry><para><literal>encoder</literal>: One of
                DoubleMetaphone, Metaphone, Soundex or
                RefinedSoundex</para><para>inject: <constant>true</constant>
                will add tokens to the stream, <constant>false</constant> will
                replace the existing token
                </para><para><literal>maxCodeLength</literal>: sets the
                maximum length of the code to be generated. Supported only for
                Metaphone and DoubleMetaphone encodings</para></entry>

                <entry><literal>solr-core</literal> and
                <literal>commons-codec</literal></entry>
              </row>

              <row>
                <entry><classname>CollationKeyFilterFactory</classname></entry>

                <entry>Converts each token into its
                <classname>java.text.CollationKey</classname>, and then
                encodes the <classname>CollationKey</classname> with
                <classname>IndexableBinaryStringTools</classname>, to allow it
                to be stored as an index term.</entry>

                <entry><literal>custom</literal>, <literal>language</literal>,
                <literal>country</literal>, <literal>variant</literal>,
                <literal>strength</literal>, <literal>decomposition
                </literal>see Lucene's
                <classname>CollationKeyFilter</classname> javadocs for more
                info</entry>

                <entry><literal>solr-core</literal> and
                <literal>commons-io</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>We recommend to check all the implementations of
        <classname>org.apache.solr.analysis.TokenizerFactory</classname> and
        <classname>org.apache.solr.analysis.TokenFilterFactory</classname> in
        your IDE to see the implementations available.</para>
      </section>
    </section>

    <section>
      <title>Dynamic analyzer selection</title>

      <para>So far all the introduced ways to specify an analyzer were static.
      However, there are use cases where it is useful to select an analyzer
      depending on the current state of the entity to be indexed, for example
      in a multilingual applications. For an <classname>BlogEntry</classname>
      class for example the analyzer could depend on the language property of
      the entry. Depending on this property the correct language specific
      stemmer should be chosen to index the actual text.</para>

      <para>To enable this dynamic analyzer selection Hibernate Search
      introduces the <classname>AnalyzerDiscriminator</classname> annotation.
      <xref linkend="example-analyzer-discriminator"/> demonstrates the usage
      of this annotation.</para>

      <example id="example-analyzer-discriminator">
        <title>Usage of @AnalyzerDiscriminator</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
@AnalyzerDefs({
  @AnalyzerDef(name = "en",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = EnglishPorterFilterFactory.class
      )
    }),
  @AnalyzerDef(name = "de",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = GermanStemFilterFactory.class)
    })
})
public class BlogEntry {

    @Id
    @GeneratedValue
    @DocumentId
    private Integer id;

    @Field
    @AnalyzerDiscriminator(impl = LanguageDiscriminator.class)
    private String language;
    
    @Field
    private String text;
    
    private Set&lt;BlogEntry&gt; references;

    // standard getter/setter
    ...
}</programlisting>

        <programlisting language="JAVA" role="JAVA">public class LanguageDiscriminator implements Discriminator {

    public String getAnalyzerDefinitionName(Object value, Object entity, String field) {
        if ( value == null || !( entity instanceof Article ) ) {
            return null;
        }
        return (String) value;

    }
}</programlisting>
      </example>

      <para>The prerequisite for using
      <classname>@AnalyzerDiscriminator</classname> is that all analyzers
      which are going to be used dynamically are predefined via
      <classname>@AnalyzerDef</classname> definitions. If this is the case,
      one can place the <classname>@AnalyzerDiscriminator</classname>
      annotation either on the class or on a specific property of the entity
      for which to dynamically select an analyzer. Via the
      <literal>impl</literal> parameter of the
      <classname>AnalyzerDiscriminator</classname> you specify a concrete
      implementation of the <classname>Discriminator</classname> interface. It
      is up to you to provide an implementation for this interface. The only
      method you have to implement is
      <classname>getAnalyzerDefinitionName()</classname> which gets called for
      each field added to the Lucene document. The entity which is getting
      indexed is also passed to the interface method. The
      <literal>value</literal> parameter is only set if the
      <classname>AnalyzerDiscriminator</classname> is placed on property level
      instead of class level. In this case the value represents the current
      value of this property.</para>

      <para>An implemention of the <classname>Discriminator</classname>
      interface has to return the name of an existing analyzer definition or
      <classname>null</classname> if the default analyzer should not be
      overridden. <xref linkend="example-analyzer-discriminator"/> assumes
      that the language parameter is either 'de' or 'en' which matches the
      specified names in the <classname>@AnalyzerDef</classname>s.</para>
    </section>

    <section id="analyzer-retrievinganalyzer">
      <title>Retrieving an analyzer</title>

      <para>In some situations retrieving analyzers can be handy. For example,
      if your domain model makes use of multiple analyzers (maybe to benefit
      from stemming, use phonetic approximation and so on), you need to make
      sure to use the same analyzers when you build your query.</para>

      <note>
        <para>This rule can be broken but you need a good reason for it. If
        you are unsure, use the same analyzers. If you use the Hibernate
        Search query DSL (see <xref linkend="search-query-querydsl"/>), you
        don't have to think about it. The query DSL does use the right
        analyzer transparently for you.</para>
      </note>

      <para>Whether you are using the Lucene programmatic API or the Lucene
      query parser, you can retrieve the scoped analyzer for a given entity. A
      scoped analyzer is an analyzer which applies the right analyzers
      depending on the field indexed. Remember, multiple analyzers can be
      defined on a given entity each one working on an individual field. A
      scoped analyzer unifies all these analyzers into a context-aware
      analyzer. While the theory seems a bit complex, using the right analyzer
      in a query is very easy.</para>

      <example>
        <title>Using the scoped analyzer when building a full-text
        query</title>

        <programlisting language="JAVA" role="JAVA">org.apache.lucene.queryParser.QueryParser parser = new QueryParser(
    "title", 
    fullTextSession.getSearchFactory().getAnalyzer( Song.class )
);

org.apache.lucene.search.Query luceneQuery = 
    parser.parse( "title:sky Or title_stemmed:diamond" );

org.hibernate.Query fullTextQuery = 
    fullTextSession.createFullTextQuery( luceneQuery, Song.class );

List result = fullTextQuery.list(); //return a list of managed objects
</programlisting>
      </example>

      <para>In the example above, the song title is indexed in two fields: the
      standard analyzer is used in the field <literal>title</literal> and a
      stemming analyzer is used in the field <literal>title_stemmed</literal>.
      By using the analyzer provided by the search factory, the query uses the
      appropriate analyzer depending on the field targeted.</para>

      <tip>
        <para>You can also retrieve analyzers defined via
        <classname>@AnalyzerDef</classname> by their definition name using
        <code>searchFactory.getAnalyzer(String)</code>.</para>
      </tip>
    </section>
  </section>

  <section id="search-mapping-bridge">
    <title>Bridges</title>

    <para>When discussing the basic mapping for an entity one important fact
    was so far disregarded. In Lucene all index fields have to be represented
    as strings. All entity properties annotated with <literal>@Field</literal>
    have to be converted to strings to be indexed. The reason we have not
    mentioned it so far is, that for most of your properties Hibernate Search
    does the translation job for you thanks to a set of built-in bridges.
    However, in some cases you need a more fine grained control over the
    translation process.</para>

    <section>
      <title>Built-in bridges</title>

      <para>Hibernate Search comes bundled with a set of built-in bridges
      between a Java property type and its full text representation.</para>

      <variablelist>
        <varlistentry>
          <term>null</term>

          <listitem>
            <para>Per default <constant>null</constant> elements are not
            indexed. Lucene does not support null elements. However, in some
            situation it can be useful to insert a custom token representing
            the <constant>null</constant> value. See <xref lang=""
            linkend="field-annotation"/> for more information.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>java.lang.String</term>

          <listitem>
            <para>Strings are indexed as are</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>short, Short, integer, Integer, long, Long, float, Float,
          double, Double, BigInteger, BigDecimal</term>

          <listitem>
            <para>Numbers are converted into their string representation. Note
            that numbers cannot be compared by Lucene (ie used in ranged
            queries) out of the box: they have to be padded <note>
                <para>Using a Range query has drawbacks; an alternative
                approach is to use a Filter query which will filter the result
                query to the appropriate range.</para>

                <para>Hibernate Search will support a padding mechanism</para>
              </note></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>java.util.Date</term>

          <listitem>
            <para>Dates are stored as yyyyMMddHHmmssSSS in GMT time
            (200611072203012 for Nov 7th of 2006 4:03PM and 12ms EST). You
            shouldn't really bother with the internal format. What is
            important is that when using a TermRangeQuery, you should know
            that the dates have to be expressed in GMT time.</para>

            <para>Usually, storing the date up to the millisecond is not
            necessary. <literal>@DateBridge</literal> defines the appropriate
            resolution you are willing to store in the index
            (<literal>@DateBridge(resolution=Resolution.DAY)</literal>). The
            date pattern will then be truncated accordingly.</para>

            <programlisting language="JAVA" role="JAVA">@Entity 
@Indexed
public class Meeting {
    @Field(analyze=Analyze.NO)
    <emphasis role="bold">@DateBridge(resolution=Resolution.MINUTE)</emphasis>
    private Date date;
    ...                 </programlisting>

            <warning>
              <para>A Date whose resolution is lower than
              <literal>MILLISECOND</literal> cannot be a
              <literal>@DocumentId</literal></para>
            </warning>

            <important>
              <para>The default <classname>Date</classname> bridge uses
              Lucene's <classname>DateTools</classname> to convert from and to
              <classname>String</classname>. This means that all dates are
              expressed in GMT time. If your requirements are to store dates
              in a fixed time zone you have to implement a custom date bridge.
              Make sure you understand the requirements of your applications
              regarding to date indexing and searching.</para>
            </important>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>java.net.URI, java.net.URL</term>

          <listitem>
            <para>URI and URL are converted to their string
            representation</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>java.lang.Class</term>

          <listitem>
            <para>Class are converted to their fully qualified class name. The
            thread context classloader is used when the class is
            rehydrated</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section>
      <title>Tika bridge</title>

      <para>Hibernate Search allows you to extract text from various document
      types using the built-in <classname>TikaBridge</classname> which
      utilizes <ulink url="http://tika.apache.org">Apache Tika</ulink> to
      extract text and metadata from the provided documents. The
      <classname>TikaBridge</classname> annotation can be used with
      <classname>String</classname>, <classname>URI</classname>,
      <classname>byte[]</classname> or <classname>java.sql.Blob</classname>
      properties. In the case of <classname>String</classname> and
      <classname>URI</classname> the bridge interprets the values are file
      paths and tries to open a file to parse the document. In the case of
      <classname>byte[]</classname> and <classname>Blob</classname> the values
      are directly passed to Tika for parsing.</para>

      <para>Tika uses metadata as in- and output of the parsing process and it
      also allows to provide additional context information. This process is
      described in <ulink
      url="http://tika.apache.org/1.1/parser.html#apiorgapachetikametadataMetadata.html">Parser
      interface</ulink>. The Hibernate Search Tika bridge allows you to make
      use of these additional configuration options by providing two
      interfaces in conjunction with <classname>TikaBridge</classname>. The
      first interface is the <classname>TikaParseContextProvider</classname>.
      It allows you to create a custom <classname>ParseContext</classname> for
      the document parsing. The second interface is
      <classname>TikaMetadataProcessor</classname> which has two methods -
      <methodname>prepareMetadata()</methodname> and <methodname>set(String,
      Object, Document, LuceneOptions, Metadata metadata)</methodname>. The
      former allows to add additional metadata to the parsing process (for
      example the file name) and the latter allows you to index metadata
      discovered during the parsing process.</para>

      <para><classname>TikaParseContextProvider</classname> as well as
      <classname>TikaMetadataProcessor</classname> implementation classes can
      both be specified as parameters on the TikaBridge annotation.</para>

      <example id="example-tika-mapping">
        <title>Example mapping with Apache Tika</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public class Song {
    @Id
    @GeneratedValue
    long id;

    @Field
    <emphasis role="bold">@TikaBridge(metadataProcessor = Mp3TikaMetadataProcessor.class)</emphasis>
    String mp3FileName;

    [...]
}</programlisting>

        <programlisting language="JAVA" role="JAVA">QueryBuilder queryBuilder = fullTextSession.getSearchFactory()
    .buildQueryBuilder()
    .forEntity( Song.class )
    .get();
Query query = queryBuilder.keyword()
    .onField( "mp3FileName" )
    <emphasis role="bold">.ignoreFieldBridge()</emphasis>   //mandatory
    .matching( "Apes" )
    .createQuery();
List result = fullTextSession.createFullTextQuery( query ).list();</programlisting>
      </example>

      <para>In the <xref linkend="example-tika-mapping"/> the property
      <methodname>mp3FileName</methodname> represents a path to an MP3 file;
      the headers of this file will be indexed and so the performed query will
      be able to match the MP3 metadata.</para>

      <warning>
        <para>TikaBridge does not implement TwoWayFieldBridge: queries built
        using the DSL (as in the <xref linkend="example-tika-mapping"/>) need
        to explicitly enable the option
        <methodname>ignoreFieldBridge()</methodname>.</para>
      </warning>
    </section>

    <section>
      <title>Custom bridges</title>

      <para>Sometimes, the built-in bridges of Hibernate Search do not cover
      some of your property types, or the String representation used by the
      bridge does not meet your requirements. The following paragraphs
      describe several solutions to this problem.</para>

      <section>
        <title>StringBridge</title>

        <para>The simplest custom solution is to give Hibernate Search an
        implementation of your expected <classname>Object</classname> to
        <classname>String</classname> bridge. To do so you need to implement
        the <literal>org.hibernate.search.bridge.StringBridge</literal>
        interface. All implementations have to be thread-safe as they are used
        concurrently.</para>

        <example id="example-custom-string-bridge">
          <title>Custom <classname>StringBridge</classname>
          implementation</title>

          <programlisting language="JAVA" role="JAVA">/**
 * Padding Integer bridge.
 * All numbers will be padded with 0 to match 5 digits
 *
 * @author Emmanuel Bernard
 */
public class PaddedIntegerBridge implements <emphasis role="bold">StringBridge</emphasis> {

    private int padding = 5;

    <emphasis role="bold">public String objectToString(Object object)</emphasis> {
        String rawInteger = ((Integer) object).toString();
        if (rawInteger.length() &gt; padding)
            throw new IllegalArgumentException("Number too big to be padded");
        StringBuilder paddedInteger = new StringBuilder();
        for (int padIndex = rawInteger.length(); padIndex &lt; padding; padIndex++) {
            paddedInteger.append('0');
        }
        return paddedInteger.append( rawInteger ).toString();
    }
}                </programlisting>
        </example>

        <para>Given the string bridge defined in <xref
        linkend="example-custom-string-bridge"/>, any property or field can
        use this bridge thanks to the <literal>@FieldBridge</literal>
        annotation:</para>

        <programlisting language="JAVA" role="JAVA"><emphasis role="bold">@FieldBridge(impl = PaddedIntegerBridge.class)</emphasis>
private Integer length;                </programlisting>

        <section>
          <title>Parameterized bridge</title>

          <para>Parameters can also be passed to the bridge implementation
          making it more flexible. <xref
          linkend="example-passing-bridge-paremters"/> implements a
          <classname>ParameterizedBridge</classname> interface and parameters
          are passed through the <literal>@FieldBridge</literal>
          annotation.</para>

          <example id="example-passing-bridge-paremters">
            <title>Passing parameters to your bridge implementation</title>

            <programlisting language="JAVA" role="JAVA">public class PaddedIntegerBridge implements StringBridge, <emphasis
                role="bold">ParameterizedBridge</emphasis> {

    public static String PADDING_PROPERTY = "padding";
    private int padding = 5; //default

    <emphasis role="bold">public void setParameterValues(Map&lt;String,String&gt; parameters)</emphasis> {
        String padding = parameters.get( PADDING_PROPERTY );
        if (padding != null) this.padding = Integer.parseInt( padding );
    }

    public String objectToString(Object object) {
        String rawInteger = ((Integer) object).toString();
        if (rawInteger.length() &gt; padding) 
            throw new IllegalArgumentException("Number too big to be padded");
        StringBuilder paddedInteger = new StringBuilder( );
        for (int padIndex = rawInteger.length(); padIndex &lt; padding; padIndex++) {
            paddedInteger.append('0');
        }
        return paddedInteger.append(rawInteger).toString();
    }
}

//on the property:
@FieldBridge(impl = PaddedIntegerBridge.class,
             <emphasis role="bold">params = @Parameter(name="padding", value="10")</emphasis>
            )
private Integer length;                </programlisting>
          </example>

          <para>The <classname>ParameterizedBridge</classname> interface can
          be implemented by <classname>StringBridge</classname>,
          <classname>TwoWayStringBridge</classname>,
          <classname>FieldBridge</classname> implementations.</para>

          <para>All implementations have to be thread-safe, but the parameters
          are set during initialization and no special care is required at
          this stage.</para>
        </section>

        <section>
          <title>Type aware bridge</title>

          <para>It is sometimes useful to get the type the bridge is applied
          on:</para>

          <itemizedlist>
            <listitem>
              <para>the return type of the property for field/getter-level
              bridges</para>
            </listitem>

            <listitem>
              <para>the class type for class-level bridges</para>
            </listitem>
          </itemizedlist>

          <para>An example is a bridge that deals with enums in a custom
          fashion but needs to access the actual enum type. Any bridge
          implementing <classname>AppliedOnTypeAwareBridge</classname> will
          get the type the bridge is applied on injected. Like parameters, the
          type injected needs no particular care with regard to
          thread-safety.</para>
        </section>

        <section>
          <title>Two-way bridge</title>

          <para>If you expect to use your bridge implementation on an id
          property (ie annotated with <literal>@DocumentId</literal> ), you
          need to use a slightly extended version of
          <literal>StringBridge</literal> named
          <classname>TwoWayStringBridge</classname>. Hibernate Search needs to
          read the string representation of the identifier and generate the
          object out of it. There is no difference in the way the
          <literal>@FieldBridge</literal> annotation is used.</para>

          <example>
            <title>Implementing a TwoWayStringBridge usable for id
            properties</title>

            <programlisting language="JAVA" role="JAVA">public class PaddedIntegerBridge implements TwoWayStringBridge, ParameterizedBridge {

    public static String PADDING_PROPERTY = "padding";
    private int padding = 5; //default

    public void setParameterValues(Map parameters) {
        Object padding = parameters.get(PADDING_PROPERTY);
        if (padding != null) this.padding = (Integer) padding;
    }

    public String objectToString(Object object) {
        String rawInteger = ((Integer) object).toString();
        if (rawInteger.length() &gt; padding) 
            throw new IllegalArgumentException("Number too big to be padded");
        StringBuilder paddedInteger = new StringBuilder();
        for (int padIndex = rawInteger.length(); padIndex &lt; padding ; padIndex++) {
            paddedInteger.append('0');
        }
        return paddedInteger.append(rawInteger).toString();
    }

    <emphasis role="bold">public Object stringToObject(String stringValue)</emphasis> {
        return new Integer(stringValue);
    }
}

//On an id property:
@DocumentId
@FieldBridge(impl = PaddedIntegerBridge.class,
             params = @Parameter(name="padding", value="10") 
private Integer id;
                </programlisting>
          </example>

          <important>
            <para>It is important for the two-way process to be idempotent (ie
            object = stringToObject( objectToString( object ) ) ).</para>
          </important>
        </section>
      </section>

      <section>
        <title>FieldBridge</title>

        <para>Some use cases require more than a simple object to string
        translation when mapping a property to a Lucene index. To give you the
        greatest possible flexibility you can also implement a bridge as a
        <classname>FieldBridge</classname>. This interface gives you a
        property value and let you map it the way you want in your Lucene
        <classname>Document</classname>. You can for example store a property
        in two different document fields. The interface is very similar in its
        concept to the Hibernate <classname>UserType</classname>s.</para>

        <example id="example-field-bridge">
          <title>Implementing the FieldBridge interface</title>

          <programlisting language="JAVA" role="JAVA">/**
 * Store the date in 3 different fields - year, month, day - to ease Range Query per
 * year, month or day (eg get all the elements of December for the last 5 years).
 * @author Emmanuel Bernard
 */
public class DateSplitBridge implements FieldBridge {
    private final static TimeZone GMT = TimeZone.getTimeZone("GMT");

    <emphasis role="bold">public void set(String name, Object value, Document document, 
                    LuceneOptions luceneOptions)</emphasis> {
        Date date = (Date) value;
        Calendar cal = GregorianCalendar.getInstance(GMT);
        cal.setTime(date);
        int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH) + 1;
        int day = cal.get(Calendar.DAY_OF_MONTH);
  
        // set year
        luceneOptions.addFieldToDocument(
            name + ".year",
            String.valueOf( year ),
            document );
  
        // set month and pad it if needed
        luceneOptions.addFieldToDocument(
            name + ".month",
            month &lt; 10 ? "0" : "" + String.valueOf( month ),
            document );
  
        // set day and pad it if needed
        luceneOptions.addFieldToDocument(
            name + ".day",
            day &lt; 10 ? "0" : "" + String.valueOf( day ),
            document );
    }
}

//property
<emphasis role="bold">@FieldBridge(impl = DateSplitBridge.class)</emphasis>
private Date date;                </programlisting>
        </example>

        <para>In <xref linkend="example-field-bridge"/> the fields are not
        added directly to Document. Instead the addition is delegated to the
        <classname>LuceneOptions</classname> helper; this helper will apply
        the options you have selected on <literal>@Field</literal>, like
        <literal>Store</literal> or <literal>TermVector</literal>, or apply
        the choosen <classname>@Boost</classname> value. It is especially
        useful to encapsulate the complexity of <literal>COMPRESS</literal>
        implementations. Even though it is recommended to delegate to
        <classname>LuceneOptions</classname> to add fields to the
        <classname>Document</classname>, nothing stops you from editing the
        <classname>Document</classname> directly and ignore the
        <classname>LuceneOptions</classname> in case you need to.</para>

        <tip>
          <para>Classes like <classname>LuceneOptions</classname> are created
          to shield your application from changes in Lucene API and simplify
          your code. Use them if you can, but if you need more flexibility
          you're not required to.</para>
        </tip>
      </section>

      <section>
        <title>ClassBridge</title>

        <para>It is sometimes useful to combine more than one property of a
        given entity and index this combination in a specific way into the
        Lucene index. The <classname>@ClassBridge</classname> respectively
        <classname>@ClassBridges</classname> annotations can be defined at
        class level (as opposed to the property level). In this case the
        custom field bridge implementation receives the entity instance as the
        value parameter instead of a particular property. Though not shown in
        <xref linkend="example-class-bridge"/>,
        <classname>@ClassBridge</classname> supports the
        <methodname>termVector</methodname> attribute discussed in section
        <xref linkend="basic-mapping"/>.</para>

        <example id="example-class-bridge">
          <title>Implementing a class bridge</title>

          <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
<emphasis role="bold">@ClassBridge</emphasis>(name="branchnetwork",
             store=Store.YES,
             impl = <emphasis role="bold">CatFieldsClassBridge.class</emphasis>,
             params = @Parameter( name="sepChar", value=" " ) )
public class Department {
    private int id;
    private String network;
    private String branchHead;
    private String branch;
    private Integer maxEmployees
    ...
}

public class CatFieldsClassBridge implements FieldBridge, ParameterizedBridge {
    private String sepChar;

    public void setParameterValues(Map parameters) {
        this.sepChar = (String) parameters.get( "sepChar" );
    }

    <emphasis role="bold">public void set(
        String name, Object value, Document document, LuceneOptions luceneOptions)</emphasis> {
        // In this particular class the name of the new field was passed
        // from the name field of the ClassBridge Annotation. This is not
        // a requirement. It just works that way in this instance. The
        // actual name could be supplied by hard coding it below.
        Department dep = (Department) value;
        String fieldValue1 = dep.getBranch();
        if ( fieldValue1 == null ) {
            fieldValue1 = "";
        }
        String fieldValue2 = dep.getNetwork();
        if ( fieldValue2 == null ) {
            fieldValue2 = "";
        }
        String fieldValue = fieldValue1 + sepChar + fieldValue2;
        Field field = new Field( name, fieldValue, luceneOptions.getStore(),
            luceneOptions.getIndex(), luceneOptions.getTermVector() );
        field.setBoost( luceneOptions.getBoost() );
        document.add( field );
   }
}</programlisting>
        </example>

        <para>In this example, the particular
        <classname>CatFieldsClassBridge</classname> is applied to the
        <literal>department</literal> instance, the field bridge then
        concatenate both branch and network and index the
        concatenation.</para>
      </section>
    </section>
  </section>

  <section id="search-mapping-indexinginterceptor">
    <title>Conditional indexing: to index or not based on entity state</title>

    <important>
      <para>This feature is considered experimental. More operation types
      might be added in the future depending on user feedback.</para>
    </important>

    <para>In some situations, you want to index an entity only when it is in a
    given state, for example:</para>

    <itemizedlist>
      <listitem>
        <para>only index blog entries marked as published</para>
      </listitem>

      <listitem>
        <para>no longer index invoices when they are marked archived</para>
      </listitem>
    </itemizedlist>

    <para>This serves both functional and technical needs. You don't want your
    blog readers to find your draft entries and filtering them off the query
    is a bit annoying. Very few of your entities are actually required to be
    indexed and you want to limit indexing overhead and keep indexes small and
    fast.</para>

    <para>Hibernate Search lets you intercept entity indexing operations and
    override them. It is quite simple:</para>

    <itemizedlist>
      <listitem>
        <para>Write an <classname>EntityIndexingInterceptor</classname> class
        with your entity state based logic</para>
      </listitem>

      <listitem>
        <para>Mark the entity as intercepted by this implementation</para>
      </listitem>
    </itemizedlist>

    <para>Let's look at the blog example at <xref
    linkend="example-search-mapping-indexinginterceptor-blog"/></para>

    <example id="example-search-mapping-indexinginterceptor-blog">
      <title>Index blog entries only when they are published and remove them
      when they are in a different state</title>

      <programlisting language="JAVA" role="JAVA">/**
 * Only index blog when it is in published state
 *
 * @author Emmanuel Bernard &lt;emmanuel@hibernate.org&gt;
 */
public class IndexWhenPublishedInterceptor implements EntityIndexingInterceptor&lt;Blog&gt; {
    @Override
    public IndexingOverride onAdd(Blog entity) {
        if (entity.getStatus() == BlogStatus.PUBLISHED) {
            return IndexingOverride.APPLY_DEFAULT;
        }
        return IndexingOverride.SKIP;
    }

    @Override
    public IndexingOverride onUpdate(Blog entity) {
        if (entity.getStatus() == BlogStatus.PUBLISHED) {
            return IndexingOverride.UPDATE;
        }
        return IndexingOverride.REMOVE;
    }

    @Override
    public IndexingOverride onDelete(Blog entity) {
        return IndexingOverride.APPLY_DEFAULT;
    }

    @Override
    public IndexingOverride onCollectionUpdate(Blog entity) {
        return onUpdate(entity);
    }
}</programlisting>

      <programlisting language="JAVA" role="JAVA">@Entity
@Indexed(interceptor=IndexWhenPublishedInterceptor.class)
public class Blog {
    @Id
    @GeneratedValue
    public Integer getId() { return id; }
    public void setId(Integer id) {  this.id = id; }
    private Integer id;

    @Field
    public String getTitle() { return title; }
    public void setTitle(String title) {  this.title = title; }
    private String title;

    public BlogStatus getStatus() { return status; }
    public void setStatus(BlogStatus status) {  this.status = status; }
    private BlogStatus status;

    [...]
}</programlisting>
    </example>

    <para>We mark the <classname>Blog</classname> entity with
    <methodname>@Indexed.interceptor</methodname>. As you can see,
    <classname>IndexWhenPublishedInterceptor</classname> implements
    <classname>EntityIndexingInterceptor</classname> and accepts
    <classname>Blog</classname> entities (it could have accepted superclasses
    as well - for example <classname>Object</classname> if you create a
    generic interceptor.</para>

    <para>You can react to several planned indexing events:</para>

    <itemizedlist>
      <listitem>
        <para>when an entity is added to your datastore</para>
      </listitem>

      <listitem>
        <para>when an entity is updated in your datastore</para>
      </listitem>

      <listitem>
        <para>when an entity is deleted from your datastore</para>
      </listitem>

      <listitem>
        <para>when a collection own by this entity is updated in your
        datastore</para>
      </listitem>
    </itemizedlist>

    <para>For each occurring event you can respond with one of the following
    actions:</para>

    <itemizedlist>
      <listitem>
        <para><literal>APPLY_DEFAULT</literal>: that's the basic operation
        that lets Hibernate Search update the index as expected - creating,
        updating or removing the document</para>
      </listitem>

      <listitem>
        <para><literal>SKIP</literal>: ask Hibernate Search to not do anything
        to the index for this event - data will not be created, updated or
        removed from the index in any way</para>
      </listitem>

      <listitem>
        <para><literal>REMOVE</literal>: ask Hibernate Search to remove
        indexing data about this entity - you can safely ask for
        <literal>REMOVE</literal> even if the entity has not yet been
        indexed</para>
      </listitem>

      <listitem>
        <para><literal>UPDATE</literal>: ask Hibernate Search to either index
        or update the index for this entity - it is safe to ask for
        <literal>UPDATE</literal> even if the entity has never been
        indexed</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Be careful, not every combination makes sense: for example, asking
      to <literal>UPDATE</literal> the index upon
      <methodname>onDelete</methodname>. Note that you could ask for
      <literal>SKIP</literal> in this situation if saving indexing time is
      critical for you. That's rarely the case though.</para>
    </note>

    <para>By default, no interceptor is applied on an entity. You have to
    explicitly define an interceptor via the <classname>@Indexed</classname>
    annotation (see <xref linkend="indexed-annotation"/>) or programmatically
    (see <xref linkend="hsearch-mapping-programmaticapi"/>). This class and
    all its subclasses will then be intercepted. You can stop or change the
    interceptor used in a subclass by overriding
    <methodname>@Indexed.interceptor</methodname>. Hibernate Search provides
    <classname>DontInterceptEntityInterceptor</classname> which will
    explicitly not intercept any call. This is useful to reset interception
    within a class hierarchy.</para>

    <note>
      <para>Dirty checking optimization is disabled when interceptors are
      used. Dirty checking optimization does check what has changed in an
      entity and only triggers an index update if indexed properties are
      changed. The reason is simple, your interceptor might depend on a non
      indexed property which would be ignored by this optimization.</para>
    </note>

    <warning>
      <para>An <classname>EntityIndexingInterceptor</classname> can never
      override an explicit indexing operation such as
      <methodname>index(T)</methodname>, <methodname>purge(T, id)</methodname>
      or <methodname>purgeAll(class)</methodname>.</para>
    </warning>
  </section>

  <section id="provided-id">
    <title>Providing your own id</title>

    <para>You can provide your own id for Hibernate Search if you are
    extending the internals. You will have to generate a unique value so it
    can be given to Lucene to be indexed. This will have to be given to
    Hibernate Search when you create an org.hibernate.search.Work object - the
    document id is required in the constructor.</para>

    <section id="ProvidedId">
      <title>The ProvidedId annotation</title>

      <para>Unlike <classname>@DocumentId</classname>which is applied on field
      level, <classname>@ProvidedId</classname> is used on the class level.
      Optionally you can specify your own bridge implementation using the
      <constant>bridge</constant> property. Also, if you annotate a class with
      <classname>@ProvidedId</classname>, your subclasses will also get the
      annotation - but it is not done by using the
      java.lang.annotations.@Inherited. Be sure however, to
      <emphasis>not</emphasis> use this annotation with @DocumentId as your
      system will break.</para>

      <example>
        <title>Providing your own id</title>

        <programlisting language="JAVA" role="JAVA">@ProvidedId(bridge = org.my.own.package.MyCustomBridge)
@Indexed
public class MyClass{
    @Field
    String MyString;
    ...
}</programlisting>
      </example>
    </section>
  </section>

  <section id="hsearch-mapping-programmaticapi">
    <title>Programmatic API</title>

    <para>Although the recommended approach for mapping indexed entities is to
    use annotations, it is sometimes more convenient to use a different
    approach:</para>

    <itemizedlist>
      <listitem>
        <para>the same entity is mapped differently depending on deployment
        needs (customization for clients)</para>
      </listitem>

      <listitem>
        <para>some automatization process requires the dynamic mapping of many
        entities sharing common traits</para>
      </listitem>
    </itemizedlist>

    <para>While it has been a popular demand in the past, the Hibernate team
    never found the idea of an XML alternative to annotations appealing due to
    it's heavy duplication, lack of code refactoring safety, because it did
    not cover all the use case spectrum and because we are in the 21st century
    :)</para>

    <para>The idea of a programmatic API was much more appealing and has now
    become a reality. You can programmatically define your mapping using a
    programmatic API: you define entities and fields as indexable by using
    mapping classes which effectively mirror the annotation concepts in
    Hibernate Search. Note that fan(s) of XML approach can design their own
    schema and use the programmatic API to create the mapping while parsing
    the XML stream.</para>

    <para>In order to use the programmatic model you must first construct a
    <classname>SearchMapping</classname> object which you can do in two
    ways:</para>

    <itemizedlist>
      <listitem>
        <para>directly</para>
      </listitem>

      <listitem>
        <para>via a factory</para>
      </listitem>
    </itemizedlist>

    <para>You can pass the <classname>SearchMapping</classname> object
    directly via the property key
    <literal>hibernate.search.model_mapping</literal> or the constant
    <classname>Environment.MODEL_MAPPING</classname>. Use the
    <classname>Configuration</classname> API or the Map passed to the JPA
    <classname>Persistence</classname> bootstrap methods.</para>

    <example>
      <title>Programmatic mapping</title>

      <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();
[...] //configure mapping
Configuration config = new Configuration();
config.getProperties().put( Environment.MODEL_MAPPING, mapping );
SessionFactory sf = config.buildSessionFactory();</programlisting>
    </example>

    <example>
      <title>Programmatic mapping with JPA</title>

      <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();
[...] //configure mapping
Map props = new HashMap();
props.put( Environment.MODEL_MAPPING, mapping );
EntityManagerFactory emf = Persistence.createEntityManagerFactory( "userPU", props );</programlisting>
    </example>

    <para>Alternatively, you can create a factory class (ie. hosting a method
    annotated with <classname>@Factory</classname>) whose factory method
    returns the <classname>SearchMapping</classname> object. The factory class
    must have a no-arg constructor and its fully qualified class name is
    passed to the property key
    <literal>hibernate.search.model_mapping</literal> or its type-safe
    representation <classname>Environment.MODEL_MAPPING</classname>. This
    approach is useful when you do not necessarily control the bootstrap
    process like in a Java EE, CDI or Spring Framework container.</para>

    <example>
      <title>Use a mapping factory</title>

      <programlisting language="JAVA" role="JAVA">public class MyAppSearchMappingFactory {
    @Factory
    public SearchMapping getSearchMapping() {
        SearchMapping mapping = new SearchMapping();
        mapping
                .analyzerDef( "ngram", StandardTokenizerFactory.class )
                    .filter( LowerCaseFilterFactory.class )
                    .filter( NGramFilterFactory.class )
                        .param( "minGramSize", "3" )
                        .param( "maxGramSize", "3" );
        return mapping;
    }
}</programlisting>

      <programlisting language="XML" role="XML">&lt;persistence ...&gt;
    &lt;persistence-unit name="users"&gt;
        ...
        &lt;properties&gt;
            &lt;property name="hibernate.search.model_mapping"
                      value="com.acme.MyAppSearchMappingFactory"/&gt;
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;</programlisting>
    </example>

    <para>The <classname>SearchMapping</classname> is the root object which
    contains all the necessary indexable entities and fields. From there, the
    <classname>SearchMapping</classname> object exposes a fluent (and thus
    intuitive) API to express your mappings: it contextually exposes the
    relevant mapping options in a type-safe way. Just let your IDE
    autocompletion feature guide you through.</para>

    <para>Today, the programmatic API cannot be used on a class annotated with
    Hibernate Search annotations, chose one approach or the other. Also note
    that the same default values apply in annotations and the programmatic
    API. For example, the <methodname>@Field.name</methodname> is defaulted to
    the property name and does not have to be set.</para>

    <para>Each core concept of the programmatic API has a corresponding
    example to depict how the same definition would look using annotation.
    Therefore seeing an annotation example of the programmatic approach should
    give you a clear picture of what Hibernate Search will build with the
    marked entities and associated properties.</para>

    <section>
      <title>Mapping an entity as indexable</title>

      <para>The first concept of the programmatic API is to define an entity
      as indexable. Using the annotation approach a user would mark the entity
      as <classname>@Indexed</classname>, the following example demonstrates
      how to programmatically achieve this.</para>

      <example>
        <title>Marking an entity indexable</title>

        <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();

mapping.entity(Address.class)
           .indexed()
               .indexName("Address_Index") //optional
               .interceptor(IndexWhenPublishedInterceptor.class); //optional

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</programlisting>
      </example>

      <para>As you can see you must first create a
      <classname>SearchMapping</classname> object which is the root object
      that is then passed to the <classname>Configuration</classname> object
      as property. You must declare an entity and if you wish to make that
      entity as indexable then you must call the
      <methodname>indexed()</methodname> method. The <methodname>indexed()
      </methodname>method has an optional <methodname>indexName(String
      indexName)</methodname> which can be used to change the default index
      name that is created by Hibernate Search. Likewise, an
      <methodname>interceptor(Class&lt;? extends
      EntityIndexedInterceptor&gt;)</methodname> is available. Using the
      annotation model the above can be achieved as:</para>

      <example>
        <title>Annotation example of indexing entity</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed(index="Address_Index", interceptor=IndexWhenPublishedInterceptor.class)
public class Address {
....
}</programlisting>
      </example>
    </section>

    <section>
      <title>Adding DocumentId to indexed entity</title>

      <para>To set a property as a document id:</para>

      <example>
        <title>Enabling document id with programmatic model</title>

        <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();

mapping.entity(Address.class).indexed()
           .property("addressId", ElementType.FIELD) //field access
               .documentId()
                   .name("id");

cfg.getProperties().put( "hibernate.search.model_mapping", mapping);</programlisting>
      </example>

      <para>The above is equivalent to annotating a property in the entity as
      <classname>@DocumentId</classname> as seen in the following
      example:</para>

      <example>
        <title>DocumentId annotation definition</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public class Address {
 @Id
 @GeneratedValue
 @DocumentId(name="id")
 private Long addressId;

 ....
}</programlisting>

        <para>The next section demonstrates how to programmatically define
        analyzers.</para>
      </example>
    </section>

    <section>
      <title>Defining analyzers</title>

      <para>Analyzers can be programmatically defined using the
      <methodname>analyzerDef(String analyzerDef, Class&lt;? extends
      TokenizerFactory&gt; tokenizerFactory) </methodname>method. This method
      also enables you to define filters for the analyzer definition. Each
      filter that you define can optionally take in parameters as seen in the
      following example :</para>

      <example>
        <title>Defining analyzers using programmatic model</title>

        <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    <emphasis role="bold">.analyzerDef( "ngram", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( NGramFilterFactory.class )
            .param( "minGramSize", "3" )
            .param( "maxGramSize", "3" )
    .analyzerDef( "en", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( EnglishPorterFilterFactory.class )
    .analyzerDef( "de", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( GermanStemFilterFactory.class )</emphasis>
    .entity(Address.class).indexed()
        .property("addressId", ElementType.METHOD) //getter access
            .documentId()
                .name("id");

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</programlisting>
      </example>

      <para>The analyzer mapping defined above is equivalent to the annotation
      model using <classname>@AnalyzerDef</classname> in conjunction with
      <classname>@AnalyzerDefs</classname>:</para>

      <example>
        <title>Analyzer definition using annotation</title>

        <programlisting language="JAVA" role="JAVA">@Indexed
@Entity
@AnalyzerDefs({
  @AnalyzerDef(name = "ngram",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = NGramFilterFactory.class, 
        params = {
          @Parameter(name = "minGramSize",value = "3"),
          @Parameter(name = "maxGramSize",value = "3") 
       })
   }),
  @AnalyzerDef(name = "en",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = EnglishPorterFilterFactory.class)
   }),

  @AnalyzerDef(name = "de",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = GermanStemFilterFactory.class)
  })

})
public class Address {
...
}</programlisting>
      </example>
    </section>

    <section>
      <title>Defining full text filter definitions</title>

      <para>The programmatic API provides easy mechanism for defining full
      text filter definitions which is available via
      <classname>@FullTextFilterDef</classname> and
      <classname>@FullTextFilterDefs</classname> (see <xref
      linkend="query-filter"/>). The next example depicts the creation of full
      text filter definition using the <methodname>fullTextFilterDef
      </methodname>method.</para>

      <example>
        <title>Defining full text definition programmatically</title>

        <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .analyzerDef( "en", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( EnglishPorterFilterFactory.class )
    <emphasis role="bold">.fullTextFilterDef("security", SecurityFilterFactory.class)
            .cache(FilterCacheModeType.INSTANCE_ONLY)</emphasis>
    .entity(Address.class)
        .indexed()
        .property("addressId", ElementType.METHOD)
            .documentId()
                .name("id")
        .property("street1", ElementType.METHOD)
            .field()
                .analyzer("en")
                .store(Store.YES)
            .field()
                .name("address_data")
                .analyzer("en")
                .store(Store.NO);

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</programlisting>
      </example>

      <para>The previous example can effectively been seen as annotating your
      entity with <classname>@FullTextFilterDef</classname> like below:</para>

      <example>
        <title>Using annotation to define full text filter definition</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
@AnalyzerDefs({
  @AnalyzerDef(name = "en",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = EnglishPorterFilterFactory.class)
   })
})
@FullTextFilterDefs({
 @FullTextFilterDef(name = "security", impl = SecurityFilterFactory.class, cache = FilterCacheModeType.INSTANCE_ONLY)
})
public class Address {
 
 @Id
 @GeneratedValue
 @DocumentId(name="id")
 pubblic Long getAddressId() {...};

 @Fields({
      @Field(store=Store.YES, analyzer=@Analyzer(definition="en")),
      @Field(name="address_data", analyzer=@Analyzer(definition="en"))
 })
 public String getAddress1() {...};

 ......
 
}</programlisting>
      </example>
    </section>

    <section>
      <title>Defining fields for indexing</title>

      <para>When defining fields for indexing using the programmatic API, call
      <methodname>field()</methodname> on the <methodname>property(String
      propertyName, ElementType elementType)</methodname> method. From
      <methodname>field()</methodname> you can specify the <methodname>name,
      index</methodname>, <methodname>store</methodname>,
      <methodname>bridge</methodname> and <methodname>analyzer</methodname>
      definitions.</para>

      <example>
        <title>Indexing fields using programmatic API</title>

        <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .analyzerDef( "en", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( EnglishPorterFilterFactory.class )
    .entity(Address.class).indexed()
        .property("addressId", ElementType.METHOD)
            .documentId()
                .name("id")
        .property("street1", ElementType.METHOD)
            <emphasis role="bold">.field()
                .analyzer("en")
                .store(Store.YES)
            .field()
                .name("address_data")
                .analyzer("en");</emphasis>

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</programlisting>
      </example>

      <para>The above example of marking fields as indexable is equivalent to
      defining fields using <classname>@Field</classname> as seen
      below:</para>

      <example>
        <title>Indexing fields using annotation</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
@AnalyzerDefs({
  @AnalyzerDef(name = "en",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = EnglishPorterFilterFactory.class)
   })
})
public class Address {
 
 @Id
 @GeneratedValue
 @DocumentId(name="id")
 private Long getAddressId() {...};

 @Fields({
      @Field(store=Store.YES, analyzer=@Analyzer(definition="en")),
      @Field(name="address_data", analyzer=@Analyzer(definition="en"))
 })
 public String getAddress1() {...}

 ......
}</programlisting>
      </example>

      <note>
        <para>When using a programmatic mapping for a given type X, you can
        only refer to fields defined on X. Fields or methods inherited from a
        super type are not configurable. In case you need to configure a super
        class property, you need to either override the property in X or
        create a programmatic mapping for the super class. This mimics the
        usage of annotations where you cannot annotate a field or method of a
        super class either, unless it is redefined in the given type.</para>
      </note>
    </section>

    <section>
      <title>Programmatically defining embedded entities</title>

      <para>In this section you will see how to programmatically define
      entities to be embedded into the indexed entity similar to using the
      <classname>@IndexedEmbedded</classname> model. In order to define this
      you must mark the property as
      <methodname>indexEmbedded.</methodname>There is the option to add a
      prefix to the embedded entity definition which can be done by calling
      <methodname>prefix</methodname> as seen in the example below:</para>

      <example>
        <title>Programmatically defining embedded entites</title>

        <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .entity(ProductCatalog.class)
        .indexed()
        .property("catalogId", ElementType.METHOD)
            .documentId()
                .name("id")
        .property("title", ElementType.METHOD)
            .field()
                .index(Index.YES)
                .store(Store.NO)
        .property("description", ElementType.METHOD)
             .field()
                 .index(Index.YES)
                 .store(Store.NO)
        .property("items", ElementType.METHOD)
            <emphasis role="bold">.indexEmbedded()
                .prefix("catalog.items"); //optional</emphasis>

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</programlisting>
      </example>

      <para>The next example shows the same definition using annotation
      (<classname>@IndexedEmbedded</classname>):</para>

      <example>
        <title>Using @IndexedEmbedded</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public class ProductCatalog {
 @Id
 @GeneratedValue
 @DocumentId(name="id")
 public Long getCatalogId() {...}
 
 @Field
 public String getTitle() {...}

 @Field
 public String getDescription();
 
 @OneToMany(fetch = FetchType.LAZY)
 @IndexColumn(name = "list_position")
 @Cascade(org.hibernate.annotations.CascadeType.ALL)
 @IndexedEmbedded(prefix="catalog.items")
 public List&lt;Item&gt; getItems() {...}

 ...

}</programlisting>
      </example>
    </section>

    <section>
      <title>Contained In definition</title>

      <para><classname>@ContainedIn</classname> can be define as seen in the
      example below:</para>

      <example>
        <title>Programmatically defining ContainedIn</title>

        <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .entity(ProductCatalog.class)
        .indexed()
        .property("catalogId", ElementType.METHOD)
            .documentId()
        .property("title", ElementType.METHOD)
            .field()
        .property("description", ElementType.METHOD)
            .field()
        .property("items", ElementType.METHOD)
            .indexEmbedded()

    .entity(Item.class)
        .property("description", ElementType.METHOD)
            .field()
        .property("productCatalog", ElementType.METHOD)
            <emphasis role="bold">.containedIn()</emphasis>;

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</programlisting>
      </example>

      <para>This is equivalent to defining <classname>@ContainedIn</classname>
      in your entity:</para>

      <example>
        <title>Annotation approach for ContainedIn</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public class ProductCatalog {
 
 @Id
 @GeneratedValue
 @DocumentId
 public Long getCatalogId() {...}
 
 @Field
 public String getTitle() {...}

 @Field
 public String getDescription() {...}
 
 @OneToMany(fetch = FetchType.LAZY)
 @IndexColumn(name = "list_position")
 @Cascade(org.hibernate.annotations.CascadeType.ALL)
 @IndexedEmbedded
 private List&lt;Item&gt; getItems() {...}

 ...
}

@Entity
public class Item {
 
 @Id
 @GeneratedValue
 private Long itemId;

 @Field
 public String getDescription() {...}
 
 @ManyToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )
 @ContainedIn
 public ProductCatalog getProductCatalog() {...}

 ...
}</programlisting>
      </example>
    </section>

    <section>
      <title>Date/Calendar Bridge</title>

      <para>In order to define a calendar or date bridge mapping, call the
      <methodname>dateBridge(Resolution resolution) </methodname>or
      <methodname>calendarBridge(Resolution resolution)</methodname> methods
      after you have defined a <methodname>field()</methodname> in the
      <classname>SearchMapping </classname>hierarchy.</para>

      <example>
        <title>Programmatic model for defining calendar/date bridge</title>

        <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .entity(Address.class)
        .indexed()
        .property("addressId", ElementType.FIELD)
            .documentId()
    .property("street1", ElementType.FIELD()
        .field()
    .property("createdOn", ElementType.FIELD)
        .field()
        <emphasis role="bold">.dateBridge(Resolution.DAY)</emphasis>
    .property("lastUpdated", ElementType.FIELD)
        <emphasis role="bold">.calendarBridge(Resolution.DAY)</emphasis>;

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</programlisting>
      </example>

      <para>See below for defining the above using
      <classname>@CalendarBridge</classname> and
      <classname>@DateBridge</classname>:</para>

      <example>
        <title>@CalendarBridge and @DateBridge definition</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public class Address {
 
 @Id
 @GeneratedValue
 @DocumentId
 private Long addressId;

 @Field
 private String address1;

 @Field
 @DateBridge(resolution=Resolution.DAY)
 private Date createdOn;

 @CalendarBridge(resolution=Resolution.DAY)
 private Calendar lastUpdated;

 ...
}</programlisting>
      </example>
    </section>

    <section>
      <title>Defining bridges</title>

      <para>It is possible to associate bridges to programmatically defined
      fields. When you define a <methodname>field()</methodname>
      programmatically you can use the <methodname>bridge(Class&lt;?&gt;
      impl)</methodname> to associate a <classname>FieldBridge
      </classname>implementation class. The bridge method also provides
      optional methods to include any parameters required for the bridge
      class. The below shows an example of programmatically defining a
      bridge:</para>

      <example>
        <title>Defining field bridges programmatically</title>

        <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .entity(Address.class)
        .indexed()
        .property("addressId", ElementType.FIELD)
            .documentId()
        .property("street1", ElementType.FIELD)
            .field()
            .field()
                .name("street1_abridged")
                <emphasis role="bold">.bridge( ConcatStringBridge.class )
                    .param( "size", "4" )</emphasis>;
 
cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</programlisting>
      </example>

      <para>The above can equally be defined using annotations, as seen in the
      next example.</para>

      <example>
        <title>Defining field bridges using annotation</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public class Address {
 
 @Id
 @GeneratedValue
 @DocumentId(name="id")
 private Long addressId;

 @Fields({
      @Field,
      @Field(name="street1_abridged", 
             bridge = @FieldBridge( impl = ConcatStringBridge.class, 
             params = @Parameter( name="size", value="4" ))
 })
 private String address1;

 ...
}</programlisting>
      </example>
    </section>

    <section>
      <title>Mapping class bridge</title>

      <para>You can define class bridges on entities programmatically. This is
      shown in the next example:</para>

      <example>
        <title>Defining class briges using API</title>

        <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .entity(Departments.class)
<emphasis>       .classBridge(CatDeptsFieldsClassBridge.class)
         .name("branchnetwork")
         .index(Index.YES)
         .store(Store.YES)
         .param("sepChar", " ")
      .classBridge(EquipmentType.class)
         .name("equiptype")
         .index(Index.YES)
         .store(Store.YES)
         .param("C", "Cisco")
         .param("D", "D-Link")
         .param("K", "Kingston")
         .param("3", "3Com")</emphasis>
      .indexed();

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );

</programlisting>
      </example>

      <para>The above is similar to using <classname>@ClassBridge
      </classname>as seen in the next example:</para>

      <example>
        <title>Using @ClassBridge</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
@ClassBridges ( {
  @ClassBridge(name="branchnetwork",
     store= Store.YES,
     impl = CatDeptsFieldsClassBridge.class,
     params = @Parameter( name="sepChar", value=" " ) ),
  @ClassBridge(name="equiptype",
     store= Store.YES,
     impl = EquipmentType.class,
     params = {@Parameter( name="C", value="Cisco" ),
        @Parameter( name="D", value="D-Link" ),
        @Parameter( name="K", value="Kingston" ),
        @Parameter( name="3", value="3Com" )
   })
})
public class Departments {

....
}</programlisting>
      </example>
    </section>

    <section>
      <title>Mapping dynamic boost</title>

      <para>You can apply a dynamic boost factor on either a field or a whole
      entity:</para>

      <example>
        <title>DynamicBoost mapping using programmatic model</title>

        <programlisting language="JAVA" role="JAVA">SearchMapping mapping = new SearchMapping();

mapping
  .entity(DynamicBoostedDescLibrary.class)
   .indexed()
   <emphasis>.dynamicBoost(CustomBoostStrategy.class)</emphasis>
  .property("libraryId", ElementType.FIELD)
    .documentId().name("id")
  .property("name", ElementType.FIELD)
    <emphasis>.dynamicBoost(CustomFieldBoostStrategy.class)</emphasis>;
    .field()
      .store(Store.YES)

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</programlisting>
      </example>

      <para>The next example shows the equivalent mapping using the
      <classname>@DynamicBoost</classname> annotation:</para>

      <example>
        <title>Using the @DynamicBoost</title>

        <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
@DynamicBoost(impl = CustomBoostStrategy.class)
public class DynamicBoostedDescriptionLibrary {

 @Id
 @GeneratedValue
 @DocumentId
 private int id;

 private float dynScore;
 
 @Field(store = Store.YES)
 @DynamicBoost(impl = CustomFieldBoostStrategy.class)
 private String name;

 public DynamicBoostedDescriptionLibrary() {
  dynScore = 1.0f;
 }
  
 .......
}</programlisting>
      </example>
    </section>
  </section>
</chapter>
