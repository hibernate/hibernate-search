<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Hibernate, Relational Persistence for Idiomatic Java
  ~
  ~  Copyright (c) 2010, Red Hat, Inc. and/or its affiliates or third-party contributors as
  ~  indicated by the @author tags or express copyright attribution
  ~  statements applied by the authors.  All third-party contributions are
  ~  distributed under license by Red Hat, Inc.
  ~
  ~  This copyrighted material is made available to anyone wishing to use, modify,
  ~  copy, or redistribute it subject to the terms and conditions of the GNU
  ~  Lesser General Public License, as published by the Free Software Foundation.
  ~
  ~  This program is distributed in the hope that it will be useful,
  ~  but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~  for more details.
  ~
  ~  You should have received a copy of the GNU Lesser General Public License
  ~  along with this distribution; if not, write to:
  ~  Free Software Foundation, Inc.
  ~  51 Franklin Street, Fifth Floor
  ~  Boston, MA  02110-1301  USA
  -->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "../hsearch.ent">
%BOOK_ENTITIES;
]>
<chapter id="search-query" xreflabel="Querying">
  <title>Querying</title>

  <para>The second most important capability of Hibernate Search is the
  ability to execute Lucene queries and retrieve entities managed by a
  Hibernate session. The search provides the power of Lucene without leaving
  the Hibernate paradigm, giving another dimension to the Hibernate classic
  search mechanisms (HQL, Criteria query, native SQL query).</para>

  <para>Preparing and executing a query consists of four simple steps:</para>

  <itemizedlist>
    <listitem>
      <para>Creating a <classname>FullTextSession</classname></para>
    </listitem>

    <listitem>
      <para>Creating a Lucene query either via the Hibernate Search query DSL
      (recommended) or by utilizing the Lucene query API</para>
    </listitem>

    <listitem>
      <para>Wrapping the Lucene query using an
      <classname>org.hibernate.Query</classname></para>
    </listitem>

    <listitem>
      <para>Executing the search by calling for example
      <methodname>list()</methodname> or
      <methodname>scroll()</methodname></para>
    </listitem>
  </itemizedlist>

  <para>To access the querying facilities, you have to use a
  <classname>FullTextSession</classname>. This Search specific session wraps a
  regular <classname>org.hibernate.Session</classname> in order to provide
  query and indexing capabilities.</para>

  <example>
    <title>Creating a FullTextSession</title>

    <programlisting language="JAVA" role="JAVA">Session session = sessionFactory.openSession();
...
FullTextSession fullTextSession = Search.getFullTextSession(session);    </programlisting>
  </example>

  <para>Once you have a <classname>FullTextSession</classname> you have two
  options to build the full-text query: the Hibernate Search query DSL or the
  native Lucene query.</para>

  <para>If you use the Hibernate Search query DSL, it will look like
  this:</para>

  <programlisting language="JAVA" role="JAVA">QueryBuilder b = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity(Myth.class).get();

org.apache.lucene.search.Query luceneQuery =
    b.keyword()
        .onField("history").boostedTo(3)
        .matching("storm")
        .createQuery();

org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery(luceneQuery);
List result = fullTextQuery.list(); //return a list of managed objects
</programlisting>

  <para>You can alternatively write your Lucene query either using the Lucene
  query parser or Lucene programmatic API.</para>

  <example>
    <title>Creating a Lucene query via the
    <classname>QueryParser</classname></title>

    <programlisting language="JAVA" role="JAVA">
SearchFactory searchFactory = fullTextSession.getSearchFactory();
org.apache.lucene.queryParser.QueryParser parser = 
    new QueryParser("title", searchFactory.getAnalyzer(Myth.class));
try {
    org.apache.lucene.search.Query luceneQuery = parser.parse("history:storm^3");
}
catch (ParseException e) {
    //handle parsing failure
}

org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery(luceneQuery);
List result = fullTextQuery.list(); //return a list of managed objects    </programlisting>
  </example>

  <note>
    <para>The Hibernate query built on top of the Lucene query is a regular
    <literal>org.hibernate.Query</literal>, which means you are in the same
    paradigm as the other Hibernate query facilities (HQL, Native or
    Criteria). The regular <literal>list()</literal> ,
    <literal>uniqueResult()</literal>, <literal>iterate()</literal> and
    <literal>scroll()</literal> methods can be used.</para>
  </note>

  <para>In case you are using the Java Persistence APIs of Hibernate, the same
  extensions exist:</para>

  <example>
    <title>Creating a Search query using the JPA API</title>

    <programlisting language="JAVA" role="JAVA">EntityManager em = entityManagerFactory.createEntityManager();

FullTextEntityManager fullTextEntityManager = 
    org.hibernate.search.jpa.Search.getFullTextEntityManager(em);

...
QueryBuilder b = fullTextEntityManager.getSearchFactory()
    .buildQueryBuilder().forEntity( Myth.class ).get();

org.apache.lucene.search.Query luceneQuery =
    b.keyword()
        .onField("history").boostedTo(3)
        .matching("storm")
        .createQuery();
<emphasis role="bold">javax.persistence.Query fullTextQuery = 
    fullTextEntityManager.createFullTextQuery( luceneQuery );</emphasis>

List result = fullTextQuery.getResultList(); //return a list of managed objects  </programlisting>
  </example>

  <note>
    <para>The following examples we will use the Hibernate APIs but the same
    example can be easily rewritten with the Java Persistence API by just
    adjusting the way the <classname>FullTextQuery</classname> is
    retrieved.</para>
  </note>

  <section id="section-building-lucene-queries">
    <title>Building queries</title>

    <para>Hibernate Search queries are built on top of Lucene queries which
    gives you total freedom on the type of Lucene query you want to execute.
    However, once built, Hibernate Search wraps further query processing using
    <classname>org.hibernate.Query</classname> as your primary query
    manipulation API.</para>

    <section id="search-query-lucene-api">
      <title>Building a Lucene query using the Lucene API</title>

      <para>Using the Lucene API, you have several options. You can use the
      query parser (fine for simple queries) or the Lucene programmatic API
      (for more complex use cases). It is out of the scope of this
      documentation on how to exactly build a Lucene query. Please refer to
      the online Lucene documentation or get hold of a copy of Lucene In
      Action or Hibernate Search in Action.</para>
    </section>

    <section id="search-query-querydsl">
      <title>Building a Lucene query with the Hibernate Search query
      DSL</title>

      <para>Writing full-text queries with the Lucene programmatic API is
      quite complex. It's even more complex to understand the code once
      written. Besides the inherent API complexity, you have to remember to
      convert your parameters to their string equivalent as well as make sure
      to apply the correct analyzer to the right field (a ngram analyzer will
      for example use several ngrams as the tokens for a given word and should
      be searched as such).</para>

      <para>The Hibernate Search query DSL makes use of a style of API called
      a fluent API. This API has a few key characteristics:</para>

      <itemizedlist>
        <listitem>
          <para>it has meaningful method names making a succession of
          operations reads almost like English</para>
        </listitem>

        <listitem>
          <para>it limits the options offered to what makes sense in a given
          context (thanks to strong typing and IDE autocompletion).</para>
        </listitem>

        <listitem>
          <para>It often uses the chaining method pattern</para>
        </listitem>

        <listitem>
          <para>it's easy to use and even easier to read</para>
        </listitem>
      </itemizedlist>

      <para>Let's see how to use the API. You first need to create a query
      builder that is attached to a given indexed entity type. This
      <classname>QueryBuilder</classname> will know what analyzer to use and
      what field bridge to apply. You can create several
      <classname>QueryBuilder</classname>s (one for each entity type involved
      in the root of your query). You get the
      <classname>QueryBuilder</classname> from the
      <classname>SearchFactory</classname>.</para>

      <programlisting language="JAVA" role="JAVA">QueryBuilder mythQB = searchFactory.buildQueryBuilder().forEntity( Myth.class ).get();</programlisting>

      <para>You can also override the analyzer used for a given field or
      fields. This is rarely needed and should be avoided unless you know what
      you are doing.</para>

      <programlisting language="JAVA" role="JAVA">QueryBuilder mythQB = searchFactory.buildQueryBuilder()
    .forEntity( Myth.class )
        .overridesForField("history","stem_analyzer_definition")
    .get();</programlisting>

      <para>Using the query builder, you can then build queries. It is
      important to realize that the end result of a
      <classname>QueryBuilder</classname> is a Lucene query. For this reason
      you can easily mix and match queries generated via Lucene's query parser
      or <classname>Query</classname> objects you have assembled with the
      Lucene programmatic API and use them with the Hibernate Search DSL. Just
      in case the DSL is missing some features.</para>

      <section>
        <title>Keyword queries</title>

        <para>Let's start with the most basic use case - searching for a
        specific word:</para>

        <programlisting language="JAVA" role="JAVA">Query luceneQuery = mythQB.keyword().onField("history").matching("storm").createQuery();</programlisting>

        <para><methodname>keyword()</methodname> means that you are trying to
        find a specific word. <methodname>onField()</methodname> specifies in
        which Lucene field to look. <methodname>matching()</methodname> tells
        what to look for. And finally <methodname>createQuery()</methodname>
        creates the Lucene query object. A lot is going on with this line of
        code.</para>

        <itemizedlist>
          <listitem>
            <para>The value storm is passed through the
            <literal>history</literal> <classname>FieldBridge</classname>: it
            does not matter here but you will see that it's quite handy when
            dealing with numbers or dates.</para>
          </listitem>

          <listitem>
            <para>The field bridge value is then passed to the analyzer used
            to index the field <literal>history</literal>. This ensures that
            the query uses the same term transformation than the indexing
            (lower case, n-gram, stemming and so on). If the analyzing process
            generates several terms for a given word, a boolean query is used
            with the <literal>SHOULD</literal> logic (roughly an
            <literal>OR</literal> logic).</para>
          </listitem>
        </itemizedlist>

        <para>Let's see how you can search a property that is not of type
        string.</para>

        <programlisting language="JAVA" role="JAVA">@Entity 
@Indexed 
public class Myth {
  @Field(analyze = Analyze.NO) 
  @DateBridge(resolution = Resolution.YEAR)
  public Date getCreationDate() { return creationDate; }
  public Date setCreationDate(Date creationDate) { this.creationDate = creationDate; }
  private Date creationDate;
  
  ...
}

Date birthdate = ...;
Query luceneQuery = mythQb.keyword().onField("creationDate").matching(birthdate).createQuery();
</programlisting>

        <note>
          <para>In plain Lucene, you would have had to convert the
          <classname>Date</classname> object to its string representation (in
          this case the year).</para>
        </note>

        <para>This conversion works for any object, not just
        <classname>Date</classname>, provided that the
        <classname>FieldBridge</classname> has an
        <methodname>objectToString</methodname> method (and all built-in
        <classname>FieldBridge</classname> implementations do).</para>

        <para>We make the example a little more advanced now and have a look
        at how to search a field that uses ngram analyzers. ngram analyzers
        index succession of ngrams of your words which helps to recover from
        user typos. For example the 3-grams of the word hibernate are hib,
        ibe, ber, rna, nat, ate.</para>

        <programlisting language="JAVA" role="JAVA">@AnalyzerDef(name = "ngram",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class ),
  filters = {
    @TokenFilterDef(factory = StandardFilterFactory.class),
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = StopFilterFactory.class),
    @TokenFilterDef(factory = NGramFilterFactory.class,
      params = { 
        @Parameter(name = "minGramSize", value = "3"),
        @Parameter(name = "maxGramSize", value = "3") } )
  }
)
@Entity 
@Indexed 
public class Myth {
  @Field(analyzer=@Analyzer(definition="ngram") 
  @DateBridge(resolution = Resolution.YEAR)
  public String getName() { return name; }
  public String setName(Date name) { this.name = name; }
  private String name;
  
  ...
}

Date birthdate = ...;
Query luceneQuery = mythQb.keyword().onField("name").matching("Sisiphus")
   .createQuery();
</programlisting>

        <para>The matching word "Sisiphus" will be lower-cased and then split
        into 3-grams: sis, isi, sip, phu, hus. Each of these n-gram will be
        part of the query. We will then be able to find the Sysiphus myth
        (with a <literal>y</literal>). All that is transparently done for
        you.</para>

        <note>
          <para>If for some reason you do not want a specific field to use the
          field bridge or the analyzer you can call the
          <methodname>ignoreAnalyzer()</methodname> or
          <methodname>ignoreFieldBridge()</methodname> functions</para>
        </note>

        <para>To search for multiple possible words in the same field, simply
        add them all in the matching clause.</para>

        <programlisting language="JAVA" role="JAVA">//search document with storm or lightning in their history
Query luceneQuery = 
    mythQB.keyword().onField("history").matching("storm lightning").createQuery();</programlisting>

        <para>To search the same word on multiple fields, use the
        <methodname>onFields</methodname> method.</para>

        <programlisting language="JAVA" role="JAVA">Query luceneQuery = mythQB
    .keyword()
    .onFields("history","description","name")
    .matching("storm")
    .createQuery();</programlisting>

        <para>Sometimes, one field should be treated differently from another
        field even if searching the same term, you can use the
        <methodname>andField()</methodname> method for that.</para>

        <programlisting language="JAVA" role="JAVA">Query luceneQuery = mythQB.keyword()
    .onField("history")
    .andField("name")
      .boostedTo(5)
    .andField("description")
    .matching("storm")
    .createQuery();</programlisting>

        <para>In the previous example, only field name is boosted to 5.</para>
      </section>

      <section>
        <title>Fuzzy queries</title>

        <para>To execute a fuzzy query (based on the Levenshtein distance
        algorithm), start like a <literal>keyword</literal> query and add the
        fuzzy flag.</para>

        <programlisting language="JAVA" role="JAVA">Query luceneQuery = mythQB
    .keyword()
      .fuzzy()
        .withThreshold(.8f)
        .withPrefixLength(1)
    .onField("history")
    .matching("starm")
    .createQuery();</programlisting>

        <para><literal>threshold</literal> is the limit above which two terms
        are considering matching. It's a decimal between 0 and 1 and defaults
        to 0.5. <literal>prefixLength</literal> is the length of the prefix
        ignored by the "fuzzyness": while it defaults to 0, a non zero value
        is recommended for indexes containing a huge amount of distinct
        terms.</para>
      </section>

      <section>
        <title>Wildcard queries</title>

        <para>You can also execute wildcard queries (queries where some of
        parts of the word are unknown). <literal>?</literal> represents a
        single character and <literal>*</literal> represents any character
        sequence. Note that for performance purposes, it is recommended that
        the query does not start with either <literal>?</literal> or
        <literal>*</literal>.</para>

        <programlisting language="JAVA" role="JAVA">Query luceneQuery = mythQB
    .keyword()
      .wildcard()
    .onField("history")
    .matching("sto*")
    .createQuery();</programlisting>

        <note>
          <para>Wildcard queries do not apply the analyzer on the matching
          terms. Otherwise the risk of <literal>*</literal> or
          <literal>?</literal> being mangled is too high.</para>
        </note>
      </section>

      <section>
        <title>Phrase queries</title>

        <para>So far we have been looking for words or sets of words, you can
        also search exact or approximate sentences. Use
        <methodname>phrase()</methodname> to do so.</para>

        <programlisting language="JAVA" role="JAVA">Query luceneQuery = mythQB
    .phrase()
    .onField("history")
    .sentence("Thou shalt not kill")
    .createQuery();</programlisting>

        <para>You can search approximate sentences by adding a slop factor.
        The slop factor represents the number of other words permitted in the
        sentence: this works like a within or near operator</para>

        <programlisting language="JAVA" role="JAVA">Query luceneQuery = mythQB
    .phrase()
      .withSlop(3)
    .onField("history")
    .sentence("Thou kill")
    .createQuery();</programlisting>
      </section>

      <section>
        <title>Range queries</title>

        <para>After looking at all these query examples for searching for to a
        given word, it is time to introduce range queries (on numbers, dates,
        strings etc). A range query searches for a value in between given
        boundaries (included or not) or for a value below or above a given
        boundary (included or not).</para>

        <programlisting language="JAVA" role="JAVA">//look for 0 &lt;= starred &lt; 3
Query luceneQuery = mythQB
    .range()
    .onField("starred")
    .from(0).to(3).excludeLimit()
    .createQuery();

//look for myths strictly BC
Date beforeChrist = ...;
Query luceneQuery = mythQB
    .range()
    .onField("creationDate")
    .below(beforeChrist).excludeLimit()
    .createQuery();</programlisting>
      </section>

      <section>
        <title>Combining queries</title>

        <para>Finally, you can aggregate (combine) queries to create more
        complex queries. The following aggregation operators are
        available:</para>

        <itemizedlist>
          <listitem>
            <para><literal>SHOULD</literal>: the query query should contain
            the matching elements of the subquery</para>
          </listitem>

          <listitem>
            <para><literal>MUST</literal>: the query must contain the matching
            elements of the subquery</para>
          </listitem>

          <listitem>
            <para><literal>MUST NOT</literal>: the query must not contain the
            matching elements of the subquery</para>
          </listitem>
        </itemizedlist>

        <para>The subqueries can be any Lucene query including a boolean query
        itself. Let's look at a few examples:</para>

        <programlisting language="JAVA" role="JAVA">//look for popular modern myths that are not urban
Date twentiethCentury = ...;
Query luceneQuery = mythQB
    .bool()
      .must( mythQB.keyword().onField("description").matching("urban").createQuery() )
        .not()
      .must( mythQB.range().onField("starred").above(4).createQuery() )
      .must( mythQB
        .range()
        .onField("creationDate")
        .above(twentiethCentury)
        .createQuery() )
    .createQuery();

//look for popular myths that are preferably urban
Query luceneQuery = mythQB
    .bool()
      .should( mythQB.keyword().onField("description").matching("urban").createQuery() )
      .must( mythQB.range().onField("starred").above(4).createQuery() )
    .createQuery();

//look for all myths except religious ones
Query luceneQuery = mythQB
    .all()
      .except( monthQb
        .keyword()
        .onField( "description_stem" )
        .matching( "religion" )
        .createQuery() 
      )
    .createQuery();</programlisting>
      </section>

      <section>
        <title>Query options</title>

        <para>We already have seen several query options in the previous
        example, but lets summarize again the options for query types and
        fields:</para>

        <itemizedlist>
          <listitem>
            <para><methodname>boostedTo</methodname> (on query type and on
            field): boost the whole query or the specific field to a given
            factor</para>
          </listitem>

          <listitem>
            <para><methodname>withConstantScore</methodname> (on query): all
            results matching the query have a constant score equals to the
            boost</para>
          </listitem>

          <listitem>
            <para><methodname>filteredBy(Filter)</methodname> (on query):
            filter query results using the <classname>Filter</classname>
            instance</para>
          </listitem>

          <listitem>
            <para><methodname>ignoreAnalyzer</methodname> (on field): ignore
            the analyzer when processing this field</para>
          </listitem>

          <listitem>
            <para><methodname>ignoreFieldBridge</methodname> (on field):
            ignore field bridge when processing this field</para>
          </listitem>
        </itemizedlist>

        <para>Let's check out an example using some of these options</para>

        <programlisting language="JAVA" role="JAVA">Query luceneQuery = mythQB
    .bool()
      .should( mythQB.keyword().onField("description").matching("urban").createQuery() )
      .should( mythQB
        .keyword()
        .onField("name")
          .boostedTo(3)
          .ignoreAnalyzer()
        .matching("urban").createQuery() )
      .must( mythQB
        .range()
          .boostedTo(5).withConstantScore()
        .onField("starred").above(4).createQuery() )
    .createQuery();
</programlisting>

        <para>As you can see, the Hibernate Search query DSL is an easy to use
        and easy to read query API and by accepting and producing Lucene
        queries, you can easily incorporate query types not (yet) supported by
        the DSL. Please give us feedback!</para>
      </section>
    </section>

    <section>
      <title>Building a Hibernate Search query</title>

      <para>So far we only covered the process of how to create your Lucene
      query (see <xref linkend="section-building-lucene-queries"/>). However,
      this is only the first step in the chain of actions. Let's now see how
      to build the Hibernate Search query from the Lucene query.</para>

      <section>
        <title>Generality</title>

        <para>Once the Lucene query is built, it needs to be wrapped into an
        Hibernate Query. If not specified otherwise, the query will be
        executed against all indexed entities, potentially returning all types
        of indexed classes.</para>

        <example>
          <title>Wrapping a Lucene query into a Hibernate Query</title>

          <programlisting language="JAVA" role="JAVA">FullTextSession fullTextSession = Search.getFullTextSession( session );
org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery );</programlisting>
        </example>

        <para>It is advised, from a performance point of view, to restrict the
        returned types:</para>

        <example id="example-filtering-by-entity-type">
          <title>Filtering the search result by entity type</title>

          <programlisting language="JAVA" role="JAVA">fullTextQuery = fullTextSession
    .createFullTextQuery(luceneQuery, Customer.class);

// or

fullTextQuery = fullTextSession
    .createFullTextQuery(luceneQuery, Item.class, Actor.class);</programlisting>
        </example>

        <para>In <xref linkend="example-filtering-by-entity-type"/> the first
        example returns only matching <classname>Customer</classname>s, the
        second returns matching <classname>Actor</classname>s and
        <classname>Item</classname>s. The type restriction is fully
        polymorphic which means that if there are two indexed subclasses
        <classname>Salesman</classname> and <classname>Customer</classname> of
        the baseclass <classname>Person</classname>, it is possible to just
        specify <classname>Person.class</classname> in order to filter on
        result types.</para>
      </section>

      <section>
        <title>Pagination</title>

        <para>Out of performance reasons it is recommended to restrict the
        number of returned objects per query. In fact is a very common use
        case anyway that the user navigates from one page to an other. The way
        to define pagination is exactly the way you would define pagination in
        a plain HQL or Criteria query.</para>

        <example>
          <title>Defining pagination for a search query</title>

          <programlisting language="JAVA" role="JAVA">org.hibernate.Query fullTextQuery = 
    fullTextSession.createFullTextQuery(luceneQuery, Customer.class);
fullTextQuery.setFirstResult(15); //start from the 15th element
fullTextQuery.setMaxResults(10); //return 10 elements</programlisting>
        </example>

        <tip>
          <para>It is still possible to get the total number of matching
          elements regardless of the pagination via
          <methodname>fulltextQuery.</methodname><methodname>getResultSize()</methodname></para>
        </tip>
      </section>

      <section>
        <title>Sorting</title>

        <para>Apache Lucene provides a very flexible and powerful way to sort
        results. While the default sorting (by relevance) is appropriate most
        of the time, it can be interesting to sort by one or several other
        properties. In order to do so set the Lucene Sort object to apply a
        Lucene sorting strategy.</para>

        <example>
          <title>Specifying a Lucene <classname>Sort</classname> in order to
          sort the results</title>

          <programlisting language="JAVA" role="JAVA">
org.hibernate.search.FullTextQuery query = s.createFullTextQuery( query, Book.class );
org.apache.lucene.search.Sort sort = new Sort(
    new SortField("title", SortField.STRING));
<emphasis role="bold">query.setSort(sort);</emphasis>
List results = query.list();
</programlisting>
        </example>

        <tip>
          <para>Be aware that fields used for sorting must not be tokenized
          (see <xref linkend="field-annotation"/>).</para>
        </tip>
      </section>

      <section>
        <title>Fetching strategy</title>

        <para>When you restrict the return types to one class, Hibernate
        Search loads the objects using a single query. It also respects the
        static fetching strategy defined in your domain model.</para>

        <para>It is often useful, however, to refine the fetching strategy for
        a specific use case.</para>

        <example>
          <title>Specifying <classname>FetchMode</classname> on a
          query</title>

          <programlisting language="JAVA" role="JAVA">Criteria criteria = 
    s.createCriteria(Book.class).setFetchMode("authors", FetchMode.JOIN);
s.createFullTextQuery(luceneQuery).setCriteriaQuery(criteria);</programlisting>
        </example>

        <para>In this example, the query will return all Books matching the
        luceneQuery. The authors collection will be loaded from the same query
        using an SQL outer join.</para>

        <para>When defining a criteria query, it is not necessary to restrict
        the returned entity types when creating the Hibernate Search query
        from the full text session: the type is guessed from the criteria
        query itself.</para>

        <important>
          <para>Only fetch mode can be adjusted, refrain from applying any
          other restriction. While it is known to work as of Hibernate Search
          4, using restriction (ie a where clause) on your
          <classname>Criteria</classname> query should be avoided when
          possible. <methodname>getResultSize()</methodname> will throw a
          <classname>SearchException</classname> if used in conjunction with a
          <classname>Criteria</classname> with restriction.</para>
        </important>

        <important>
          <para>You cannot use <methodname>setCriteriaQuery</methodname> if
          more than one entity type is expected to be returned.</para>
        </important>
      </section>

      <section id="projections">
        <title>Projection</title>

        <para>For some use cases, returning the domain object (including its
        associations) is overkill. Only a small subset of the properties is
        necessary. Hibernate Search allows you to return a subset of
        properties:</para>

        <example>
          <title>Using projection instead of returning the full domain
          object</title>

          <programlisting language="JAVA" role="JAVA">org.hibernate.search.FullTextQuery query = 
    s.createFullTextQuery(luceneQuery, Book.class);
query.<emphasis role="bold">setProjection("id", "summary", "body", "mainAuthor.name")</emphasis>;
List results = query.list();
Object[] firstResult = (Object[]) results.get(0);
Integer id = firstResult[0];
String summary = firstResult[1];
String body = firstResult[2];
String authorName = firstResult[3];</programlisting>
        </example>

        <para>Hibernate Search extracts the properties from the Lucene index
        and convert them back to their object representation, returning a list
        of <classname>Object[]</classname>. Projections avoid a potential
        database round trip (useful if the query response time is critical).
        However, it also has several constraints:</para>

        <itemizedlist>
          <listitem>
            <para>the properties projected must be stored in the index
            (<literal>@Field(store=Store.YES)</literal>), which increases the
            index size</para>
          </listitem>

          <listitem>
            <para>the properties projected must use a
            <literal>FieldBridge</literal> implementing
            <classname>org.hibernate.search.bridge.TwoWayFieldBridge</classname>
            or
            <literal>org.hibernate.search.bridge.TwoWayStringBridge</literal>,
            the latter being the simpler version.</para>

            <note>
              <para>All Hibernate Search built-in types are two-way.</para>
            </note>
          </listitem>

          <listitem>
            <para>you can only project simple properties of the indexed entity
            or its embedded associations. This means you cannot project a
            whole embedded entity.</para>
          </listitem>

          <listitem>
            <para>projection does not work on collections or maps which are
            indexed via <classname>@IndexedEmbedded</classname></para>
          </listitem>
        </itemizedlist>

        <para>Projection is also useful for another kind of use case. Lucene
        can provide metadata information about the results. By using some
        special projection constants, the projection mechanism can retrieve
        this metadata:</para>

        <example>
          <title>Using projection in order to retrieve meta data</title>

          <programlisting language="JAVA" role="JAVA">org.hibernate.search.FullTextQuery query = 
    s.createFullTextQuery(luceneQuery, Book.class);
query.<emphasis role="bold">setProjection( 
    FullTextQuery.SCORE, 
    FullTextQuery.THIS, 
    "mainAuthor.name" )</emphasis>;
List results = query.list();
Object[] firstResult = (Object[]) results.get(0);
float score = firstResult[0];
Book book = firstResult[1];
String authorName = firstResult[2];</programlisting>
        </example>

        <para>You can mix and match regular fields and projection constants.
        Here is the list of the available constants:</para>

        <itemizedlist>
          <listitem>
            <para><classname>FullTextQuery.THIS</classname>: returns the
            initialized and managed entity (as a non projected query would
            have done).</para>
          </listitem>

          <listitem>
            <para><classname>FullTextQuery.DOCUMENT</classname>: returns the
            Lucene Document related to the object projected.</para>
          </listitem>

          <listitem>
            <para><classname>FullTextQuery.OBJECT_CLASS</classname>: returns
            the class of the indexed entity.</para>
          </listitem>

          <listitem>
            <para><classname>FullTextQuery.SCORE</classname>: returns the
            document score in the query. Scores are handy to compare one
            result against an other for a given query but are useless when
            comparing the result of different queries.</para>
          </listitem>

          <listitem>
            <para><classname>FullTextQuery.ID</classname>: the id property
            value of the projected object.</para>
          </listitem>

          <listitem>
            <para><classname>FullTextQuery.DOCUMENT_ID</classname>: the Lucene
            document id. Careful, Lucene document id can change overtime
            between two different IndexReader opening.</para>
          </listitem>

          <listitem>
            <para><classname>FullTextQuery.EXPLANATION</classname>: returns
            the Lucene Explanation object for the matching object/document in
            the given query. Do not use if you retrieve a lot of data. Running
            explanation typically is as costly as running the whole Lucene
            query per matching element. Make sure you use projection!</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Customizing object initialization strategies</title>

        <para>By default, Hibernate Search uses the most appropriate strategy
        to initialize entities matching your full text query. It executes one
        (or several) queries to retrieve the required entities. This is the
        best approach to minimize database round trips in a scenario where
        none / few of the retrieved entities are present in the persistence
        context (ie the session) or the second level cache.</para>

        <para>If most of your entities are present in the second level cache,
        you can force Hibernate Search to look into the cache before
        retrieving an object from the database.</para>

        <example>
          <title>Check the second-level cache before using a query</title>

          <programlisting language="JAVA" role="JAVA">FullTextQuery query = session.createFullTextQuery(luceneQuery, User.class);
query.initializeObjectWith(
    ObjectLookupMethod.SECOND_LEVEL_CACHE,
    DatabaseRetrievalMethod.QUERY
);</programlisting>
        </example>

        <para><classname>ObjectLookupMethod</classname> defines the strategy
        used to check if an object is easily accessible (without database
        round trip). Other options are:</para>

        <itemizedlist>
          <listitem>
            <para><literal>ObjectLookupMethod.PERSISTENCE_CONTEXT</literal>:
            useful if most of the matching entities are already in the
            persistence context (ie loaded in the
            <classname>Session</classname> or
            <classname>EntityManager</classname>)</para>
          </listitem>

          <listitem>
            <para><literal>ObjectLookupMethod.SECOND_LEVEL_CACHE</literal>:
            check first the persistence context and then the second-level
            cache.</para>
          </listitem>
        </itemizedlist>

        <note>
          <para>Note that to search in the second-level cache, several
          settings must be in place:</para>

          <itemizedlist>
            <listitem>
              <para>the second level cache must be properly configured and
              active</para>
            </listitem>

            <listitem>
              <para>the entity must have enabled second-level cache (eg via
              <classname>@Cacheable</classname>)</para>
            </listitem>

            <listitem>
              <para>the <classname>Session</classname>,
              <classname>EntityManager</classname> or
              <classname>Query</classname> must allow access to the
              second-level cache for read access (ie
              <literal>CacheMode.NORMAL</literal> in Hibernate native APIs or
              <literal>CacheRetrieveMode.USE</literal> in JPA 2 APIs).</para>
            </listitem>
          </itemizedlist>
        </note>

        <warning>
          <para>Avoid using
          <literal>ObjectLookupMethod.SECOND_LEVEL_CACHE</literal> unless your
          second level cache implementation is either EHCache or Infinispan;
          other second level cache providers don't currently implement this
          operation efficiently.</para>
        </warning>

        <para>You can also customize how objects are loaded from the database
        (if not found before). Use
        <classname>DatabaseRetrievalMethod</classname> for that:</para>

        <itemizedlist>
          <listitem>
            <para><classname>QUERY</classname> (default): use a (set of)
            queries to load several objects in batch. This is usually the best
            approach.</para>
          </listitem>

          <listitem>
            <para><classname>FIND_BY_ID</classname>: load objects one by one
            using the
            <classname>Session</classname>.<methodname>get</methodname> or
            <classname>EntityManager</classname>.<methodname>find</methodname>
            semantic. This might be useful if batch-size is set on the entity
            (in which case, entities will be loaded in batch by Hibernate
            Core). <classname>QUERY</classname> should be preferred almost all
            the time.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Limiting the time of a query</title>

        <para>You can limit the time a query takes in Hibernate Search in two
        ways:</para>

        <itemizedlist>
          <listitem>
            <para>raise an exception when the limit is reached</para>
          </listitem>

          <listitem>
            <para>limit to the number of results retrieved when the time limit
            is raised</para>
          </listitem>
        </itemizedlist>

        <section>
          <title>Raise an exception on time limit</title>

          <para>You can decide to stop a query if when it takes more than a
          predefined amount of time. Note that this is a best effort basis but
          if Hibernate Search still has significant work to do and if we are
          beyond the time limit, a
          <classname>QueryTimeoutException</classname> will be raised
          (<classname>org.hibernate.QueryTimeoutException</classname> or
          <classname>javax.persistence.QueryTimeoutException</classname>
          depending on your programmatic API).</para>

          <para>To define the limit when using the native Hibernate APIs, use
          one of the following approaches</para>

          <example>
            <title>Defining a timeout in query execution</title>

            <programlisting language="JAVA" role="JAVA">Query luceneQuery = ...;
FullTextQuery query = fullTextSession.createFullTextQuery(luceneQuery, User.class);

//define the timeout in seconds
query.setTimeout(5);

//alternatively, define the timeout in any given time unit
query.setTimeout(450, TimeUnit.MILLISECONDS);

try {
    query.list();
}
catch (org.hibernate.QueryTimeoutException e) {
    //do something, too slow
}</programlisting>
          </example>

          <para>Likewise <literal>getResultSize()</literal>,
          <methodname>iterate()</methodname> and
          <methodname>scroll()</methodname> honor the timeout but only until
          the end of the method call. That simply means that the methods of
          <classname>Iterable</classname> or the
          <classname>ScrollableResults</classname> ignore the timeout.</para>

          <note>
            <para><methodname>explain()</methodname> does not honor the
            timeout: this method is used for debug purposes and in particular
            to find out why a query is slow</para>
          </note>

          <para>When using JPA, simply use the standard way of limiting query
          execution time.</para>

          <example>
            <title>Defining a timeout in query execution</title>

            <programlisting language="JAVA" role="JAVA">Query luceneQuery = ...;
FullTextQuery query = fullTextEM.createFullTextQuery(luceneQuery, User.class);

//define the timeout in milliseconds
query.setHint( "javax.persistence.query.timeout", 450 );

try {
    query.getResultList();
}
catch (javax.persistence.QueryTimeoutException e) {
    //do something, too slow
}</programlisting>
          </example>

          <important>
            <para>Remember, this is a best effort approach and does not
            guarantee to stop exactly on the specified timeout.</para>
          </important>
        </section>

        <section>
          <title>Limit the number of results when the time limit is
          reached</title>

          <para>Alternatively, you can return the number of results which have
          already been fetched by the time the limit is reached. Note that
          only the Lucene part of the query is influenced by this limit. It is
          possible that, if you retrieve managed object, it takes longer to
          fetch these objects.</para>

          <warning>
            <para>This approach is not compatible with the
            <classname>setTimeout</classname> approach.</para>
          </warning>

          <para>To define this soft limit, use the following approach</para>

          <example>
            <title>Defining a time limit in query execution</title>

            <programlisting language="JAVA" role="JAVA">Query luceneQuery = ...;
FullTextQuery query = fullTextSession.createFullTextQuery(luceneQuery, User.class);

//define the timeout in seconds
query.limitExecutionTimeTo(500, TimeUnit.MILLISECONDS);
List results = query.list();</programlisting>
          </example>

          <para>Likewise <literal>getResultSize()</literal>,
          <methodname>iterate()</methodname> and
          <methodname>scroll()</methodname> honor the time limit but only
          until the end of the method call. That simply means that the methods
          of <classname>Iterable</classname> or the
          <classname>ScrollableResults</classname> ignore the timeout.</para>

          <para>You can determine if the results have been partially loaded by
          invoking the <methodname>hasPartialResults</methodname>
          method.</para>

          <example>
            <title>Determines when a query returns partial results</title>

            <programlisting language="JAVA" role="JAVA">Query luceneQuery = ...;
FullTextQuery query = fullTextSession.createFullTextQuery(luceneQuery, User.class);

//define the timeout in seconds
query.limitExecutionTimeTo(500, TimeUnit.MILLISECONDS);
List results = query.list();

if ( query.hasPartialResults() ) {
    displayWarningToUser();
}</programlisting>
          </example>

          <para>If you use the JPA API,
          <methodname>limitExecutionTimeTo</methodname> and
          <methodname>hasPartialResults</methodname> are also available to
          you.</para>
        </section>
      </section>
    </section>
  </section>

  <section>
    <title>Retrieving the results</title>

    <para>Once the Hibernate Search query is built, executing it is in no way
    different than executing a HQL or Criteria query. The same paradigm and
    object semantic applies. All the common operations are available:
    <methodname>list()</methodname>, <methodname>uniqueResult()</methodname>,
    <methodname>iterate()</methodname>,
    <methodname>scroll()</methodname>.</para>

    <section>
      <title>Performance considerations</title>

      <para>If you expect a reasonable number of results (for example using
      pagination) and expect to work on all of them,
      <methodname>list()</methodname> or
      <methodname>uniqueResult()</methodname> are recommended.
      <methodname>list()</methodname> work best if the entity
      <literal>batch-size</literal> is set up properly. Note that Hibernate
      Search has to process all Lucene Hits elements (within the pagination)
      when using <methodname>list()</methodname> ,
      <methodname>uniqueResult()</methodname> and
      <methodname>iterate()</methodname>.</para>

      <para>If you wish to minimize Lucene document loading,
      <methodname>scroll()</methodname> is more appropriate. Don't forget to
      close the <classname>ScrollableResults</classname> object when you're
      done, since it keeps Lucene resources. If you expect to use
      <methodname>scroll,</methodname> but wish to load objects in batch, you
      can use <methodname>query.setFetchSize()</methodname>. When an object is
      accessed, and if not already loaded, Hibernate Search will load the next
      <literal>fetchSize</literal> objects in one pass.</para>

      <important>
        <para>Pagination is preferred over scrolling.</para>
      </important>
    </section>

    <section>
      <title>Result size</title>

      <para>It is sometimes useful to know the total number of matching
      documents:</para>

      <itemizedlist>
        <listitem>
          <para>for the Google-like feature "1-10 of about 888,000,000"</para>
        </listitem>

        <listitem>
          <para>to implement a fast pagination navigation</para>
        </listitem>

        <listitem>
          <para>to implement a multi step search engine (adding approximation
          if the restricted query return no or not enough results)</para>
        </listitem>
      </itemizedlist>

      <para>Of course it would be too costly to retrieve all the matching
      documents. Hibernate Search allows you to retrieve the total number of
      matching documents regardless of the pagination parameters. Even more
      interesting, you can retrieve the number of matching elements without
      triggering a single object load.</para>

      <example>
        <title>Determining the result size of a query</title>

        <programlisting language="JAVA" role="JAVA">org.hibernate.search.FullTextQuery query = 
    s.createFullTextQuery(luceneQuery, Book.class);
//return the number of matching books without loading a single one
assert 3245 == <emphasis role="bold">query.getResultSize()</emphasis>; 

org.hibernate.search.FullTextQuery query = 
    s.createFullTextQuery(luceneQuery, Book.class);
query.setMaxResult(10);
List results = query.list();
//return the total number of matching books regardless of pagination
assert 3245 == <emphasis role="bold">query.getResultSize()</emphasis>; </programlisting>
      </example>

      <note>
        <para>Like Google, the number of results is an approximation if the
        index is not fully up-to-date with the database (asynchronous cluster
        for example).</para>
      </note>
    </section>

    <section>
      <title>ResultTransformer</title>

      <para>As seen in <xref linkend="projections"/> projection results are
      returns as <classname>Object</classname> arrays. This data structure is
      not always matching the application needs. In this cases It is possible
      to apply a <classname>ResultTransformer</classname> which post query
      execution can build the needed data structure:</para>

      <example>
        <title>Using ResultTransformer in conjunction with projections</title>

        <programlisting language="JAVA" role="JAVA">org.hibernate.search.FullTextQuery query = 
    s.createFullTextQuery(luceneQuery, Book.class);
query.setProjection("title", "mainAuthor.name");

<emphasis role="bold">query.setResultTransformer( 
    new StaticAliasToBeanResultTransformer( 
        BookView.class, 
        "title", 
        "author" ) 
);</emphasis>
List&lt;BookView&gt; results = (List&lt;BookView&gt;) query.list();
for (BookView view : results) {
    log.info("Book: " + view.getTitle() + ", " + view.getAuthor());
}</programlisting>
      </example>

      <para>Examples of <classname>ResultTransformer</classname>
      implementations can be found in the Hibernate Core codebase.</para>
    </section>

    <section>
      <title>Understanding results</title>

      <para>You will find yourself sometimes puzzled by a result showing up in
      a query or a result not showing up in a query. Luke is a great tool to
      understand those mysteries. However, Hibernate Search also gives you
      access to the Lucene <classname>Explanation</classname> object for a
      given result (in a given query). This class is considered fairly
      advanced to Lucene users but can provide a good understanding of the
      scoring of an object. You have two ways to access the Explanation object
      for a given result:</para>

      <itemizedlist>
        <listitem>
          <para>Use the <methodname>fullTextQuery.explain(int)</methodname>
          method</para>
        </listitem>

        <listitem>
          <para>Use projection</para>
        </listitem>
      </itemizedlist>

      <para>The first approach takes a document id as a parameter and return
      the Explanation object. The document id can be retrieved using
      projection and the <literal>FullTextQuery.DOCUMENT_ID</literal>
      constant.</para>

      <warning>
        <para>The Document id has nothing to do with the entity id. Do not
        mess up these two notions.</para>
      </warning>

      <para>In the second approach you project the
      <classname>Explanation</classname> object using the
      <literal>FullTextQuery.EXPLANATION</literal> constant.</para>

      <example>
        <title>Retrieving the Lucene Explanation object using
        projection</title>

        <programlisting language="JAVA" role="JAVA">FullTextQuery ftQuery = s.createFullTextQuery( luceneQuery, Dvd.class )
        .setProjection( 
             FullTextQuery.DOCUMENT_ID, 
             <emphasis role="bold">FullTextQuery.EXPLANATION</emphasis>, 
             FullTextQuery.THIS );
@SuppressWarnings("unchecked") List&lt;Object[]&gt; results = ftQuery.list();
for (Object[] result : results) {
    Explanation e = (Explanation) result[1];
    display( e.toString() );
}</programlisting>
      </example>

      <para>Be careful, building the explanation object is quite expensive, it
      is roughly as expensive as running the Lucene query again. Don't do it
      if you don't need the object</para>
    </section>
  </section>

  <section id="query-filter">
    <title>Filters</title>

    <para>Apache Lucene has a powerful feature that allows to filter query
    results according to a custom filtering process. This is a very powerful
    way to apply additional data restrictions, especially since filters can be
    cached and reused. Some interesting use cases are:</para>

    <itemizedlist>
      <listitem>
        <para>security</para>
      </listitem>

      <listitem>
        <para>temporal data (eg. view only last month's data)</para>
      </listitem>

      <listitem>
        <para>population filter (eg. search limited to a given
        category)</para>
      </listitem>

      <listitem>
        <para>and many more</para>
      </listitem>
    </itemizedlist>

    <para>Hibernate Search pushes the concept further by introducing the
    notion of parameterizable named filters which are transparently cached.
    For people familiar with the notion of Hibernate Core filters, the API is
    very similar:</para>

    <example>
      <title>Enabling fulltext filters for a given query</title>

      <programlisting language="JAVA" role="JAVA">fullTextQuery = s.createFullTextQuery(query, Driver.class);
fullTextQuery.enableFullTextFilter("bestDriver");
fullTextQuery.enableFullTextFilter("security").setParameter("login", "andre");
fullTextQuery.list(); //returns only best drivers where andre has credentials</programlisting>
    </example>

    <para>In this example we enabled two filters on top of the query. You can
    enable (or disable) as many filters as you like.</para>

    <para>Declaring filters is done through the
    <classname>@FullTextFilterDef</classname> annotation. This annotation can
    be on any <literal>@Indexed</literal> entity regardless of the query the
    filter is later applied to. This implies that filter definitions are
    global and their names must be unique. A
    <classname>SearchException</classname> is thrown in case two different
    <classname>@FullTextFilterDef</classname> annotations with the same name
    are defined. Each named filter has to specify its actual filter
    implementation.</para>

    <example>
      <title>Defining and implementing a Filter</title>

      <programlisting>@Entity
@Indexed
@FullTextFilterDefs( {
    <emphasis role="bold">@FullTextFilterDef(name = "bestDriver", impl = BestDriversFilter.class)</emphasis>, 
    <emphasis role="bold">@FullTextFilterDef(name = "security", impl = SecurityFilterFactory.class)</emphasis> 
})
public class Driver { ... }</programlisting>

      <programlisting language="JAVA" role="JAVA">public class BestDriversFilter extends <emphasis
          role="bold">org.apache.lucene.search.Filter</emphasis> {

    public DocIdSet getDocIdSet(IndexReader reader) throws IOException {
        OpenBitSet bitSet = new OpenBitSet( reader.maxDoc() );
        TermDocs termDocs = reader.termDocs( new Term( "score", "5" ) );
        while ( termDocs.next() ) {
            bitSet.set( termDocs.doc() );
        }
        return bitSet;
    }
}</programlisting>
    </example>

    <para><classname>BestDriversFilter</classname> is an example of a simple
    Lucene filter which reduces the result set to drivers whose score is 5. In
    this example the specified filter implements the
    <literal>org.apache.lucene.search.Filter</literal> directly and contains a
    no-arg constructor.</para>

    <para>If your Filter creation requires additional steps or if the filter
    you want to use does not have a no-arg constructor, you can use the
    factory pattern:</para>

    <example>
      <title>Creating a filter using the factory pattern</title>

      <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
@FullTextFilterDef(name = "bestDriver", impl = BestDriversFilterFactory.class)
public class Driver { ... }

public class BestDriversFilterFactory {

    <emphasis role="bold">@Factory</emphasis>
    public Filter getFilter() {
        //some additional steps to cache the filter results per IndexReader
        Filter bestDriversFilter = new BestDriversFilter();
        return new CachingWrapperFilter(bestDriversFilter);
    }
}</programlisting>
    </example>

    <para>Hibernate Search will look for a <literal>@Factory</literal>
    annotated method and use it to build the filter instance. The factory must
    have a no-arg constructor.</para>

    <para>Named filters come in handy where parameters have to be passed to
    the filter. For example a security filter might want to know which
    security level you want to apply:</para>

    <example>
      <title>Passing parameters to a defined filter</title>

      <programlisting language="JAVA" role="JAVA">fullTextQuery = s.createFullTextQuery(query, Driver.class);
fullTextQuery.enableFullTextFilter("security")<emphasis role="bold">.setParameter("level", 5)</emphasis>;</programlisting>
    </example>

    <para>Each parameter name should have an associated setter on either the
    filter or filter factory of the targeted named filter definition.</para>

    <example>
      <title>Using parameters in the actual filter implementation</title>

      <programlisting language="JAVA" role="JAVA">public class SecurityFilterFactory {
    private Integer level;

    /**
     * injected parameter
     */
    <emphasis role="bold">public void setLevel(Integer level)</emphasis> {
        this.level = level;
    }

    <emphasis role="bold">@Key
    public FilterKey getKey()</emphasis> {
        StandardFilterKey key = new StandardFilterKey();
        key.addParameter( level );
        return key;
    }

    @Factory
    public Filter getFilter() {
        Query query = new TermQuery( new Term("level", level.toString() ) );
        return new CachingWrapperFilter( new QueryWrapperFilter(query) );
    }
}</programlisting>
    </example>

    <para>Note the method annotated <classname>@Key</classname> returning a
    <classname>FilterKey</classname> object. The returned object has a special
    contract: the key object must implement <methodname>equals()</methodname>
    / <methodname>hashCode()</methodname> so that 2 keys are equal if and only
    if the given <classname>Filter</classname> types are the same and the set
    of parameters are the same. In other words, 2 filter keys are equal if and
    only if the filters from which the keys are generated can be interchanged.
    The key object is used as a key in the cache mechanism.</para>

    <para><classname>@Key</classname> methods are needed only if:</para>

    <itemizedlist>
      <listitem>
        <para>you enabled the filter caching system (enabled by
        default)</para>
      </listitem>

      <listitem>
        <para>your filter has parameters</para>
      </listitem>
    </itemizedlist>

    <para>In most cases, using the <literal>StandardFilterKey</literal>
    implementation will be good enough. It delegates the
    <methodname>equals()</methodname> / <methodname>hashCode()</methodname>
    implementation to each of the parameters equals and hashcode
    methods.</para>

    <para>As mentioned before the defined filters are per default cached and
    the cache uses a combination of hard and soft references to allow disposal
    of memory when needed. The hard reference cache keeps track of the most
    recently used filters and transforms the ones least used to
    <classname>SoftReferences</classname> when needed. Once the limit of the
    hard reference cache is reached additional filters are cached as
    <classname>SoftReferences</classname>. To adjust the size of the hard
    reference cache, use
    <literal>hibernate.search.filter.cache_strategy.size</literal> (defaults
    to 128). For advanced use of filter caching, you can implement your own
    <classname>FilterCachingStrategy</classname>. The classname is defined by
    <literal>hibernate.search.filter.cache_strategy</literal>.</para>

    <para>This filter caching mechanism should not be confused with caching
    the actual filter results. In Lucene it is common practice to wrap filters
    using the <classname>IndexReader</classname> around a
    <classname>CachingWrapperFilter.</classname> The wrapper will cache the
    <classname>DocIdSet</classname> returned from the
    <methodname>getDocIdSet(IndexReader reader)</methodname> method to avoid
    expensive recomputation. It is important to mention that the computed
    <classname>DocIdSet</classname> is only cachable for the same
    <classname>IndexReader</classname> instance, because the reader
    effectively represents the state of the index at the moment it was opened.
    The document list cannot change within an opened
    <classname>IndexReader</classname>. A different/new<classname>
    IndexReader</classname> instance, however, works potentially on a
    different set of <classname>Document</classname>s (either from a different
    index or simply because the index has changed), hence the cached
    <classname>DocIdSet</classname> has to be recomputed.</para>

    <para>Hibernate Search also helps with this aspect of caching. Per default
    the <literal>cache</literal> flag of <classname>@FullTextFilterDef
    </classname>is set to
    <literal>FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS</literal> which
    will automatically cache the filter instance as well as wrap the specified
    filter around a Hibernate specific implementation of
    <classname>CachingWrapperFilter</classname>. In contrast to Lucene's
    version of this class <classname>SoftReference</classname>s are used
    together with a hard reference count (see discussion about filter cache).
    The hard reference count can be adjusted using
    <literal>hibernate.search.filter.cache_docidresults.size</literal>
    (defaults to 5). The wrapping behaviour can be controlled using the
    <literal>@FullTextFilterDef.cache</literal> parameter. There are three
    different values for this parameter:</para>

    <para><informaltable align="left" width="">
        <tgroup cols="2">
          <thead>
            <row>
              <entry align="center">Value</entry>

              <entry align="center">Definition</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry align="left">FilterCacheModeType.NONE</entry>

              <entry>No filter instance and no result is cached by Hibernate
              Search. For every filter call, a new filter instance is created.
              This setting might be useful for rapidly changing data sets or
              heavily memory constrained environments.</entry>
            </row>

            <row>
              <entry align="left">FilterCacheModeType.INSTANCE_ONLY</entry>

              <entry>The filter instance is cached and reused across
              concurrent <methodname>Filter.getDocIdSet()</methodname> calls.
              <classname>DocIdSet</classname> results are not cached. This
              setting is useful when a filter uses its own specific caching
              mechanism or the filter results change dynamically due to
              application specific events making
              <classname>DocIdSet</classname> caching in both cases
              unnecessary.</entry>
            </row>

            <row>
              <entry
              align="left">FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS</entry>

              <entry>Both the filter instance and the
              <classname>DocIdSet</classname> results are cached. This is the
              default value.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>Last but not least - why should filters be cached? There
    are two areas where filter caching shines:</para>

    <itemizedlist>
      <listitem>
        <para>the system does not update the targeted entity index often (in
        other words, the IndexReader is reused a lot)</para>
      </listitem>

      <listitem>
        <para>the Filter's DocIdSet is expensive to compute (compared to the
        time spent to execute the query)</para>
      </listitem>
    </itemizedlist>

    <section id="query-filter-shard">
      <title>Using filters in a sharded environment</title>

      <para>It is possible, in a sharded environment to execute queries on a
      subset of the available shards. This can be done in two steps:</para>

      <itemizedlist>
        <listitem>
          <para>create a sharding strategy that does select a subset of
          <classname>IndexManager</classname>s depending on some filter
          configuration</para>
        </listitem>

        <listitem>
          <para>activate the proper filter at query time</para>
        </listitem>
      </itemizedlist>

      <para>Let's first look at an example of sharding strategy that query on
      a specific customer shard if the customer filter is activated.</para>

      <programlisting language="JAVA" role="JAVA">public class CustomerShardingStrategy implements IndexShardingStrategy {

 // stored IndexManagers in a array indexed by customerID
 private IndexManager[] indexManagers;
 
 public void initialize(Properties properties, IndexManager[] indexManagers) {
   this.indexManagers = indexManagers;
 }

 public IndexManager[] getIndexManagersForAllShards() {
   return indexManagers;
 }

 public IndexManager getIndexManagerForAddition(
     Class&lt;?&gt; entity, Serializable id, String idInString, Document document) {
   Integer customerID = Integer.parseInt(document.getFieldable("customerID").stringValue());
   return indexManagers[customerID];
 }

 public IndexManager[] getIndexManagersForDeletion(
     Class&lt;?&gt; entity, Serializable id, String idInString) {
   return getIndexManagersForAllShards();
 }

  /**
  * Optimization; don't search ALL shards and union the results; in this case, we 
  * can be certain that all the data for a particular customer Filter is in a single
  * shard; simply return that shard by customerID.
  */
 public IndexManager[] getIndexManagersForQuery(
     FullTextFilterImplementor[] filters) {
   FullTextFilter filter = getCustomerFilter(filters, "customer");
   if (filter == null) {
     return getIndexManagersForAllShards();
   }
   else {
     return new IndexManager[] { indexManagers[Integer.parseInt(
       filter.getParameter("customerID").toString())] };
   }
 }

 private FullTextFilter getCustomerFilter(FullTextFilterImplementor[] filters, String name) {
   for (FullTextFilterImplementor filter: filters) {
     if (filter.getName().equals(name)) return filter;
   }
   return null;
 }
}</programlisting>

      <para>In this example, if the filter named <literal>customer</literal>
      is present, we make sure to only use the shard dedicated to this
      customer. Otherwise, we return all shards. A given Sharding strategy can
      react to one or more filters and depends on their parameters.</para>

      <para>The second step is simply to activate the filter at query time.
      While the filter can be a regular filter (as defined in <xref
      linkend="query-filter"/>) which also filters Lucene results after the
      query, you can make use of a special filter that will only be passed to
      the sharding strategy and otherwise ignored for the rest of the query.
      Simply use the <classname>ShardSensitiveOnlyFilter</classname> class
      when declaring your filter.</para>

      <programlisting language="JAVA" role="JAVA">@Entity @Indexed
<emphasis role="bold">@FullTextFilterDef(name="customer", impl=ShardSensitiveOnlyFilter.class)</emphasis>
public class Customer {
   ...
}

FullTextQuery query = ftEm.createFullTextQuery(luceneQuery, Customer.class);
<emphasis role="bold">query.enableFulltextFilter("customer").setParameter("CustomerID", 5);</emphasis>
@SuppressWarnings("unchecked")
List&lt;Customer&gt; results = query.getResultList();</programlisting>

      <para>Note that by using the
      <classname>ShardSensitiveOnlyFilter</classname>, you do not have to
      implement any Lucene filter. Using filters and sharding strategy
      reacting to these filters is recommended to speed up queries in a
      sharded environment.</para>
    </section>
  </section>

  <section id="query-faceting" revision="1">
    <title>Faceting</title>

    <para><ulink url="http://en.wikipedia.org/wiki/Faceted_search">Faceted
    search</ulink> is a technique which allows to divide the results of a
    query into multiple categories. This categorization includes the
    calculation of hit counts for each category and the ability to further
    restrict search results based on these facets (categories). <xref lang=""
    linkend="example-amazon-facets"/> shows a faceting example. The search for
    'Hibernate Search' results in fifteen hits which are displayed on the main
    part of the page. The navigation bar on the left, however, shows the
    category<emphasis> Computers &amp; Internet</emphasis> with its
    subcategories <emphasis>Programming</emphasis>, <emphasis>Computer
    Science</emphasis>, <emphasis>Databases</emphasis>,
    <emphasis>Software</emphasis>, <emphasis>Web Development,</emphasis>
    <emphasis>Networking</emphasis> and <emphasis>Home Computing</emphasis>.
    For each of these subcategories the number of books is shown matching the
    main search criteria and belonging to the respective subcategory. This
    division of the category <emphasis>Computers &amp; Internet</emphasis> is
    one facet of this search. Another one is for example the average customer
    review rating.</para>

    <example id="example-amazon-facets">
      <title>Search for <emphasis>'Hibernate Search'</emphasis> on
      Amazon</title>

      <mediaobject>
        <imageobject role="fo">
          <imagedata align="center" fileref="faceting.png" width="14cm"/>
        </imageobject>

        <imageobject role="html">
          <imagedata align="center" depth="3cm" fileref="faceting.png"/>
        </imageobject>
      </mediaobject>
    </example>

    <para>In Hibernate Search the classes <classname>QueryBuilder</classname>
    and <classname>FullTextQuery</classname> are the entry point to the
    faceting API. The former allows to create faceting requests whereas the
    latter gives access to the so called <classname>FacetManager</classname>.
    With the help of the <classname>FacetManager</classname> faceting requests
    can be applied on a query and selected facets can be added to an existing
    query in order to refine search results. The following sections will
    describe the faceting process in more detail. The examples will use the
    entity <classname>Cd</classname> as shown in <xref
    linkend="example-faceting-entity"/>:</para>

    <example id="example-faceting-entity">
      <title>Example entity for faceting</title>

      <programlisting language="JAVA" role="JAVA">@Entity
@Indexed
public class Cd {

    @Id
    @GeneratedValue
    private int id;

    @Fields( {
        @Field,
        @Field(name = "name_un_analyzed", analyze = Analyze.NO)
    })
    private String name;

    @Field(analyze = Analyze.NO)
    private int price;

    Field(analyze = Analyze.NO)
    @DateBridge(resolution = Resolution.YEAR)
    private Date releaseYear;

    @Field(analyze = Analyze.NO)
    private String label;


// setter/getter
...</programlisting>
    </example>

    <section id="section-creating-faceting-request">
      <title>Creating a faceting request</title>

      <para>The first step towards a faceted search is to create the
      <classname>FacetingRequest</classname>. Currently two types of faceting
      requests are supported. The first type is called <emphasis>discrete
      faceting</emphasis> and the second type <emphasis>range
      faceting</emphasis> request.</para>

      <section id="discrete-faceting-request">
        <title>Discrete faceting request</title>

        <para>In the case of a discrete faceting request you start with giving
        the request a unique name. This name will later be used to retrieve
        the facet values (see <xref
        linkend="section-interpreting-facet-result"/>). Then you need to
        specify on which index field you want to categorize on and which
        faceting options to apply. An example for a discrete faceting request
        can be seen in <xref linkend="example-discrete-faceting"/>:</para>

        <example id="example-discrete-faceting">
          <title>Creating a discrete faceting request</title>

          <programlisting language="JAVA" role="JAVA">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder()
        .forEntity(Cd.class)
            .get();
FacetingRequest labelFacetingRequest = builder.facet()
    .name("labelFacetRequest")
    .onField("label")
    .discrete()
    .orderedBy(FacetSortOrder.COUNT_DESC)
    .includeZeroCounts(false)
    .maxFacetCount(3)
    .createFacetingRequest();</programlisting>
        </example>

        <para>When executing this faceting request a
        <classname>Facet</classname> instance will be created for each
        discrete value for the indexed field <constant>label</constant>. The
        <classname>Facet</classname> instance will record the actual field
        value including how often this particular field value occurs within
        the original query results. Parameters <methodname>orderedBy</methodname>,
        <methodname>includeZeroCounts</methodname> and
        <methodname>maxFacetCount</methodname> are optional and can be applied
        on any faceting request.
        Parameter <methodname>orderedBy</methodname> allows to specify in which
        order the created facets will be returned. The default is
        <constant>FacetSortOrder.COUNT_DESC</constant>, but you can also sort
        on the field value. Parameter <methodname>includeZeroCount</methodname>
        determines whether facets with a count of 0 will be included in the
        result (by default they are) and <methodname>maxFacetCount</methodname>
        allows to limit the maximum amount of facets returned.</para>

        <note>
          <para>There are several preconditions an indexed field has to meet
          in order to categorize (facet) on it. The indexed
          property must be of type <classname>String</classname>,
          <classname>Date</classname> or a subtype of
          <classname>Number</classname>; also <constant>null</constant> values
          should be avoided. Finally the property has to be indexed with
          <constant>Analyze.NO</constant> and you can not use it in combination
          with <classname>@NumericField</classname>. When you need these other
          options we suggest to index the property twice and use the appropriate
          field depending on the use case: <programlisting>...
@Fields({
  @Field( name="price" ),
  @Field( name="price_facet", analyze=Analyze.NO )
})
@NumericFields({
  @NumericField( forField="price" )
})
private int price;
...</programlisting></para>
        </note>
      </section>

      <section id="range-faceting-request">
        <title>Creating a range faceting request</title>

        <para>The creation of a range faceting request is similar. We also
        start with a name for the request and the field to facet on. Then
        we have to specify ranges for the field values. A range faceting
        request can be seen in <xref linkend="example-range-faceting"/>.
        There, three different price ranges are specified.
        <methodname>below</methodname> and <methodname>above</methodname> can
        only be specified once, but you can specify as many
        <methodname>from</methodname> - <methodname>to</methodname> ranges as
        you want. For each range boundary you can also specify via
        <methodname>excludeLimit</methodname> whether it is included into the
        range or not.</para>

        <example id="example-range-faceting">
          <title>Creating a range faceting request</title>

          <programlisting language="JAVA" role="JAVA">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder()
        .forEntity(Cd.class)
            .get();
FacetingRequest priceFacetingRequest = builder.facet()
    .name("priceFaceting")
    .onField("price_facet")
    .range()
    .below(1000)
    .from(1001).to(1500)
    .above(1500).excludeLimit()
    .createFacetingRequest();</programlisting>
        </example>
      </section>
    </section>

    <section id="section-sorting-faceting-request">
      <title>Setting the facet sort order</title>

      <para>The result of applying a faceting request is a list of
      <classname>Facet</classname> instances as seen in <xref
      linkend="example-applying-faceting"/>. The order within the list is
      given by the <classname>FacetSortOrder</classname> parameter specified
      via <methodname>orderedBy</methodname> when creating the faceting
      request. The default value is
      <constant>FacetSortOrder.COUNT_DESC</constant>, meaning facets are
      ordered by their count in descending order (highest count first).
      Other values are <constant>COUNT_ASC</constant>,
      <constant>FIELD_VALUE</constant> and
      <constant>RANGE_DEFINITION_ORDER</constant>.
      <constant>COUNT_ASC</constant> returns the facets in ascending count
      order whereas <constant>FIELD_VALUE</constant> will return them in
      alphabetical order of the facet/category value (see <xref
      linkend="section-interpreting-facet-result"/>).
      <constant>RANGE_DEFINITION_ORDER</constant> only applies for range
      faceting request and returns the facets in the same order in which the
      ranges are defined. For <xref linkend="example-range-faceting"/> this
      would mean the facet for the range of below 1000 would be returned
      first, followed by the facet for the range 1001 to 1500 and finally
      the facet for above 1500.</para>
    </section>

    <section id="section-applying-faceting-request">
      <title>Applying a faceting request</title>

      <para>In <xref linkend="section-creating-faceting-request"/> we have
      seen how to create a faceting request. Now it is time to apply it on a
      query. The key is the <classname>FacetManager</classname> which can be
      retrieved via the <classname>FullTextQuery</classname> (see <xref
      linkend="example-applying-faceting"/>).</para>

      <example id="example-applying-faceting">
        <title>Applying a faceting request</title>

        <programlisting language="JAVA" role="JAVA">// create a fulltext query
Query luceneQuery = builder.all().createQuery(); // match all query
FullTextQuery fullTextQuery = fullTextSession.createFullTextQuery(luceneQuery, Cd.class);

// retrieve facet manager and apply faceting request
FacetManager facetManager = fullTextQuery.getFacetManager();
facetManager.enableFaceting(priceFacetingRequest);

// get the list of Cds 
List&lt;Cd&gt; cds = fullTextQuery.list();
...

// retrieve the faceting results
List&lt;Facet&gt; facets = facetManager.getFacets("priceFaceting");
...</programlisting>
      </example>

      <para>You need to enable the faceting request before you execute the
      query. You do that via
      <methodname>facetManager.enableFaceting(&lt;facetName&gt;)</methodname>.
      You can enable as many faceting requests as you like, then you execute
      the query and retrieve the facet results for a given request via
      <methodname>facetManager.getFacets(&lt;facetname&gt;)</methodname>. For
      each request you will get a list of <classname>Facet</classname>
      instances. Facet requests stay active and get applied to the fulltext
      query until they are either explicitly disabled via
      <methodname>disableFaceting(&lt;facetName&gt;)</methodname> or the
      query is discarded.</para>
    </section>

    <section id="section-interpreting-facet-result">
      <title>Interpreting a <classname>Facet</classname> result</title>

      <para>Each facet request results in a list of
      <classname>Facet</classname> instances. Each instance represents one
      facet/category value. In the CD example (<xref
      linkend="example-discrete-faceting"/>) where we want to categorize on
      the Cd labels, there would for example be a <classname>Facet</classname>
      for each of the record labels Universal, Sony and Warner. <xref
      linkend="example-facet-api"/> shows the API of
      <classname>Facet</classname>.</para>

      <example id="example-facet-api">
        <title>Facet API</title>

        <programlisting language="JAVA" role="JAVA">public interface Facet {
    /**
     * @return the faceting name this {@code Facet} belongs to.
     *
     * @see org.hibernate.search.query.facet.FacetingRequest#getFacetingName()
     */
    String getFacetingName();

    /**
     * Return the {@code Document} field name this facet is targeting.
     * The field needs to be indexed with {@code Analyze.NO}.
     *
     * @return the {@code Document} field name this facet is targeting.
     */
    String getFieldName();

    /**
     * @return the value of this facet. In case of a discrete facet it is the actual
     *         {@code Document} field value. In case of a range query the value is a
     *         string representation of the range.
     */
    String getValue();

    /**
     * @return the facet count.
     */
    int getCount();

    /**
     * @return a Lucene {@link Query} which can be executed to retrieve all
     *         documents matching the value of this facet.
     */
    Query getFacetQuery();
}
</programlisting>
      </example>

      <para><methodname>getFacetingName()</methodname> and
      <methodname>getFieldName()</methodname> are returning the facet request
      name and the targeted document field name as specified by the underlying
      <classname>FacetRequest</classname>. For <xref
      linkend="example-discrete-faceting"/> that would be
      <constant>labelFacetRequest</constant> and <constant>label</constant>
      respectively. The interesting information is provided by
      <methodname>getValue()</methodname> and
      <methodname>getCount()</methodname>. The former is the actual
      facet/category value, for example a concrete record label like
      Universal. The latter returns the count for this value. To stick with
      the example again, the count value tells you how many Cds are released
      under the Universal label. Last but not least,
      <classname>getFacetQuery()</classname> returns a Lucene query which can
      be used to retrieve the entities counted in this facet.</para>
    </section>

    <section>
      <title>Restricting query results</title>

      <para>A common use case for faceting is a "drill-down" functionality
      which allows you to narrow your original search by applying a given
      facet on it. To do this, you can apply any of the returned
      <classname>Facet</classname>s as additional criteria on your original
      query via <classname>FacetSelection</classname>.
      <classname>FacetSelection</classname>s are available via the
      <classname>FacetManager</classname> and allow you to select a facet as
      query criteria (<methodname>selectFacets</methodname>), remove a facet
      restriction (<methodname>deselectFacets</methodname>), remove all facet
      restrictions (<methodname>clearSelectedFacets</methodname>) and retrieve
      all currently selected facets
      (<methodname>getSelectedFacets</methodname>). <xref
      linkend="example-restricting-query-results"/> shows an example.</para>

      <example id="example-restricting-query-results">
        <title>Restricting query results via the application of a
        <classname>FacetSelection</classname></title>

        <programlisting language="JAVA" role="JAVA">// create a fulltext query
Query luceneQuery = builder.all().createQuery(); // match all query
FullTextQuery fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery, clazz );

// retrieve facet manager and apply faceting request
FacetManager facetManager = fullTextQuery.getFacetManager();
facetManager.enableFaceting( priceFacetingRequest );

// get the list of Cd 
List&lt;Cd&gt; cds = fullTextQuery.list();
assertTrue(cds.size() == 10);

// retrieve the faceting results
List&lt;Facet&gt; facets = facetManager.getFacets( "priceFaceting" );
assertTrue(facets.get(0).getCount() == 2)

// apply first facet as additional search criteria
FacetSelection facetSelection = facetManager.getFacetGroup( "priceFaceting" );
facetSelection.selectFacets( facets.get( 0 ) );

// re-execute the query
cds = fullTextQuery.list();
assertTrue(cds.size() == 2);</programlisting>
      </example>
    </section>
  </section>

  <section>
    <title>Optimizing the query process</title>

    <para>Query performance depends on several criteria:</para>

    <itemizedlist>
      <listitem>
        <para>the Lucene query itself: read the literature on this
        subject.</para>
      </listitem>

      <listitem>
        <para>the number of loaded objects: use pagination and / or index
        projection (if needed).</para>
      </listitem>

      <listitem>
        <para>the way Hibernate Search interacts with the Lucene readers:
        defines the appropriate <xref
        linkend="search-architecture-readerstrategy"/>.</para>
      </listitem>

      <listitem>
        <para>caching frequently extracted values from the index: see <xref
        linkend="query-fieldcaches"/>.</para>
      </listitem>
    </itemizedlist>

    <section id="query-fieldcaches">
      <title>Caching index values: FieldCache</title>

      <para>The primary function of a Lucene index is to identify matches to
      your queries, still after the query is performed the results must be
      analyzed to extract useful information: typically Hibernate Search might
      need to extract the Class type and the primary key.</para>

      <para>Extracting the needed values from the index has a performance
      cost, which in some cases might be very low and not noticeable, but in
      some other cases might be a good candidate for caching.</para>

      <para>What is exactly needed depends on the kind of Projections being
      used (see <xref linkend="projections"/>), and in some cases the Class
      type is not needed as it can be inferred from the query context or other
      means.</para>

      <para>Using the @<classname>CacheFromIndex</classname> annotation you
      can experiment different kinds of caching of the main metadata fields
      required by Hibernate Search:</para>

      <programlisting language="JAVA" role="JAVA">
import static org.hibernate.search.annotations.FieldCacheType.CLASS;
import static org.hibernate.search.annotations.FieldCacheType.ID;

@Indexed
@CacheFromIndex( { CLASS, ID } )
public class Essay {
    ...

         </programlisting>

      <para>It is currently possible to cache Class types and IDs using this
      annotation:</para>

      <itemizedlist>
        <listitem>
          <para><constant>CLASS</constant>: Hibernate Search will use a Lucene
          FieldCache to improve peformance of the Class type extraction from
          the index.</para>

          <para>This value is enabled by default, and is what Hibernate Search
          will apply if you don't specify the
          @<classname>CacheFromIndex</classname> annotation.</para>
        </listitem>

        <listitem>
          <para><constant>ID</constant>: Extracting the primary identifier
          will use a cache. This is likely providing the best performing
          queries, but will consume much more memory which in turn might
          reduce performance.</para>
        </listitem>
      </itemizedlist>

      <note>
        <para>Measure the performance and memory consumption impact after
        warmup (executing some queries): enabling Field Caches is likely to
        improve performance but this is not always the case.</para>
      </note>

      <para>Using a FieldCache has two downsides to consider:</para>

      <itemizedlist>
        <listitem>
          <para>Memory usage: these caches can be quite memory hungry.
          Typically the CLASS cache has lower requirements than the ID
          cache.</para>
        </listitem>

        <listitem>
          <para>Index warmup: when using field caches, the first query on a
          new index or segment will be slower than when you don't have caching
          enabled.</para>
        </listitem>
      </itemizedlist>

      <para>With some queries the classtype won't be needed at all, in that
      case even if you enabled the <constant>CLASS</constant> field cache,
      this might not be used; for example if you are targeting a single class,
      obviously all returned values will be of that type (this is evaluated at
      each Query execution).</para>

      <para>For the ID FieldCache to be used, the ids of targeted entities
      must be using a <classname>TwoWayFieldBridge</classname> (as all
      builting bridges), and all types being loaded in a specific query must
      use the fieldname for the id, and have ids of the same type (this is
      evaluated at each Query execution).</para>
    </section>
  </section>
</chapter>
