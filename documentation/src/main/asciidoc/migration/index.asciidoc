= Hibernate Search {hibernateSearchVersion}: Migration Guide from {hibernateSearchPreviousStableVersionShort}
:doctype: book
:revdate: {docdate}
:sectanchors:
:anchor:
:toc: left
:toclevels: 4
:docinfodir: {docinfodir}
:docinfo: shared,private
:title-logo-image: image:hibernate_logo_a.png[align=left,pdfwidth=33%]

== Introduction

The aim of this guide is to assist you migrating
an existing application using any version `{hibernateSearchPreviousStableVersionShort}.x` of Hibernate Search
to the latest of the `{hibernateSearchVersionShort}.x` series.

NOTE: If you think something is missing or something does not work, please link:https://hibernate.org/community[contact us].

If you're looking to migrate from an earlier version,
you should migrate step-by-step, from one minor version to the next,
following the migration guide of link:https://hibernate.org/search/documentation/[each version].

[[recommended-procedure]]
== Recommended procedure

Search 6 introduces new APIs, so migrating older projects will be more work than usual.

To facilitate the process of migrating, Hibernate Search 6 includes a "migration helper" module
that allows you to use the Hibernate Search 5 APIs with Hibernate Search 6 and a Lucene backend under the hood.
However, this module does not offer full backward compatibility: for some features that changed dramatically,
it may not be possible to use the Search 5 APIs anymore.
See <<migration-helper>> for more information.

[NOTE]
====
For those who cannot afford to, or do not want to, spend the time required to migrate,
we intend to continue maintenance releases (= bugfixes) of Hibernate Search 5.x:
no end-of-life date has been set at the moment.
====

[[requirements]]
== Requirements

Hibernate Search 6 is still compatible with both JDK8 and JDK11.

The required versions of dependencies changed:

* The Hibernate ORM mapper now requires Hibernate ORM 5.4.4.Final or later
(5.4.3.Final and earlier won't work correctly).
* The Elasticsearch backend now requires Elasticsearch 5.6, 6.8 or 7.9.
* The Lucene backend now requires Lucene 8.6.

[[maven-coordinates]]
== Maven coordinates changes

If you pull Hibernate Search artifacts from a Maven repository and you come from Hibernate Search 5,
be aware that just bumping the version number will not be enough:

* the group IDs changed from `org.hibernate` to `org.hibernate.search`
* most of the artifact IDs changed to reflect the new mapper/backend design
* the Lucene integration now requires an explicit dependency instead of being pulled by the engine by default.

Read the link:{hibernateSearchDocUrl}#getting-started-dependencies[getting started guide, section "dependencies"]
for more information.

[[data-format]]
== Data format and schema changes

Indexes created with Hibernate Search 5 or earlier are not compatible with Hibernate Search 6.
This goes for embedded-Lucene indexes as well as Elasticsearch indexes.

In order to upgrade an application to Hibernate Search 6, all data must be reindexed.
See link:{hibernateSearchDocUrl}#mapper-orm-indexing-massindexer[the documentation of the `MassIndexer`]
for instructions.

Similarly, native queries/predicates/sorts targeting Hibernate Search 5 indexes
(e.g. manual instantiation of Lucene `Query` types, Elasticsearch JSON) may not work correctly
with Hibernate Search 6, because the underlying type of some fields may have changed.
To avoid that sort of problem in future major upgrades, we recommend you use the <<searching,Hibernate Search DSL>>
to create predicates and sorts,
so that Hibernate Search will automatically pick the right predicate/sort depending on the field type.

[[migration-helper]]
== Migration helper

=== Purpose

Hibernate Search 6 includes a temporary additional "migration helper" module
that provides partial compatibility with Hibernate Search 5 APIs backed by the Hibernate Search 6 implementations.

This module should make migration easier by making sure that code relying on the most-frequently-used APIs
(mapping annotations, search DSL, ...)
continues to compile and run.
The idea is to use the migration helper temporarily to make most of the application code (search queries, ...) work,
making it easier to focus on migrating configuration and to assess the effort required to migrate the remaining code.

[IMPORTANT]
====
The migration helper should not be used in production environments.

It has limitations preventing full compatibility with Hibernate Search 5,
and these limitations will never be addressed.

All APIs defined in the migration helper are deprecated and will be removed in the next major version
of Hibernate Search.
====

=== How to use the migration helper

To use the migration helper, add the following dependency to your project:

[source, XML, subs="+attributes"]
----
<dependency>
   <groupId>org.hibernate.search</groupId>
   <artifactId>hibernate-search-v5migrationhelper-orm</artifactId>
   <version>{hibernateSearchVersion}</version>
</dependency>
----

Then, try to recompile your application.
Compilation errors should point you to the most significant API changes that require your immediate attention;
most of the code that still compiles should work as it used to in Hibernate Search 5.

[NOTE]
====
The migration helper only addresses Java API compatibility.
This excludes in particular:

* Configuration properties: they must still be <<configuration,replaced with Search 6 properties>>.
* Data format: data must still be <<data-format,reindexed>>.
====

[[configuration]]
== Configuration changes

=== Basics

Most configuration properties changed in Hibernate Search 6.
In most cases it's only a matter of changing the prefix of a configuration property
(due to the different structure of Hibernate Search 6),
but in a few cases the relevant feature changed so much that a new approach was necessary for configuration.

For a quick introduction to the basics of configuration in Hibernate Search 6,
refer to the link:{hibernateSearchDocUrl}#getting-started-configuration[getting started guide, section "configuration"].

For more details,
see the link:{hibernateSearchDocUrl}#configuration[main "configuration" section of the reference documentation].

For a complete list of Hibernate Search 5 properties and their equivalent in Hibernate Search 6,
refer to the section below.

=== Constants for property keys

In Hibernate Search 5, constants for configuration property keys used to be provided through
`org.hibernate.search.cfg.Environment` and `org.hibernate.search.elasticsearch.cfg.ElasticsearchEnvironment`.

In Hibernate Search 6, constants are provided through classes whose name ends with `Settings`:

* `org.hibernate.search.engine.cfg.EngineSettings`
* `org.hibernate.search.engine.cfg.BackendSettings`
* `org.hibernate.search.engine.cfg.IndexSettings`
* `org.hibernate.search.mapper.orm.cfg.HibernateOrmMapperSettings`
* `org.hibernate.search.backend.lucene.cfg.LuceneBackendSettings`
* `org.hibernate.search.backend.lucene.cfg.LuceneIndexSettings`
* `org.hibernate.search.backend.elasticsearch.cfg.ElasticsearchBackendSettings`
* `org.hibernate.search.backend.elasticsearch.cfg.ElasticsearchIndexSettings`

=== Configuration property reference

Below is a list of Hibernate Search 5 properties in alphabetical order,
along with their equivalent in Hibernate Search 6.

[WARNING]
====
Index defaults are no longer specified using the prefix `hibernate.search.default.`,
and `hibernate.search.indexes.default.` will not work either.

To specify configuration to be applied by default to all indexes,
just set the configuration at the backend level using the prefix `hibernate.search.backend.`.
====

`hibernate.search.analyzer`::
No direct equivalent in Hibernate Search 6.
+
To override the default analyzer, define a custom analyzer named `default`.
See <<analysis-definition-provider>>.
`hibernate.search.autoregister_listeners`::
Hibernate Search 6 equivalent: `hibernate.search.enabled`.
`hibernate.search.batch_size`::
No direct equivalent in Hibernate Search 6.
+
This property was not documented in Hibernate Search 5.
For the specific use case of batch processes,
know that upon Hibernate ORM session flushes,
Hibernate Search 6 will automatically turn entities to documents
and hold documents in memory until the transaction commit.
+
See also link:{hibernateSearchDocUrl}#mapper-orm-indexing-manual[this section of the documentation].
`hibernate.search.default.elasticsearch.connection_timeout`::
Hibernate Search 6 equivalent: `hibernate.search.backend.connection_timeout`.
+
NOTE: Defaults to 1000 (1 second) in Hibernate Search 6 instead of 3 seconds in Hibernate Search 5.
More information https://in.relation.to/2020/09/07/hibernate-search-6-0-0-Beta10/#improved-timeouts[here].
`hibernate.search.default.elasticsearch.discovery.default_scheme`::
Hibernate Search 6 equivalent: `hibernate.search.backend.protocol`.
`hibernate.search.default.elasticsearch.discovery.enabled`::
Hibernate Search 6 equivalent: `hibernate.search.backend.discovery.enabled`.
`hibernate.search.default.elasticsearch.discovery.refresh_interval`::
Hibernate Search 6 equivalent: `hibernate.search.backend.discovery.refresh_interval`.
`hibernate.search.default.elasticsearch.dynamic_mapping`, `hibernate.search.<index-name>.elasticsearch.dynamic_mapping`::
Hibernate Search 6 equivalent (global defaults): `hibernate.search.backend.dynamic_mapping`.
+
Hibernate Search 6 equivalent (per-index): `hibernate.search.backend.indexes.<index-name>.dynamic_mapping`.
`hibernate.search.default.elasticsearch.host`::
Hibernate Search 6 equivalent: `hibernate.search.backend.hosts`.
+
IMPORTANT: In Hibernate Search 6, the URL scheme (`http://` or `https://`) must *not* be included here.
Instead, set the property `hibernate.search.backend.protocol` to either `http` (the default) or `https`.
`hibernate.search.default.elasticsearch.index_management_wait_timeout`, `hibernate.search.<index-name>.elasticsearch.index_management_wait_timeout`::
Hibernate Search 6 equivalent (global defaults): `hibernate.search.backend.schema_management.minimal_required_status_wait_timeout`.
+
Hibernate Search 6 equivalent (per-index): `hibernate.search.backend.indexes.<index-name>.schema_management.minimal_required_status_wait_timeout`.
`hibernate.search.default.elasticsearch.index_schema_management_strategy`, `hibernate.search.<index-name>.elasticsearch.index_schema_management_strategy`::
Hibernate Search 6 equivalent (global defaults): `hibernate.search.schema_management.strategy`.
+
Hibernate Search 6 equivalent (per-index): none.
+
Defaults to `create-or-validate` in Hibernate Search 6.
See link:{hibernateSearchDocUrl}#mapper-orm-schema-management-strategy[schema management].
+
There is no direct equivalent for the per-index variant in Hibernate Search 6:
automatic schema management is configured globally for all indexes, not on a per-index basis.
However, you can achieve more control by setting `hibernate.search.schema_management.strategy` to `none`
and link:{hibernateSearchDocUrl}#mapper-orm-schema-management-manager[managing the schema manually after startup].
`hibernate.search.default.elasticsearch.max_total_connection_per_route`::
Hibernate Search 6 equivalent: `hibernate.search.backend.max_connections_per_route`.
`hibernate.search.default.elasticsearch.max_total_connection`::
Hibernate Search 6 equivalent: `hibernate.search.backend.max_connections`.
`hibernate.search.default.elasticsearch.password`::
Hibernate Search 6 equivalent: `hibernate.search.backend.password`.
`hibernate.search.default.elasticsearch.path_prefix`::
No equivalent in Hibernate Search 6 link:{hibernateSearchJiraUrl}/HSEARCH-4051[yet].
`hibernate.search.default.elasticsearch.read_timeout`::
Hibernate Search 6 equivalent: `hibernate.search.backend.read_timeout`.
+
NOTE: Defaults to 30000 (30 seconds) in Hibernate Search 6 instead of 60 seconds in Hibernate Search 5.
More information https://in.relation.to/2020/09/07/hibernate-search-6-0-0-Beta10/#improved-timeouts[here].
`hibernate.search.default.elasticsearch.refresh_after_write`, `hibernate.search.<index-name>.elasticsearch.refresh_after_write`::
Hibernate Search 6 equivalent (global defaults): `hibernate.search.automatic_indexing.synchronization.strategy`.
+
Hibernate Search 6 equivalent (per-index): none.
+
Setting `hibernate.search.automatic_indexing.synchronization.strategy` to `read-sync` or `sync` will produce results
similar to setting `hibernate.search.default.elasticsearch.refresh_after_write` to `true`.
See link:{hibernateSearchDocUrl}#mapper-orm-indexing-automatic-synchronization[automatic indexing synchronization]
for more information.
+
There is no equivalent for the per-index variant in Hibernate Search 6:
the synchronization strategy can only be set globally, not on a per-index basis.
`hibernate.search.default.elasticsearch.request_timeout`::
Hibernate Search 6 equivalent: `hibernate.search.backend.request_timeout`.
+
NOTE: Defaults to no timeout in Hibernate Search 6.
More information https://in.relation.to/2020/09/07/hibernate-search-6-0-0-Beta10/#improved-timeouts[here].
`hibernate.search.default.elasticsearch.required_index_status`, `hibernate.search.<index-name>.elasticsearch.required_index_status`::
Hibernate Search 6 equivalent (global defaults): `hibernate.search.backend.schema_management.minimal_required_status`.
+
Hibernate Search 6 equivalent (per-index): `hibernate.search.backend.indexes.<index-name>.schema_management.minimal_required_status`.
`hibernate.search.default.elasticsearch.username`::
Hibernate Search 6 equivalent: `hibernate.search.backend.username`.
`hibernate.search.default.exclusive_index_use`, `hibernate.search.<index-name>.exclusive_index_use`::
No equivalent in Hibernate Search 6.
`hibernate.search.default.indexBase`, `hibernate.search.<index-name>.indexBase`::
Hibernate Search 6 equivalent (global defaults): `hibernate.search.backend.directory.root`.
+
Hibernate Search 6 equivalent (per-index): `hibernate.search.backend.indexes.<index-name>.directory.root`.
`hibernate.search.default.indexName`, `hibernate.search.<index-name>.indexName`::
No equivalent in Hibernate Search 6.
+
The name of an index can still be customized in the mapping, using `@Indexed(name = ...)`,
or with the <<mapping-programmatic,programmatic>> equivalent.
`hibernate.search.default.index_flush_interval`, `hibernate.search.<index-name>.index_flush_interval`::
Hibernate Search 6 equivalent (global defaults): `hibernate.search.backend.io.commit_interval`.
+
Hibernate Search 6 equivalent (per-index): `hibernate.search.backend.indexes.<index name>.io.commit_interval`.
`hibernate.search.default.index_metadata_complete`, `hibernate.search.<index-name>.index_metadata_complete`::
No equivalent in Hibernate Search 6.
+
This property was not documented in Hibernate Search 5.
`hibernate.search.default.indexmanager`, `hibernate.search.<index-name>.indexmanager`::
Hibernate Search 6 equivalent (global defaults): `hibernate.search.backend.type`.
+
Hibernate Search 6 equivalent (per-index): none.
+
Setting the backend type (`elasticsearch` or `lucene`) should no longer be necessary:
it will be picked automatically if there is only one backend type available in the classpath.
+
If you have multiple backend types available in the classpath for some reason,
but only want to use one, set `hibernate.search.backend.type` to either `lucene` or `elasticsearch`.
+
If you need both a Lucene backend and an Elasticsearch backend, proceed as follows:

* Annotate entities that must be indexed in the Elasticsearch backend with `@Indexed(backend = "elasticsearch")`.
* Annotate entities that must be indexed in the Lucene backend with `@Indexed(backend = "lucene")`.
* Configure two separate backends in your configuration properties:
** prefix properties of the Elasticsearch backend with
`hibernate.search.backends.elasticsearch.` instead of `hibernate.search.backend.`.
** prefix properties of the Lucene backend with
`hibernate.search.backends.lucene.` instead of `hibernate.search.backend.`.
** same goes for indexes,
e.g. `hibernate.search.backends.elasticsearch.indexes.<index-name>.someProperty`
for indexes of the Elasticsearch backend
or `hibernate.search.backends.lucene.indexes.<index-name>.someProperty`
for indexes of the Lucene backend.
`hibernate.search.default.indexwriter.*`, `hibernate.search.<index-name>.indexwriter.*`::
Hibernate Search 6 equivalent (global defaults): `hibernate.search.backend.io.writer.*` or `hibernate.search.backend.io.merge.*`.
+
Hibernate Search 6 equivalent (per-index): `hibernate.search.backend.indexes.<index-name>.io.writer.*` or `hibernate.search.backend.indexes.<index-name>.io.merge.*`.
+
The writer settings and merge settings are now split.
See link:{hibernateSearchDocUrl}#backend-lucene-io-writer[here for available writer settings]
and link:{hibernateSearchDocUrl}#backend-lucene-io-merge[here for available merge settings].
`hibernate.search.default.locking_strategy`, `hibernate.search.<index-name>.locking_strategy`::
Hibernate Search 6 equivalent (global defaults): `hibernate.search.backend.directory.locking.strategy`.
+
Hibernate Search 6 equivalent (per-index): `hibernate.search.backend.indexes.<index-name>.directory.locking.strategy`.
+
See link:{hibernateSearchDocUrl}#backend-lucene-configuration-directory-locking-strategy[here for available locking strategies].
`hibernate.search.default.max_queue_length`, `hibernate.search.<index-name>.max_queue_length`::
Hibernate Search 6 equivalent (global defaults): `hibernate.search.backend.indexing.queue_size`.
+
Hibernate Search 6 equivalent (per-index): `hibernate.search.backend.indexes.<index-name>.indexing.queue_size`.
+
IMPORTANT: In Hibernate Search 6, there are multiple queues per index, enabling parallel indexing of documents.
See link:{hibernateSearchDocUrl}#backend-lucene-indexing-queues[here for Lucene]
or link:{hibernateSearchDocUrl}#backend-elasticsearch-indexing-queues[here for Elasticsearch].
`hibernate.search.default_null_token`::
No equivalent in Hibernate Search 6.
+
In most cases, you <<field-indexnullas,won't need to use `indexNullAs` anymore>>.
Where `indexNullAs` is still needed, define the token explicitly for each index field.
`hibernate.search.default.reader.*`, `hibernate.search.<index-name>.reader.*`::
No direct equivalent in Hibernate Search 6.
+
To enable async reader refresh, set `hibernate.search.backend.io.refresh_interval` or
`hibernate.search.backend.indexes.<index-name>.io.refresh_interval`
to a strictly positive value (in milliseconds).
See link:{hibernateSearchDocUrl}#backend-lucene-io-refresh[here for more information].
+
Custom reader strategies are no longer supported.
`hibernate.search.default.retry_marker_lookup`, `hibernate.search.<index-name>.retry_marker_lookup`::
No equivalent in Hibernate Search 6: <<search-5-backends,the `filesystem-slave` backend is no longer supported>>.
`hibernate.search.default.similarity`, `hibernate.search.<index-name>.similarity`::
No direct equivalent in Hibernate Search 6: the similarity is configured through the <<analysis-definition-provider,analysis configurer>>.
`hibernate.search.default.worker.backend`, `hibernate.search.<index-name>.worker.backend`::
No equivalent in Hibernate Search 6: <<search-5-backends,the JMS/JGroups/`filesystem-slave`/`filesystem-master`/`infinispan` backends are no longer supported>>.
`hibernate.search.default.worker.execution`, `hibernate.search.<index-name>.worker.execution`::
No direct equivalent in Hibernate Search 6.
+
Setting `hibernate.search.automatic_indexing.synchronization.strategy` to `async` or `sync` will produce results
similar to setting `hibernate.search.<index-name>.worker.execution` to the same value.
See link:{hibernateSearchDocUrl}#mapper-orm-indexing-automatic-synchronization[automatic indexing synchronization]
for more information.
`hibernate.search.default.worker.*`, `hibernate.search.<index-name>.worker.*`::
No equivalent in Hibernate Search 6: <<search-5-backends,the JMS/JGroups/`filesystem-slave`/`filesystem-master`/`infinispan` backends are no longer supported>>.
`hibernate.search.elasticsearch.analysis_definition_provider`::
Hibernate Search 6 equivalent: `hibernate.search.backend.analysis.configurer`.
+
IMPORTANT: A different interface should be implemented: see <<analysis-definition-provider>>.
`hibernate.search.elasticsearch.log.json_pretty_printing`::
Hibernate Search 6 equivalent: `hibernate.search.backend.log.json_pretty_printing`.
`hibernate.search.elasticsearch.scroll_backtracking_window_size`::
No equivalent in Hibernate Search 6: scrolling is forward-only.
`hibernate.search.elasticsearch.scroll_fetch_size`::
No direct equivalent in Hibernate Search 6.
+
When using Hibernate Search APIs, the "chunk size" is an argument to the
link:{hibernateSearchDocUrl}#search-dsl-query-fetching-results-scrolling[`scroll` method].
When using the link:{hibernateSearchDocUrl}#search-dsl-query-object[Hibernate ORM or JPA adapters],
the "chunk size" is set to the same value as the link:{hibernateSearchDocUrl}#search-dsl-query-fetch-size[fetch size].
`hibernate.search.elasticsearch.scroll_timeout`::
Hibernate Search 6 equivalent: `hibernate.search.backend.scroll_timeout`.
`hibernate.search.enable_dirty_check`::
Hibernate Search 6 equivalent: `hibernate.search.automatic_indexing.enable_dirty_check`.
`hibernate.search.error_handler`::
Hibernate Search 6 equivalent: `hibernate.search.background_failure_handler`.
+
IMPORTANT: A different interface should be implemented: see <<error-handler>>.
`hibernate.search.filter.cache_docidresults.size`::
No equivalent in Hibernate Search 6. See <<full-text-filter>>.
`hibernate.search.filter.cache_strategy`::
No equivalent in Hibernate Search 6. See <<full-text-filter>>.
`hibernate.search.generate_statistics`::
No equivalent in Hibernate Search 6. See <<statistics>>.
`hibernate.search.index_uninverting_allowed`::
Index uninverting was deprecated in Hibernate Search 5 due to poor performance and is no longer allowed.
All index fields that you want to sort on must be <<sortablefield,marked as sortable>>.
`hibernate.search.indexing_strategy`::
Hibernate Search 6 equivalent: `hibernate.search.automatic_indexing.strategy`.
+
Set to `none` to get the equivalent of `hibernate.search.indexing_strategy = manual` in Hibernate Search 5.
`hibernate.search.jmx_bean_suffix`::
No equivalent in Hibernate Search 6. See <<jmx>>.
`hibernate.search.jmx_enabled`::
No equivalent in Hibernate Search 6. See <<jmx>>.
`hibernate.search.lucene.analysis_definition_provider`::
Hibernate Search 6 equivalent: `hibernate.search.backend.analysis.configurer`.
+
IMPORTANT: A different interface should be implemented: see <<analysis-definition-provider>>.
`hibernate.search.lucene_version`::
Hibernate Search 6 equivalent: `hibernate.search.backend.lucene_version`.
`hibernate.search.model_mapping`::
Hibernate Search 6 equivalent: `hibernate.search.mapping.configurer`.
+
IMPORTANT: A different interface should be implemented: see <<mapping-programmatic>>.
`hibernate.search.query.database_retrieval_method`::
No equivalent in Hibernate Search 6: entities are always loaded with a query.
`hibernate.search.query.object_lookup_method`::
Hibernate Search 6 equivalent: `hibernate.search.query.loading.cache_lookup.strategy`.
+
See link:{hibernateSearchDocUrl}#search-dsl-query-cache-lookup-strategy[this section of the documentation].
`hibernate.search.similarity`::
No direct equivalent in Hibernate Search 6: the similarity is configured through the <<analysis-definition-provider,analysis configurer>>.
`hibernate.search.worker.*`::
No equivalent to the concept of "worker" in Hibernate Search 6:
* automatic indexing is link:{hibernateSearchDocUrl}#mapper-orm-indexing-automatic-concepts[always performed on transaction commit or,
when there is no transaction, on session flush].
* <<search-5-backends,transactional backends, for example the JMS backend, are no longer supported>>.

[[jmx]]
=== JMX

TODO

[[search-5-backends]]
=== Backends

TODO

[[api]]
== API changes

A lot of APIs changed. We recommend having a look at
link:{hibernateSearchDocUrl}#getting-started[the getting started guide] before migrating.

[[mapping-annotation]]
=== Annotation mapping

[[analyzer]]
==== `@Analyzer`

In Hibernate Search 5, it was possible to apply an `@Analyzer` annotation to a class or property,
so that the corresponding analyzer would be used by default for any index field declared in this scope.

There is no equivalent to that feature in Hibernate Search 6:
all fields must specify their analyzer explicitly using `@FullTextField(analyzer = "myAnalyzer")`,
or rely on the (global) default analyzer.

Also, still in Hibernate Search 5, `@Analyzer` could point directly to a class extending `org.apache.lucene.analysis.Analyzer`,
for example with `@Analyzer(impl = StandardAnalyzer.class)`.

This is no longer possible: analyzers are now always referenced by their name.
However, you can assign a name to a given analyzer instance using
the link:{hibernateSearchDocUrl}#backend-lucene-analysis-analyzers[Lucene analysis configurer].

[[analyzerdef]]
==== `@AnalyzerDef`, `@AnalyzerDefs`

Annotation-based analyzer definitions are no longer supported.

Instead, implement an analysis configurer:
see link:{hibernateSearchDocUrl}#backend-lucene-analysis-analyzers[here for Lucene],
or link:{hibernateSearchDocUrl}#backend-elasticsearch-analysis-analyzers[here for Elasticsearch].

[[analyzerdiscriminator]]
==== `@AnalyzerDiscriminator`

`@AnalyzerDiscriminator` has no direct equivalent in Hibernate Search 6:
the analyzer assigned to each field is static and cannot change at runtime,
because that results in unreliable matches and in scoring issues.

Instead, Hibernate Search 6 allows declaring multiple index fields for a single property,
and putting the content of that property in a different field depending on a discriminator.
Then, when searching, you can target all fields at once.

See link:{hibernateSearchDocUrl}#mapper-orm-alternatives[Mapping multiple alternatives].

[[boost]]
==== `@Boost`

Index-time boosting was deprecated in Hibernate Search 5.
It is no longer available in Hibernate Search 6.

Instead, rely on link:{hibernateSearchDocUrl}#search-dsl-predicate-common-boost[query-time boosting].

[[cachefromindex]]
==== `@CacheFromIndex`

This annotation was deprecated and non-functional in Hibernate Search 5.
It is no longer available in Hibernate Search 6.

[[calendarbridge]]
==== `@CalendarBridge`

`@CalendarBridge` is not necessary to index `Calendar` values:
you can simply apply `@GenericField` to a property of type `Calendar`,
and an appropriate default bridge will be used.

The main purpose of `@CalendarBridge` in Hibernate Search 5 was to provide the ability
to "truncate" calendars upon indexing, e.g. zeroing out all data more precise than the day
with `@CalendarBridge(resolution = Resolution.DAY)`.

For such use case, the recommended approach in Hibernate Search 6 is to index values with full resolution
(not using `@CalendarBridge`) and to control resolution when searching,
with a link:{hibernateSearchDocUrl}#search-dsl-predicate-range[`range` predicate].
Note that you can pass `ZonedDateTime` values to the predicate, which are much easier to truncate manually.
For example, to match only documents whose calendar is within a given day:

[source, JAVA]
----
Calendar toMatch = /* ... */;
ZonedDateTime toMatchZonedDateTime = ( (GregorianCalendar) toMatch ).toZonedDateTime();
ZonedDateTime dayStart = toMatchZonedDateTime.truncatedTo( ChronoUnit.DAYS );
ZonedDateTime nextDayStart = dayStart.plus( 1, ChronoUnit.DAYS );

List<MyEntity> hits = searchSession.search( MyEntity.class )
        .where( f -> f.range().field( "calendar" )
                .range( Range.canonical( dayStart, nextDayStart ), ValueConvert.NO )
        .fetchHits( 20 );
----

If that approach doesn't work for you, link:https://hibernate.org/community[let us know] and we'll try to come up with a solution together.

[[charfilterdef]]
==== `@CharFilterDef`

See <<analyzerdef>> or <<normalizerdef>>.

[[classbridge]]
==== `@ClassBridge`, `@ClassBridges`

See <<bridges>>.

[[containedin]]
==== `@ContainedIn`

`@ContainedIn` is no longer necessary in Hibernate Search 6.

Hibernate Search 6 infers indexing dependencies from the mapping,
and raises errors at bootstrap when the equivalent of `@ContainedIn` cannot be applied automatically
(for example an `@IndexedEmbedded` association with no inverse side).

The error message includes potential solutions. It looks like this:

> Cannot find the inverse side of the association on type 'MyIndexedType' at path '.myIndexedEmbedded<no value extractors>'
> Hibernate Search needs this information in order to reindex 'MyIndexedType' when 'MyIndexedEmbeddedType' is modified.
> You can solve this error by defining the inverse side of this association,
> either with annotations specific to your integration (`@OneToMany(mappedBy = ...)` in Hibernate ORM)
> or with the Hibernate Search `@AssociationInverseSide` annotation.
> Alternatively, if you do not need to reindex 'MyIndexedType' when 'MyIndexedEmbeddedType' is modified,
> you can disable automatic reindexing with `@IndexingDependency(reindexOnUpdate = ReindexOnUpdate.SHALLOW)`.

Thus, the recommended approach when migrating is to simply remove all `@ContainedIn` annotations,
then deal with the bootstrap errors, if any.

TIP: Hibernate Search 6 is able to raise multiple mapping errors during a single startup,
so you don't have to restart the application 20 times to address 20 different problems.

[[datebridge]]
==== `@DateBridge`

`@DateBridge` is not necessary to index `Date` values:
you can simply apply `@GenericField` to a property of type `java.util.Date`, `java.sql.Date`, `java.sql.Time` or `java.sql.Timestamp`,
and an appropriate default bridge will be used.

The main purpose of `@DateBridge` in Hibernate Search 5 was to provide the ability
to "truncate" dates upon indexing, e.g. zeroing out all data more precise than the day
with `@DateBridge(resolution = Resolution.DAY)`.

For such use case, the recommended approach in Hibernate Search 6 is to index values with full resolution
(not using `@DateBridge`) and to control resolution when searching,
with a link:{hibernateSearchDocUrl}#search-dsl-predicate-range[`range` predicate].
Note that you can pass `Instant` values to the predicate, which are much easier to truncate manually.
For example, to match only documents whose date is within a given day:

[source, JAVA]
----
Date toMatch = /* ... */;
ZoneId userZoneId = /* ... */;
ZonedDateTime toMatchZonedDateTime = Instant.ofEpochMilli( toMatch.getTime() ).atZone( userZoneId );
ZonedDateTime dayStart = toMatchZonedDateTime.truncatedTo( ChronoUnit.DAYS );
ZonedDateTime nextDayStart = dayStart.plus( 1, ChronoUnit.DAYS );

List<MyEntity> hits = searchSession.search( MyEntity.class )
        .where( f -> f.range().field( "date" )
                .range( Range.canonical( dayStart.toInstant(), nextDayStart.toInstant() ),
                        ValueConvert.NO )
        .fetchHits( 20 );
----

If that approach doesn't work for you, link:https://hibernate.org/community[let us know] and we'll try to come up with a solution together.

[[documentid]]
==== `@DocumentId`

`@DocumentId` is still available in Hibernate Search 6, but moved to a different package:
`org.hibernate.search.mapper.pojo.mapping.definition.annotation.DocumentId`.

However, it no longer exposes a `name` attribute,
because <<document-id-is-not-a-field,the document ID is no longer an index field>>,
and thus it does not need a name.

[[dynamicboost]]
==== `@DynamicBoost`

Index-time boosting was deprecated in Hibernate Search 5.
It is no longer available in Hibernate Search 6.

Instead, rely on link:{hibernateSearchDocUrl}#search-dsl-predicate-common-boost[query-time boosting].

[[facet]]
==== `@Facet`, `@Facets`

===== Basics

Facets are now called aggregations, which are a generalization of the concept of faceting.

To make a field aggregable, just set the `@*Field.aggregable` attribute to `Aggregable.YES`:

[source, JAVA]
----
@KeywordField(aggregable = Aggregable.YES)
private String myKeyword;
@GenericField(aggregable = Aggregable.YES)
private Integer myInteger;
@GenericField(aggregable = Aggregable.YES)
private LocalDate myLocalDate;
----

[NOTE]
====
An aggregable `@KeywordField` with a normalizer will return normalized values in aggregations,
whereas Hibernate Search 5 used to return raw (non-normalized) values.

See <<faceting-strings-are-normalized>>.
====

[NOTE]
====
`aggregable` is not available on `@FullTextField`,
because aggregation on a tokenized field would aggregate tokens instead of field values,
which is rarely the intent.

If you need both an analyzer and aggregations on the same property, create two separate fields:

[source, JAVA]
----
@FullTextField
@KeywordField(name = "category_aggregation", aggregable = Aggregable.YES)
private String category;
----

For instructions on how to execute aggregations, see <<searching-facet>>.

This will lead to two separate fields being created in the index, for the same property.
Just make sure to use the correct field name when searching:
`category` when creating link:{hibernateSearchDocUrl}#search-dsl-predicate-match[predicates],
but `category_aggregation` when creating link:{hibernateSearchDocUrl}#search-dsl-aggregation-terms[aggregations].
====

===== `@Facet.encoding`

The facet encoding options no longer exists:
strings will be indexed as strings and numbers will be indexed as numbers.

For the few cases where encoding a number as a string is necessary,
you can define a separate field exclusively for aggregations,
and apply a link:{hibernateSearchDocUrl}#mapper-orm-bridge-valuebridge[custom value bridge]
to convert the number to a string (and back).

[[field]]
==== `@Field`, `@Fields`

[[field-basics]]
===== Basics

The `@Field` annotation was split into multiple annotations, specific to each field type:

* `org.hibernate.search.mapper.pojo.mapping.definition.annotation.FullTextField`
* `org.hibernate.search.mapper.pojo.mapping.definition.annotation.KeywordField`
* `org.hibernate.search.mapper.pojo.mapping.definition.annotation.GenericField`

Here is a quick reference of how to convert a `@Field` annotation to Hibernate Search 6:

[cols="a,2a,2a",options="header"]
|====
|Property type|Hibernate Search 5|Hibernate Search 6
.5+|`String`, `Character`, `char`, enum|
[source, JAVA]
----
@Field
----
|[source, JAVA]
----
@FullTextField
----
|[source, JAVA]
----
@Field(analyzer = @Analyzer(definition = "myAnalyzer"))
----
.2+|[source, JAVA]
----
@FullTextField(analyzer = "myAnalyzer")
----
|[source, JAVA]
----
@Field
@Analyzer(definition = "myAnalyzer")
----
|[source, JAVA]
----
@Field(normalizer = @Normalizer(definition = "myNormalizer"))
----
|[source, JAVA]
----
@KeywordField(normalizer = "myNormalizer")
----
|[source, JAVA]
----
@Field(analyze = analyze.NO)
----
|[source, JAVA]
----
@KeywordField
// OR
@GenericField
----
.2+|Other
|[source, JAVA]
----
@Field
@NumericField
----
|[source, JAVA]
----
@GenericField
----
|[source, JAVA]
----
@Field
----
|[source, JAVA]
----
@GenericField
----
|====

[[field-analyze]]
===== `@Field.analyze`

`@Field.analyze` has no direct equivalent in Hibernate Search 6.
Instead of enabling/disabling analysis explicitly,
<<field-basics,pick the right `@*Field` annotation according to your needs>>.

[[field-analyzer]]
===== `@Field.analyzer`

See <<field-basics>>.

[[field-boost]]
===== `@Field.boost`

Index-time boosting was deprecated in Hibernate Search 5.
It is no longer available in Hibernate Search 6.

Instead, rely on link:{hibernateSearchDocUrl}#search-dsl-predicate-common-boost[query-time boosting].

[[field-bridge]]
===== `@Field.bridge`

See <<bridges>>.

[[field-index]]
===== `@Field.index`

`@Field.index` is now `@*Field.searchable`:

[cols="a,a",options="header"]
|====
|Hibernate Search 5|Hibernate Search 6
|[source, JAVA]
----
@Field(index = Index.YES)
----
|[source, JAVA]
----
@GenericField(searchable = Searchable.YES)
// OR
@FullTextField(searchable = Searchable.YES)
// OR
@KeywordField(searchable = Searchable.YES)
----
|[source, JAVA]
----
@Field(index = Index.NO)
----
|[source, JAVA]
----
@GenericField(searchable = Searchable.NO)
// OR
@FullTextField(searchable = Searchable.NO)
// OR
@KeywordField(searchable = Searchable.NO)
----
|====

[[field-indexnullas]]
===== `@Field.indexNullAs`

`@Field.indexNullAs` is still available for most Hibernate Search 6's `@*Field` annotations:

[cols="a,a",options="header"]
|====
|Hibernate Search 5|Hibernate Search 6
|[source, JAVA]
----
@Field(indexNullAs = "_null_")
----
|[source, JAVA]
----
@GenericField(indexNullAs = "_null_")
// OR
@KeywordField(indexNullAs = "_null_")
----
|====

However:

* You should consider whether it is really necessary,
as the new link:{hibernateSearchDocUrl}#search-dsl-predicate-exists[`exists` predicate]
introduced in Hibernate Search 6 allows finding documents where a field is present or not
*without* relying on `indexNullAs`.
* `indexNullAs` is not available on `@FullTextField`.
* The default null token is no longer supported, i.e. `Field.DEFAULT_NULL_TOKEN` has no equivalent in Hibernate search 6.
Each field that requires `indexNullAs` must have its value set explicitly.
* The (text) value passed to `indexNullAs` must be link:{hibernateSearchDocUrl}#mapper-orm-directfieldmapping-supported-types[formatted according to the type of the field].

[[field-name]]
===== `@Field.name`

`@Field.name` stays the same in Hibernate Search 6's `@*Field` annotations:

[cols="a,a",options="header"]
|====
|Hibernate Search 5|Hibernate Search 6
|[source, JAVA]
----
@Field(name = "myField")
----
|[source, JAVA]
----
@GenericField(name = "myField")
// OR
@FullTextField(name = "myField")
// OR
@KeywordField(name = "myField")
----
|====

[[field-normalizer]]
===== `@Field.normalizer`

See <<field-basics>>.

[[field-norms]]
===== `@Field.norms`

`@Field.norms` only has an equivalent in Hibernate Search 6's `@FullTextField` and `@KeywordField`.
The `Norms` enum has moved to `org.hibernate.search.engine.backend.types.Norms`.

[[field-store]]
===== `@Field.store`

`@Field.store` is now `@*Field.projectable`:

[cols="a,a",options="header"]
|====
|Hibernate Search 5|Hibernate Search 6
|[source, JAVA]
----
@Field(store = Store.YES)
----
|[source, JAVA]
----
@GenericField(projectable = Projectable.YES)
// OR
@FullTextField(projectable = Projectable.YES)
// OR
@KeywordField(projectable = Projectable.YES)
----
|[source, JAVA]
----
@Field(store = Store.NO)
----
|[source, JAVA]
----
@GenericField(projectable = Projectable.NO)
// OR
@FullTextField(projectable = Projectable.NO)
// OR
@KeywordField(projectable = Projectable.NO)
----
|[source, JAVA]
----
@Field(store = Store.COMPRESS)
----
|No direct equivalent; use `Projectable.YES`.

See also link:{hibernateSearchJiraUrl}/HSEARCH-3081[HSEARCH-3081].
|====

[[field-termVector]]
===== `@Field.termVector`

`@Field.termVector` only has an equivalent in Hibernate Search 6's `@FullTextField`.
The `TermVector` enum has moved to `org.hibernate.search.engine.backend.types.TermVector`.

[[fieldbridge]]
==== `@FieldBridge`

See <<bridges>>.

[[fulltextfilterdef]]
==== `@FullTextFilterDef`, `@FullTextFilterDefs`

Full-text filters have no direct equivalent in Hibernate Search 6.

See <<full-text-filter>>.

[[indexed]]
==== `@Indexed`

===== Basics

`@Indexed` is still available in Hibernate Search 6, but moved to a different package:
`org.hibernate.search.mapper.pojo.mapping.definition.annotation.Indexed`.

NOTE: In Hibernate Search 6, <<index-name-defaults-to-entity-name,index names default to the entity name, not the class name>>.

NOTE: In Hibernate Search 6, <<indexed-is-inherited,`@Indexed` is inherited>>.

===== `@Indexed.index`

`@Indexed.index` stays the same in Hibernate Search 6.

===== `@Indexed.interceptor`

Entity indexing interceptors have no direct equivalent in Hibernate Search 6,
but conditional indexing can be implemented through routing bridges.

See <<entity-indexing-interceptors>>.

[[indexedembeded]]
==== `@IndexedEmbedded`

===== Basics

`@IndexedEmbedded` is still available in Hibernate Search 6, but moved to a different package:
`org.hibernate.search.mapper.pojo.mapping.definition.annotation.IndexedEmbedded`.

===== `@IndexedEmbedded.depth`

`@IndexedEmbedded.depth` was renamed to `includeDepth` in Hibernate Search 6:

[cols="a,a",options="header"]
|====
|Hibernate Search 5|Hibernate Search 6
|[source, JAVA]
----
@IndexedEmbedded(depth = 2)
----
|[source, JAVA]
----
@IndexedEmbedded(includeDepth = 2)
----
|[source, JAVA]
----
@IndexedEmbedded(depth = 1, includePaths = {"foo.bar", "foo.bar2"})
----
|[source, JAVA]
----
@IndexedEmbedded(includeDepth = 1, includePaths = {"foo.bar", "foo.bar2"})
----
|====

===== `@IndexedEmbedded.includePaths`

`@IndexedEmbedded.includePaths` stays the same in Hibernate Search 6.

However, the document id of other entities is no longer a field by default,
so you can no longer use `@IndexedEmbedded(includePaths = "id")` (for example)
to embed another entity's ID, unless you explicitly add a `@GenericField` annotation on the id property.
See <<document-id-is-not-a-field>> for more information.

===== `@IndexedEmbedded.prefix`

`@IndexedEmbedded.prefix` is still available in Hibernate Search 6, but is deprecated for removal in the next major version.

You should use `@IndexedEmbedded.name` instead,
which doesn't prepend a prefix to the embedded fields, but instead creates an object field with the given name:

[cols="a,a",options="header"]
|====
|Hibernate Search 5|Hibernate Search 6
|[source, JAVA]
----
@IndexedEmbedded(prefix = "foo.")
----
|[source, JAVA]
----
@IndexedEmbedded(name = "foo")
----
|[source, JAVA]
----
@IndexedEmbedded(prefix = "foo.bar.")
----
|WARNING: No equivalent: `name` only allows one object field.
|[source, JAVA]
----
@IndexedEmbedded(prefix = "foo_")
----
.2+|WARNING: No equivalent: `name` does not allow prefixes to be prepended to embedded field names.
|[source, JAVA]
----
@IndexedEmbedded(prefix = "foo.bar_")
----
|====

===== `@IndexedEmbedded.targetElement`

`@IndexedEmbedded.targetElement` was renamed to `targetType` in Hibernate Search 6:

[cols="a,a",options="header"]
|====
|Hibernate Search 5|Hibernate Search 6
|[source, JAVA]
----
@IndexedEmbedded(targetElement = MyConcreteEntity.class)
----
|[source, JAVA]
----
@IndexedEmbedded(targetType = MyConcreteEntity.class)
----
|====

===== `@IndexedEmbedded.indexNullAs`

`@IndexedEmbedded.indexNullAs` has no equivalent in Hibernate Search 6.

To search for documents where an object field is present (or absent),
use the link:{hibernateSearchDocUrl}#search-dsl-predicate-exists[`exists` predicate].

===== `@IndexedEmbedded.includeEmbeddedObjectId`

`@IndexedEmbedded.includeEmbeddedObjectId` stays the same in Hibernate Search 6.

However, embedded IDs of numeric or date/time types (`Integer`, `Long`, `Date`, ...)
used to be indexed as string values by default in Hibernate Search 5,
but are indexed as numeric values by default in Hibernate Search 6.
See <<more-numeric-by-default>>.

===== Using `@IndexedEmbedded` to request container extraction

A little-known and undocumented feature of `@IndexedEmbedded` was to combine it with `@Field`
on a property of a container type (`Collection`, `List`, `Map`, ...) to instruct Hibernate Search to apply `@Field` to the container elements
instead of the container.

For example, the code below would lead to a bootstrap failure, because there is no default bridge for the `List` type:

[source, JAVA]
----
@Field
@ElementCollection
private List<String> notes;
----

However, the code below would work just fine,
and would instruct Hibernate Search to index each element of the `List` in the `notes` index field:

[source, JAVA]
----
@Field
@IndexedEmbedded
@ElementCollection
private List<String> notes;
----

In Hibernate Search 6, `@IndexedEmbedded` should no longer be used this way,
as the container extraction is now implied:

[source, JAVA]
----
@FullTextField
@ElementCollection
private List<String> notes;
----

See also <<implicit-container-extraction>>.

[[key]]
==== `@Key`

`@Key` has no equivalent in Hibernate Search 6.

See also <<full-text-filter>>.

[[latitude]]
==== `@Latitude`

`@Latitude` is still available in Hibernate Search 6, but moved to a different package:
`org.hibernate.search.annotations.Latitude`.

See also <<spatial>>.

[[longitude]]
==== `@Longitude`

`@Longitude` is still available in Hibernate Search 6, but moved to a different package:
`org.hibernate.search.annotations.Longitude`.

See also <<spatial>>.

[[normalizer]]
==== `@Normalizer`

In Hibernate Search 5, `@Normalizer` could point directly to a class extending `org.apache.lucene.analysis.Analyzer`,
for example with `@Normalizer(impl = MyNormalizer.class)`.

This is no longer possible: normalizers are now always referenced by their name.
However, you can assign a name to a given normalizer instance using
the link:{hibernateSearchDocUrl}#backend-lucene-analysis-analyzers[Lucene analysis configurer].

[[normalizerdef]]
==== `@NormalizerDef`, `@NormalizerDefs`

Annotation-based normalizer definitions are no longer supported.

Instead, implement an analysis configurer:
see link:{hibernateSearchDocUrl}#backend-lucene-analysis-analyzers[here for Lucene],
or link:{hibernateSearchDocUrl}#backend-elasticsearch-analysis-analyzers[here for Elasticsearch].

==== `@NumericField`, `@NumericFields`

`@NumericField` no longer exists in Hibernate Search 6.

Numeric types are indexed as numeric values by default, so this annotation can simply be removed.

See also <<more-numeric-by-default>>.

==== `@ProvidedId`

`@ProvidedId` was deprecated in Hibernate Search 5.
It no longer exists in Hibernate Search 6.

[[sortablefield]]
==== `@SortableField`, `@SortableFields`

`@SortableField` no longer exists in Hibernate Search 6. Instead, use `@*Field.sortable`:

[cols="a,a",options="header"]
|====
|Hibernate Search 5|Hibernate Search 6
|[source, JAVA]
----
@Field
@SortableField
----
|[source, JAVA]
----
@GenericField(sortable = Sortable.YES)
// OR
@KeywordField(sortable = Sortable.YES)
----
|[source, JAVA]
----
@Field
@Field(name = "myField_sort", analyze = Analyze.NO)
@SortableField(forField = "myField_sort")
----
|[source, JAVA]
----
@FullTextField
@KeywordField(name = "myField_sort", sortable = Sortable.YES)
----
|====

[NOTE]
====
`sortable` is not available on `@FullTextField`,
because link:{hibernateSearchDocUrl}#mapper-orm-directfieldmapping-annotations-fulltextfield[tokenized data cannot be reliably sorted on].

If you need both an analyzer and sorts on the same property, create two separate fields:

[source, JAVA]
----
@FullTextField
@KeywordField(name = "title_sort", normalizer = "myNormalizer", sortable = Sortable.YES)
private String title;
----

This will lead to two separate fields being created in the index, for the same property.
Just make sure to use the correct field name when searching:
`title` when creating link:{hibernateSearchDocUrl}#search-dsl-predicate-match[predicates],
but `title_sort` when creating link:{hibernateSearchDocUrl}#search-dsl-sort-field[sorts].
====

[[spatial]]
==== `@Spatial`, `@Spatials`

===== Basics

`@Spatial` has no direct equivalent in Hibernate Search 6.

Here is a quick reference of how to convert a `@Spatial` annotation to Hibernate Search 6:

[cols="2a,a,2a",options="header"]
|====
|Hibernate Search 5|Latitude/longitude are mutable?|Hibernate Search 6
.2+|[source, JAVA]
----
@Indexed
@Entity
public class MyEntity {
    @Spatial
	private MyCoordinates location;
}
public class MyCoordinates implements Coordinates {
	private Double latitude;
	private Double longitude;
	public Double getLatitude() {
		return latitude;
	}
	public Double getLongitude() {
		return longitude;
	}
}
----
|Yes
|[source, JAVA]
----
@Indexed
@Entity
public class MyEntity {
    @GeoPointBinding(projectable = Projectable.YES)
	private MyCoordinates location;
}
public class MyCoordinates implements Coordinates {
	private Double latitude;
	private Double longitude;
	@Latitude
	public Double getLatitude() {
		return latitude;
	}
	@Longitude
	public Double getLongitude() {
		return longitude;
	}
}
----
|No
|[source, JAVA]
----
@Indexed
@Entity
public class MyEntity {
    @GenericField(projectable = Projectable.YES)
	private MyCoordinates location;
}
public class MyCoordinates implements GeoPoint {
	private final double latitude;
	private final double longitude;
	public double latitude() {
		return latitude;
	}
	public double longitude() {
		return longitude;
	}
}
----
|[source, JAVA]
----
@Indexed
@Entity
@Spatial
public class MyEntity {
	@Latitude
	private Double latitude;

	@Longitude
    private Double longitude;
}
----
|Yes
|[source, JAVA]
----
@Indexed
@Entity
@GeoPointBinding(projectable = Projectable.YES)
public class MyEntity {
	@Latitude
	private Double latitude;

	@Longitude
    private Double longitude;
}
----
|[source, JAVA]
----
@Indexed
@Entity
@Spatial(name = "home_coordinates")
@Spatial(name = "work_coordinates")
public MyEntity {
	@Latitude(of = "home_coordinates")
	private Double homeLatitude;

	@Longitude(of = "home_coordinates")
    private Double homeLongitude;

	@Latitude(of = "work_coordinates")
	private Double workLatitude;

	@Longitude(of = "home_coordinates")
    private Double workLongitude;
}
----
|Yes
|[source, JAVA]
----
@Indexed
@Entity
@GeoPointBinding(name = "home_coordinates", markerSet = "home", projectable = Projectable.YES)
@GeoPointBinding(name = "work_coordinates", markerSet = "work", projectable = Projectable.YES)
public MyEntity {
	@Latitude(markerSet = "home")
	private Double homeLatitude;

	@Longitude(markerSet = "home")
    private Double homeLongitude;

	@Latitude(markerSet = "work")
	private Double workLatitude;

	@Longitude(markerSet = "home")
    private Double workLongitude;
}
----
|====

[[spatial-boost]]
===== `@Spatial.boost`

Index-time boosting was deprecated in Hibernate Search 5.
It is no longer available in Hibernate Search 6.

Instead, rely on link:{hibernateSearchDocUrl}#search-dsl-predicate-common-boost[query-time boosting].

[[spatial-name]]
===== `@Spatial.name`

`@Field.name` stays the same in Hibernate Search 6's `@GeoPointBinding` and `@GenericField` annotations,
with one exception: the field name is mandatory when `@GeoPointBinding` is applied to a class.

[cols="a,a",options="header"]
|====
|Hibernate Search 5|Hibernate Search 6
|[source, JAVA]
----
@Spatial(name = "myField")
----
|[source, JAVA]
----
@GeoPointBinding(name = "myField")
// OR
@GenericField(name = "myField")
----
|[source, JAVA]
----
// No field name, will use an internal default
@Spatial
public class MyEntity {
	// ...
}
----
|[source, JAVA]
----
// Must provide a field name
@GeoPointBinding(name = "location")
public class MyEntity {
	// ...
}
----
|====

[[spatial-spatialmode]]
===== `@Spatial.spatialMode`, `@Spatial.topSpatialHashLevel`, `@Spatial.bottomSpatialHashLevel`

`@Spatial.spatialMode`, `@Spatial.topSpatialHashLevel`, `@Spatial.bottomSpatialHashLevel`
have no equivalent in Hibernate Search 6:
geohash-based geo-point fields are no longer supported.

For Lucene, this is because Hibernate Search now uses Lucene's built-in spatial support,
which is range-based.

For Elasticsearch, hash-based geo-point fields have never been available in the first place.

[[spatial-store]]
===== `@Spatial.store`

`@Spatial.store` is now `@GeoPointBinding.projectable`/`@GenericField.projectable`:

[cols="a,a",options="header"]
|====
|Hibernate Search 5|Hibernate Search 6
|[source, JAVA]
----
@Spatial(store = Store.YES)
----
|[source, JAVA]
----
@GeoPointBinding(projectable = Projectable.YES)
// OR
@GenericField(projectable = Projectable.YES)
----
|[source, JAVA]
----
@Spatial(store = Store.NO)
----
|[source, JAVA]
----
@GeoPointBinding(projectable = Projectable.YES)
// OR
@GenericField(projectable = Projectable.YES)
----
|====

NOTE: In Hibernate Search 6, `projectable` must be set to `Projectable.YES`
to enable distance projections on a geo-point field.

[[tikabridge]]
==== `@TikaBridge`

`@TikaBridge` has no equivalent in Hibernate Search 6 yet.

If you need this feature, vote for it to be re-implemented using the new bridge API in 6.1:
link:{hibernateSearchJiraUrl}/HSEARCH-3350[HSEARCH-3350].
We'll also gladly help anyone interested in contributing a patch:
feel free to link:https://hibernate.org/community[contact us].

[[tokenfilterdef]]
==== `@TokenFilterDef`

See <<analyzerdef>> or <<normalizerdef>>.

[[tokenizerdef]]
==== `@TokenizerDef`

See <<analyzerdef>>.

[[mapping-programmatic]]
=== Programmatic mapping

Programmatic mapping was overhauled to match the new mapping annotations.

See link:{hibernateSearchDocUrl}#mapper-orm-programmatic-mapping[here] for the entry point,
and refer to the javadoc for details.

[[analysis-definition-provider]]
=== Analysis definition provider

Analysis definition providers are now called analysis configurers.
The interfaces are slightly different but follow the same general principle.

See link:{hibernateSearchDocUrl}#backend-lucene-analysis-analyzers[here for Lucene],
or link:{hibernateSearchDocUrl}#backend-elasticsearch-analysis-analyzers[here for Elasticsearch].

NOTE: Analysis configurers can be used to override the default analyzer.
To do so, just define a custom analyzer named `default`.

NOTE: With the Lucene backend, analysis configurers can be used to override the default similarity.
See link:{hibernateSearchDocUrl}#backend-lucene-analysis-similarity[here for more information]

[[bridges]]
=== Bridges

The bridge API was completely reworked in Hibernate Search 6 to offer a more powerful, Lucene-independent solution.
New features include:

* the ability to link:{hibernateSearchDocUrl}#mapper-orm-bridge-index-field-type-dsl[define field types precisely],
allowing in particular to pick an analyzer or to enable aggregation (faceting) on a bridge-declared field;
* the ability to link:{hibernateSearchDocUrl}#mapper-orm-bridge-bridgedelement-dependencies[declare the properties the bridge relies on],
allowing Hibernate Search to reindex less often;
* the ability to link:{hibernateSearchDocUrl}#mapper-orm-bridge-index-field-dsl-dynamic[declare dynamic fields with a precise type]
which the Search DSL will be aware of;
* the ability to link:{hibernateSearchDocUrl}#mapper-orm-custom-annotations[define custom field annotations];
* and link:{hibernateSearchDocUrl}#mapper-orm-bridge[more].

If your application relied on custom bridges with Hibernate Search 5,
and you need to re-implement them with Hibernate Search 6,
see link:{hibernateSearchDocUrl}#mapper-orm-directfieldmapping-custom-types[mapping custom property types].

The new bridge API is quite different from Hibernate Search 5,
but most changes should be addressed rather easily, especially
for the simpler bridges which will be implemented through `ValueBridge`.

Perhaps the only change to note is that bridges must declare the index fields they will create at bootstrap.
To set the value of new fields with random names dynamically at runtime,
you will have to rely on link:{hibernateSearchDocUrl}#mapper-orm-bridge-index-field-dsl-dynamic[field templates].

[[entity-indexing-interceptors]]
=== Entity indexing interceptors

TODO

See link:{hibernateSearchDocUrl}#mapper-orm-entityindexmapping-conditional-and-routing[this section of the documentation].

[[searching]]
=== Searching

[[searching-fulltextquery]]
==== `FullTextQuery` => DSL

===== Basics

Search APIs have changed significantly, in order to implement several improvements, in particular:

* to get rid of Lucene types leaking through Hibernate Search APIs;
* to avoid returning raw types in search results;
* to expose a more adapted, native interface for Hibernate Search queries,
instead of trying to make do with JPA's `Query` type;
* to offer a less verbose, lambda-based syntax as an alternative to the "traditional", object-based syntax.

The recommended way to build search queries in Hibernate Search 6 is through the Hibernate Search DSL.
You can find an explanation of entry points and all available features of this DSL
in link:{hibernateSearchDocUrl}#search-dsl-query[the dedicated section of the documentation].

As to migrating existing queries, let's take the following query in Hibernate Search 5 as an example:

[source, JAVA]
----
int pageIndex = ...;
int pageSize = ...;
FullTextEntityManager fullTextEntityManager = Search.getFullTextEntityManager( em );
QueryBuilder qb = fullTextEntityManager.getSearchFactory()
        .buildQueryBuilder().forEntity( Book.class ).get();

org.apache.lucene.search.Query luceneQuery = qb.keyword()
        .onField( "title" ).boostedTo( 3 )
        .matching( "robot" )
        .createQuery();

FullTextQuery fullTextQuery = fullTextEntityManager.createFullTextQuery( luceneQuery, Book.class );
fullTextQuery.setFirstResult( pageIndex * pageSize );
fullTextQuery.setMaxResults( pageSize );

List hits = fullTextQuery.getResultList();
int totalHitCount = fullTextQuery.getResultSize();
----

With the recommended lambda-based syntax, the equivalent code in Hibernate Search 6 will be:

[source, JAVA]
----
int pageIndex = ...;
int pageSize = ...;
SearchSession session = Search.session( entityManager );

SearchResult<Book> result = session.search( Book.class )
        .where( f -> f.match().field( "title" ).matching( "robot" ).boost( 3 ) )
        .fetch( pageIndex * pageSize, pageSize );

List<Book> hits = result.hits();
long totalHitCount = result.total().hitCount();
----

Alternatively, if the total hit count is not desired, you can use `fetchHits()`:

[source, JAVA]
----
int pageIndex = ...;
int pageSize = ...;
SearchSession session = Search.session( entityManager );

List<Book> hits = session.search( Book.class )
        .where( f -> f.match().field( "title" ).matching( "robot" ).boost( 3 ) )
        .fetchHits( pageIndex * pageSize, pageSize );
----

[[searching-fulltextquery-jpa-orm]]
===== Adapter from search query to JPA/ORM query

If you really need a `Query` object implementing JPA or Hibernate ORM interfaces,
for example to integrate with external code designed for JPA/Hibernate ORM,
know that the Hibernate Search query can still be converted.

See link:{hibernateSearchDocUrl}#search-dsl-query-object[this section of the documentation] for more information.

[[searching-fulltextquery-initializeObjectsWith]]
===== `FullTextQuery.initializeObjectsWith`

Hibernate Search 6 does not allow setting a `DatabaseRetrievalMethod` on a search query:
entities are always loaded with a Hibernate ORM query.

In Hibernate Search 6,
the equivalent to setting the `ObjectLookupMethod` with `FullTextQuery.initializeObjectsWith`
is to link:{hibernateSearchDocUrl}#search-dsl-query-cache-lookup-strategy[set the cache lookup strategy].

[[searching-fulltextquery-setCriteriaQuery]]
===== `FullTextQuery.setCriteriaQuery(...)`

Hibernate Search 6 does not allow adding a `Criteria` object to a search query.

If your goal is to control loading of associations precisely,
link:{hibernateSearchDocUrl}#search-dsl-query-entity-graph[set an entity graph in loading options] instead.

If your goal is to apply a filter expressed by an SQL "where" clause executed in-database,
rework your query to <<projections,project on the entity ID>>,
and execute a JPA/Hibernate ORM query after the search query to filter the entities and load them.

[[searching-fulltextquery-explain]]
===== `FullTextQuery.explain(...)`

Hibernate Search 6 still offers a way to explain the score of hits through an `explain` method,
but that method expects the entity ID, not the internal Lucene document ID
(which can change from one query execution to the next).

[source, JAVA]
----
LuceneSearchQuery<Book> query = searchSession.search( Book.class )
        .extension( LuceneExtension.get() )
        .where( f -> f.match()
                .field( "title" )
                .matching( "robot" ) )
        .toQuery();

Explanation explanation = query.explain( 1 );
----

See link:{hibernateSearchDocUrl}#search-dsl-query-debugging-scores[this section of the documentation].

[[searching-fulltextquery-setfilter]]
===== `FullTextQuery.setFilter(...)`

`FullTextQuery.setFilter(...)` was deprecated in Hibernate Search 5.
It is no longer available in Hibernate Search 6.

To filter a query, just wrap your predicate in a boolean predicate
and add a link:{hibernateSearchDocUrl}#search-dsl-predicate-boolean-filter[`filter` clause].

[[searching-fulltextquery-fulltextfilter]]
===== `FullTextQuery.enableFullTextFilter(...)` / `FullTextQuery.disableFullTextFilter(...)`

See <<full-text-filter>>.

[[queries]]
==== `org.apache.lucene.search.Query` => `SearchPredicate`

[[queries-basics]]
===== Basics

Lucene queries are replaced with Lucene-independent "search predicates" in Hibernate Search 6.

Most of the time, code that builds queries does not need to manipulate search predicates directly,
thanks to the lambda syntax.
However, it's still possible to manipulate `SearchPredicate` objects if you need to pass them around from a method to another.

You can find more information about building predicates and details about all available predicates
in link:{hibernateSearchDocUrl}#search-dsl-predicate[the dedicated section of the documentation],
and instructions to migrate from the Hibernate Search 5 Query DSL in <<queries-reference>>.

As to migrating existing complex queries, let's consider the query below:

[source, JAVA]
----
MySearchParameters params = ...;
FullTextEntityManager fullTextEntityManager = Search.getFullTextEntityManager( em );
QueryBuilder qb = fullTextEntityManager.getSearchFactory()
        .buildQueryBuilder().forEntity( Book.class ).get();

BooleanJunction junction = qb.bool();
junction.must(qb.all().createQuery());

if ( searchParameters.getSearchTerms() != null ) {
    junction.must( qb.simpleQueryString().onFields( "title", "description" )
            .withAndAsDefaultOperator()
            .matching( searchParameters.getSearchTerms() )
            .createQuery() );
}
if ( searchParameters.getGenre() != null ) {
    junction.must( qb.keyword().onField( "genre" )
            .matching( searchParameters.getGenre() ) );
}
if ( searchParameters.getMaxBookLength() != null ) {
    junction.must( qb.range().onField( "pageCount" )
            .below( searchParameters.getMaxBookLength() ) );
}

org.apache.lucene.search.Query luceneQuery = junction.createQuery();

FullTextQuery fullTextQuery = fullTextEntityManager.createFullTextQuery( luceneQuery, Book.class );
fullTextQuery.setFirstResult( params.getPageIndex() * params.getPageSize() );
fullTextQuery.setMaxResults( params.getPageSize() );

List hits = fullTextQuery.getResultList();
----

It would look like this in Hibernate Search 6:

[source, JAVA]
----
MySearchParameters params = ...;
SearchSession session = Search.session( entityManager );
List<Book> hits = searchSession.search( Book.class )
        .where( f -> f.bool( b -> {
            b.must( f.matchAll() );
            if ( searchParameters.getSearchTerms() != null ) {
                b.must( f.simpleQueryString().fields( "title", "description" )
                        .matching( searchParameters.getSearchTerms() )
                        .defaultOperator( BooleanOperator.AND ) );
            }
            if ( searchParameters.getGenre() != null ) {
                b.must( f.match().field( "genre" )
                        .matching( searchParameters.getGenre() ) );
            }
            if ( searchParameters.getMaxBookLength() != null ) {
                b.must( f.range().field( "pageCount" )
                        .atMost( searchParameters.getMaxBookLength() ) );
            }
        } ) )
        .fetchHits( params.getPageIndex() * params.getPageSize(), params.getPageSize() );
----

Alternatively, if for some reasons predicate objects are necessary:

[source, JAVA]
----
MySearchParameters params = ...;
SearchSession session = Search.session( entityManager );
SearchPredicateFactory pf = session.scope( Book.class ).predicate();
List<SearchPredicate> predicates = new ArrayList<>();

if ( searchParameters.getSearchTerms() != null ) {
    predicates.add( pf.simpleQueryString().fields( "title", "description" )
            .matching( searchParameters.getSearchTerms() )
            .defaultOperator( BooleanOperator.AND )
            .toPredicate() );
}
if ( searchParameters.getGenre() != null ) {
    predicates.add( pf.match().field( "genre" )
            .matching( searchParameters.getGenre() )
            .toPredicate() );
}
if ( searchParameters.getMaxBookLength() != null ) {
    predicates.add( pf.range().field( "pageCount" )
            .atMost( searchParameters.getMaxBookLength() )
            .toPredicate() );
}

List<Book> hits = searchSession.search( Book.class )
        .where( f -> f.bool( b -> {
            b.must( f.matchAll() );
            for ( SearchPredicate predicate : predicates ) {
            	b.must( predicate );
            }
        } )
        .fetchHits( params.getPageIndex() * params.getPageSize(), params.getPageSize() );
----

[[queries-reference]]
===== `Query` DSL migration reference

The code below makes some assumptions:

* For Hibernate Search 5, a `QueryBuilder` was retrieved from the `SearchFactory` and put in variable `qb`.
* For Hibernate Search 6, the predicate is being built in a lambda expression:
`Search.session( entityManager ).search( Book.class ).where( f -> ... )`.

[cols="l,l,a",options="header"]
|====
|Hibernate Search 5|Hibernate Search 6|Documentation

|qb.all().createQuery()
|f.matchAll()
|link:{hibernateSearchDocUrl}#search-dsl-predicate-match-all[`matchAll`]

|qb.keyword().onField("field")
        .matching("value")
        .createQuery()
|f.match().field("field")
        .matching("value")
.6+a|link:{hibernateSearchDocUrl}#search-dsl-predicate-match[`match`]

For matches on the identifier (which is <<document-id-is-not-a-field,no longer a field by default>>),
use the `id` predicate instead (see below).

`matching(...)` no longer accepts `null`;
use a (negated) `exists` predicate instead (see below).
|qb.keyword().onField("field")
        .matching("value")
        .ignoreFieldBridge()
        .createQuery()
|f.match().field("field")
        .matching("value",
                ValueConvert.NO)
|qb.keyword().onField("field")
        .matching("value")
        .ignoreAnalyzer()
        .createQuery()
|f.match().field("field")
        .matching("value")
        .skipAnalysis()
|qb.keyword().onField("field")
        .fuzzy()
        .matching("value")
        .createQuery()
|f.match().field("field")
        .matching("value")
        .fuzzy()
|qb.keyword().onField("field")
        .fuzzy()
        .withEditDistanceUpTo(2)
        .matching("value")
        .createQuery()
|f.match().field("field")
        .matching("value")
        .fuzzy(2)
|qb.keyword().onField("field")
        .fuzzy()
        .withEditDistanceUpTo(2)
        .withPrefixLength(1)
        .matching("value")
        .createQuery()
|f.match().field("field")
        .matching("value")
        .fuzzy(2,1)

|qb.keyword().onField("field")
        .matching(null)
        .createQuery()
|f.bool().mustNot(f.exists()
        .field("field"))
|link:{hibernateSearchDocUrl}#search-dsl-predicate-exists[`exists`]

|qb.keyword().onField("id")
        .matching(123L)
        .createQuery()
|f.id().matching(123L)
|link:{hibernateSearchDocUrl}#search-dsl-predicate-id[`id`]

|qb.keyword().wildcard()
        .onField("field")
        .matching("pattern*")
        .createQuery()
|f.wildcard().field("field")
        .matching("pattern*")
|link:{hibernateSearchDocUrl}#search-dsl-predicate-wildcard[`wildcard`]

|qb.range().onField("field")
        .from(0).to(3)
        .createQuery()
|f.range().field("field")
        .between(0,3)
.6+|link:{hibernateSearchDocUrl}#search-dsl-predicate-range[`range`]
|qb.range().onField("field")
        .from(0).to(3).excludeLimit()
        .createQuery()
|f.range().field("field")
        .range(Range.canonical(0,3))
|qb.range().onField("field")
        .below(3)
        .createQuery()
|f.range().field("field")
        .atMost(3)
|qb.range().onField("field")
        .below(3).excludeLimit()
        .createQuery()
|f.range().field("field")
        .lessThan(3)
|qb.range().onField("field")
        .above(0)
        .createQuery()
|f.range().field("field")
        .atLeast(0)
|qb.range().onField("field")
        .above(0).excludeLimit()
        .createQuery()
|f.range().field("field")
        .greaterThan(0)

|qb.phrase().onField("field")
        .sentence("a few words")
        .createQuery()
|f.phrase().field("field")
        .matching("a few words")
|link:{hibernateSearchDocUrl}#search-dsl-predicate-phrase[`phrase`]

|qb.bool()
.must(qb.keyword().onField("field1")
        .matching("value1")
        .createQuery())
.should(qb.keyword().onField("field2")
        .matching("value2")
        .createQuery())
.filter(qb.keyword().onField("field3")
        .matching("value3")
        .createQuery())
.must(qb.keyword().onField("field4")
        .matching("value4")
        .createQuery())
        .not()
.createQuery()
|f.bool()
.must(f.match().field("field1")
        .matching("value1"))
.should(f.match().field("field2")
        .matching("value2"))
.filter(f.match().field("field3")
        .matching("value3"))
.mustNot(f.match().field("field4")
        .matching("value4"))
.2+|link:{hibernateSearchDocUrl}#search-dsl-predicate-boolean[`bool`]
|qb.bool()
.minimumShouldMatchNumber(2)
.should(qb.keyword().onField("field1")
        .matching("value1")
        .createQuery())
.should(qb.keyword().onField("field2")
        .matching("value2")
        .createQuery())
.createQuery()
|f.bool()
.minimumShouldMatchNumber(2)
.should(f.match().field("field1")
        .matching("value1"))
.should(f.match().field("field2")
        .matching("value2"))

|qb.simpleQueryString().onField("field")
        .matching("querystring")
|f.simpleQueryString().field("field")
        .matching("querystring")
.2+|link:{hibernateSearchDocUrl}#search-dsl-predicate-simple-query-string[`simpleQueryString`]
|qb.simpleQueryString()
        .onField("field")
        .withAndAsDefaultOperator()
        .matching("querystring")
|f.simpleQueryString().field("field")
        .defaultOperator(BooleanOperator.AND)
        .matching("querystring")

|qb.spatial().onField("field")
        .within(51,Unit.KM)
        .ofLatitude(centerLatitude)
        .andLongitude(centerLongitude)
        .createQuery()
|f.spatial().within()
        .field("field")
        .circle(centerLatitude,
                centerLongitude,
                51,
                DistanceUnit.KILOMETERS)
.2+|link:{hibernateSearchDocUrl}#search-dsl-predicate-spatial-within[`within`]
|Coordinates center = ...;
qb.spatial().onField("field")
        .within(51,Unit.KM)
        .ofCoordinates(center)
        .createQuery()
|GeoPoint center = ...;
f.spatial().within()
        .field("field")
        .circle(center,
                51,
                DistanceUnit.KILOMETERS)

|qb.moreLikeThis()
|No equivalent in Hibernate Search 6.

If you need more-like-this predicates,
feel free to drop a comment to explain your use case on link:{hibernateSearchJiraUrl}/HSEARCH-3272[HSEARCH-3272].
|====

[[queries-native]]
===== Native query

It is still possible to rely on native Lucene queries (e.g. `new RegexpQuery(...)`)
or Elasticsearch queries (e.g. `{'match': {...}}`)
in Hibernate Search 6:
you will just need to rely on the link:{hibernateSearchDocUrl}#search-dsl-predicate-extensions[backend-specific extension].

[WARNING]
====
Be aware that internal field types may have changed since Hibernate Search 5;
see <<data-format>>.
====

[[sorts]]
==== `org.apache.lucene.search.Sort` / `SortField` => `SearchSort`

Lucene sort fields are replaced with Lucene-independent "search sorts" in Hibernate Search 6.

Most of the time, code that builds queries does not need to manipulate search sorts directly,
thanks to the lambda syntax.
However, it's still possible to manipulate `SearchSort` objects if you need to pass them around from a method to another.

You can find more information about building sorts and details about all available sorts
in link:{hibernateSearchDocUrl}#search-dsl-sort[the dedicated section of the documentation],
and instructions to migrate from the Hibernate Search 5 Query DSL in <<sorts-reference>>.

As to adding sorts to search queries, let's consider the query below:

[source, JAVA]
----
MySearchParameters params = ...;
FullTextEntityManager fullTextEntityManager = Search.getFullTextEntityManager( em );
QueryBuilder qb = fullTextEntityManager.getSearchFactory()
        .buildQueryBuilder().forEntity( Book.class ).get();

FullTextQuery fullTextQuery = fullTextEntityManager.createFullTextQuery( qb.all().createQuery(), Book.class );
fullTextQuery.setFirstResult( params.getPageIndex() * params.getPageSize() );
fullTextQuery.setMaxResults( params.getPageSize() );

fullTextQuery.sort( qb.sort().byField( "pageCount" ).desc()
        .andByField( "title_sort" )
        .createSort() );

List hits = fullTextQuery.getResultList();
----

It would look like this in Hibernate Search 6:

[source, JAVA]
----
MySearchParameters params = ...;
SearchSession session = Search.session( entityManager );
List<Book> hits = searchSession.search( Book.class )
        .where( f -> f.matchAll() )
        .sort( f -> f.field( "pageCount" ).desc()
                .then().field( "title_sort" ) )
        .fetchHits( params.getPageIndex() * params.getPageSize(), params.getPageSize() );
----

[[sorts-reference]]
===== `Sort` DSL migration reference

The code below makes some assumptions:

* For Hibernate Search 5, a `QueryBuilder` was retrieved from the `SearchFactory` and put in variable `qb`.
* For Hibernate Search 6, the sort is being built in a lambda expression:
`Search.session( entityManager ).search( Book.class ).where( f -> f.matchAll() ).sort( f -> ... )`.

[cols="l,l,a",options="header"]
|====
|Hibernate Search 5|Hibernate Search 6|Documentation

|qb.sort().byScore()
        .createSort()
|f.score()
|link:{hibernateSearchDocUrl}#search-dsl-sort-score[`score`]

|qb.sort().byIndexOrder()
        .createSort()
|f.indexOrder()
|link:{hibernateSearchDocUrl}#search-dsl-sort-index-order[`indexOrder`]

|qb.sort().byField("field")
        .createSort()
|f.field("field")
.6+|link:{hibernateSearchDocUrl}#search-dsl-sort-field[`field`]
|qb.sort().byField("field")
        .asc()
        .createSort()
|f.field("field").asc()
|qb.sort().byField("field")
        .desc()
        .createSort()
|f.field("field").desc()
|qb.sort().byField("field")
        .onMissingValue()
        .sortFirst()
        .createSort()
|f.field("field")
        .missing().first()
|qb.sort().byField("field")
        .onMissingValue()
        .sortLast()
        .createSort()
|f.field("field")
        .missing().last()
|qb.sort().byField("field")
        .onMissingValue()
        .use("value")
        .createSort()
|f.field("field")
        .missing().use("value")

|qb.sort()
        .byField("field",
                SortField.Type.STRING)
        .createSort()
|-
|This method was deprecated in Hibernate Search 5.

There is no equivalent in Hibernate Search 6.

|qb.sort().byDistance().onField("field")
        .fromLatitude(latitude)
        .andLongitude(longitude)
        .createSort()
|f.distance("field",
        GeoPoint.of(latitude, longitude))
|link:{hibernateSearchDocUrl}#search-dsl-sort-distance[`distance`]

|qb.sort().byNative(sortField)
|f.extension(LuceneExtension.get())
        .fromLuceneSortField(sortField)
|link:{hibernateSearchDocUrl}#search-dsl-sort-extensions-lucene-from-lucene-sort-field[`fromLuceneSortField`]

Be aware that internal field types may have changed since Hibernate Search 5;
see <<data-format>>.

In particular, Hibernate Search 6 relies on `SORTED_SET` docvalues for most field types,
so the classic `SortField.TYPE.STRING` and similar just won't work:
you need to go through the DSL to create the appropriate sorts.

|qb.sort().byNative("authors.name", "{'order':'asc', 'mode': 'min'}")
|f.extension(ElasticsearchExtension.get())
        .fromJson("{'authors.name': {'order':'asc', 'mode': 'min'} }")
|link:{hibernateSearchDocUrl}#search-dsl-sort-extensions-elasticsearch-from-json[`fromJson`]

Be aware that internal field types may have changed since Hibernate Search 5;
see <<data-format>>.
|====

[[sorts-native]]
===== Native sorts

It is still possible to rely on native Lucene sort fields (e.g. `new SortField(...)`)
or Elasticsearch sorts (e.g. `{'title_sort': {...}}`)
in Hibernate Search 6:
you will just need to rely on the link:{hibernateSearchDocUrl}#search-dsl-sort-extensions[backend-specific extension].

[[projections]]
==== Projections

===== Basics

Projections gain a full-blown DSL in Hibernate Search 6, allowing more complex projections,
as explained in link:{hibernateSearchDocUrl}#search-dsl-sort[the dedicated section of the documentation].

The `ProjectionConstants` are gone, and the projection DSL must be used instead to build `SearchProjection` objects.
You will find instructions to migrate from `ProjectionConstants` to the Hibernate Search 6 projection DSL in <<projections-reference>>.

As to adding projections to search queries, let's consider the query below:

[source, JAVA]
----
FullTextEntityManager fullTextEntityManager = Search.getFullTextEntityManager( em );
QueryBuilder qb = fullTextEntityManager.getSearchFactory()
        .buildQueryBuilder().forEntity( Book.class ).get();

FullTextQuery fullTextQuery = fullTextEntityManager.createFullTextQuery( qb.all().createQuery(), Book.class );
fullTextQuery.setMaxResults( 20 );

fullTextQuery.setProjection( "isbn", "title" );

List hits = fullTextQuery.getResultList();
----

It would look like this in Hibernate Search 6:

[source, JAVA]
----
SearchSession session = Search.session( entityManager );
List<List<?>> hits = searchSession.search( Book.class )
        .select( f -> f.composite(
        		f.field( "isbn" ),
        		f.field( "title" )
        ) )
        .where( f -> f.matchAll() )
        .fetchHits( 20 );
----

Alternatively, the composite projection can be made more type-safe:

[source, JAVA]
----
SearchSession session = Search.session( entityManager );
List<Map.Entry<ISBN, String>> hits = searchSession.search( Book.class )
        .select( f -> f.composite(
        		Map::entry,
        		f.field( "isbn", ISBN.class ),
        		f.field( "title", String.class )
        ) )
        .where( f -> f.matchAll() )
        .fetchHits( 20 );
----

[[projections-reference]]
===== `ProjectionConstants`/`ElasticsearchProjectionConstants` migration reference

The code below makes some assumptions for Hibernate Search 6: the projection is being built in a lambda expression,
e.g. `Search.session( entityManager ).search( Book.class ).select( f -> ... )`.

[cols="l,l,a",options="header"]
|====
|Hibernate Search 5 `ProjectionConstants` or `ElasticsearchProjectionConstants`|Hibernate Search 6|Documentation
|THIS
|f.entity()
|link:{hibernateSearchDocUrl}#search-dsl-projection-entity[`entity`]

|DOCUMENT
|f.extension(LuceneExtension.get())
        .document()
|link:{hibernateSearchDocUrl}#search-dsl-projection-extensions-lucene-document[`document`]

|SCORE
|f.score()
|link:{hibernateSearchDocUrl}#search-dsl-projection-score[`score`]

|ID
|f.composite(EntityReference::id,
        f.entityReference())
|link:{hibernateSearchDocUrl}#search-dsl-projection-reference[`entityReference`],
link:{hibernateSearchDocUrl}#search-dsl-projection-composite[`composite`]

Alternatively, `f.entityReference()` (without the wrapping in the "composite" projection)
will return an instance of `EntityReference`,
which includes both the type and ID of the entity.

|DOCUMENT_ID
|f.composite(DocumentReference::id,
        f.documentReference())
|link:{hibernateSearchDocUrl}#search-dsl-projection-documentReference[`documentReference`],
link:{hibernateSearchDocUrl}#search-dsl-projection-composite[`composite`]

This no longer returns the internal Lucene document ID
(which can change from one query execution to the next),
but instead returns the Hibernate Search document ID,
i.e. the String version of the property annotated with `@Id` or `@DocumentId`.
Note that you no longer need the internal Lucene document ID
to get an <<searching-fulltextquery-explain,explanation of the score>>.

Alternatively, `f.documentReference()` (without the wrapping in the "composite" projection)
will return an instance of `DocumentReference`,
which includes both the type and ID of the document.

|EXPLANATION
|f.extension(LuceneExtension.get())
        .explanation()

OR

f.extension(ElasticsearchExtension.get())
        .explanation()
|link:{hibernateSearchDocUrl}#search-dsl-projection-extensions-lucene-explanation[`explanation` (Lucene)]

link:{hibernateSearchDocUrl}#search-dsl-projection-extensions-elasticsearch-explanation[`explanation` (Elasticsearch)]

This projection returns a `JsonObject` for Elasticsearch.

|OBJECT_CLASS
|f.composite(EntityReference::type,
        f.entityReference())
|link:{hibernateSearchDocUrl}#search-dsl-projection-reference[`entityReference`],
link:{hibernateSearchDocUrl}#search-dsl-projection-composite[`composite`]

Alternatively, `f.entityReference()` (without the wrapping in the "composite" projection)
will return an instance of `EntityReference`,
which includes both the type and ID of the entity.

.2+|SPATIAL_DISTANCE
|f.distance("field",
        GeoPoint.of(latitude, longitude))
.2+|link:{hibernateSearchDocUrl}#search-dsl-projection-distance[`distance`]
|f.distance("field",
        GeoPoint.of(latitude, longitude))
        .unit( DistanceUnit.KILOMETERS )

|SOURCE
|f.extension(ElasticsearchExtension.get())
        .source()
|link:{hibernateSearchDocUrl}#search-dsl-projection-extensions-elasticsearch-source[`source`]

This projection used to return a `String` in Hibernate Search 5,
but returns a `JsonObject` in Hibernate Search 6.

|TOOK
|-
|See link:{hibernateSearchDocUrl}#search-dsl-query-debugging-took-timedout[`took` and `timedOut`]

|TIMED_OUT
|-
|See link:{hibernateSearchDocUrl}#search-dsl-query-debugging-took-timedout[`took` and `timedOut`]
|====

[[searching-facet]]
==== Facets => Aggregations

Facets are now called aggregations, which are a generalization of the concept of faceting.

Like other concepts (predicates, sorts, ...) aggregations have a dedicated DSL in Hibernate Search 6,
as explained in link:{hibernateSearchDocUrl}#search-dsl-aggregation[the dedicated section of the documentation].

See the following sections for the equivalent aggregation for each type of facet.

NOTE: One difference with Hibernate Search 5 is that Hibernate Search 6 aggregations
no longer allow drill-down (`.selectFacets(...)`).
See <<searching-facets-selectfacets>>.

===== Discrete faceting

Let's consider the query below:

[source, JAVA]
----
FullTextEntityManager fullTextEntityManager = Search.getFullTextEntityManager( em );
QueryBuilder qb = fullTextEntityManager.getSearchFactory()
        .buildQueryBuilder().forEntity( Book.class ).get();

FacetingRequest genreFacetingRequest = qb.facet()
        .name( "genreFaceting" )
        .onField( "genre" )
        .discrete()
        .orderedBy( FacetSortOrder.COUNT_DESC )
        .includeZeroCounts( false )
        .maxFacetCount( 3 )
        .createFacetingRequest();

FullTextQuery fullTextQuery = fullTextEntityManager.createFullTextQuery( qb.all().createQuery(), Book.class );
fullTextQuery.setMaxResults( 20 );

FacetManager facetManager = fullTextQuery.getFacetManager();
facetManager.enableFaceting( genreFacetingRequest );

List hits = fullTextQuery.getResultList();

List<Facet> facets = facetManager.getFacets( "genreFaceting" );
----

It would look like this in Hibernate Search 6:

[source, JAVA]
----
SearchSession session = Search.session( entityManager );

AggregationKey<Map<Genre, Long>> countByGenreKey = AggregationKey.of( "countByGenre" );

SearchResult<Book> result = searchSession.search( Book.class )
        .where( f -> f.matchAll() )
        .aggregation( countByGenreKey, f -> f.terms()
                .field( "genre", Genre.class )
                .orderByCountDescending()
                .minDocumentCount( 1 )
                .maxTermCount( 3 ) )
        .fetch( 20 );

List<Book> hits = result.hits();

Map<Genre, Long> countByGenre = result.aggregation( countByGenreKey );
----

See link:{hibernateSearchDocUrl}#search-dsl-aggregation-terms[this section of the documentation] for more information.

===== Range faceting

Let's consider the query below:

[source, JAVA]
----
FullTextEntityManager fullTextEntityManager = Search.getFullTextEntityManager( em );
QueryBuilder qb = fullTextEntityManager.getSearchFactory()
        .buildQueryBuilder().forEntity( Book.class ).get();

FacetingRequest priceFacetingRequest = qb.facet()
        .name( "priceFaceting" )
        .onField( "price" )
        .range()
        .below( 1000 ).excludeLimit()
        .from( 1001 ).to( 1500 ).excludeLimit()
        .above( 1500 )
        .orderedBy( FacetSortOrder.COUNT_DESC )
        .includeZeroCounts( false )
        .maxFacetCount( 3 )
        .createFacetingRequest();

FullTextQuery fullTextQuery = fullTextEntityManager.createFullTextQuery( qb.all().createQuery(), Book.class );
fullTextQuery.setMaxResults( 20 );

FacetManager facetManager = fullTextQuery.getFacetManager();
facetManager.enableFaceting( priceFacetingRequest );

List hits = fullTextQuery.getResultList();

List<Facet> facets = facetManager.getFacets( "priceFaceting" );
----

It would look like this in Hibernate Search 6:

[source, JAVA]
----
SearchSession session = Search.session( entityManager );

AggregationKey<Map<Range<Double>, Long>> countByPriceRangeKey = AggregationKey.of( "countByPriceRange" );

SearchResult<Book> result = searchSession.search( Book.class )
        .where( f -> f.matchAll() )
        .aggregation( countByPriceRangeKey, f -> f.range()
                .field( "price", Double.class )
                .range( Range.lessThan( 1000.0 ) )
                .range( Range.canonical( 1000.0, 1500.0 ) )
                .range( Range.atLeast( 1500.0 ) )
                // Not equivalent to 'orderedBy'
                // Not equivalent to 'includeZeroCounts'
                // Not equivalent to 'maxFacetCount'
        .fetch( 20 );

List<Book> hits = result.hits();

Map<Range<Double>, Long> countByPriceRange = result.aggregation( countByPriceRangeKey );
----

See link:{hibernateSearchDocUrl}#search-dsl-aggregation-range[this section of the documentation] for more information.

[NOTE]
====
`orderedBy`, `includeZeroCounts` and `maxFacetCount` have no equivalent Hibernate Search 6 range aggregations:
all given ranges will always be included in the resulting `Map`.

The behavior of these methods can be implemented by post-processing the `Map` in user code.
====

[[searching-facets-selectfacets]]
===== Drill-down with `.selectFacets`

In Hibernate Search 5, the `.selectFacets` method used to allow "drill-down",
i.e. adding a filter to the query to only consider documents in a given facet.

Hibernate Search 6 no longer supports this feature directly.

To perform a drill-down, create a new query with the original predicate wrapped in a boolean predicate
and add a link:{hibernateSearchDocUrl}#search-dsl-predicate-boolean-filter[`filter` clause]
to restrict the hits to the selected facet(s):

* For discrete faceting, use a link:{hibernateSearchDocUrl}#search-dsl-predicate-match[`match` predicate].
* For range faceting, use a link:{hibernateSearchDocUrl}#search-dsl-predicate-range[`range` predicate].

[[error-handler]]
=== Error handler

TODO

[[full-text-filter]]
=== Full text filter

TODO

[[statistics]]
=== Statistics

TODO

[[factory]]
=== `@Factory`

The `@Factory` annotation does not exist in Hibernate Search 6 anymore.

You are encouraged to rely on a proper dependency injection framework if you need such a feature:
just reference the bean name instead of referencing the bean class in your Hibernate Search mapping/configuration.
See link:{hibernateSearchDocUrl}#configuration-bean[the section of the documentation about beans in Hibernate Search]
for details and supported DI frameworks.

If you don't use a dependency injection framework,
here are details on how to migrate:

String bridges, field bridges, class bridges::
Use their `*Binder` equivalent in Hibernate Search 6,
which can act as a factory:
link:{hibernateSearchDocUrl}#mapper-orm-bridge-valuebridge-valuebinder[`ValueBinder`],
link:{hibernateSearchDocUrl}#mapper-orm-bridge-propertybridge[`PropertyBinder`],
link:{hibernateSearchDocUrl}#mapper-orm-bridge-typebridge[`TypeBinder`].

Full-text filters::
These no longer exist in Hibernate Search 6.
See link:{hibernateSearchJiraUrl}/HSEARCH-3325[HSEARCH-3325].

Programmatic mapping::
`@Factory` is no longer needed for the programmatic mapping,
since you will pass a callback (link:{hibernateSearchDocUrl}#mapper-orm-programmatic-mapping[`HibernateOrmSearchMappingConfigurer`])
instead of passing the mapping directly.
Whatever code was implemented in your factory can be moved to the configurer.

Analysis definition providers::
Analysis definition providers <<analysis-definition-provider,are now called analysis configurers>>,
and as they are just callbacks that are used only once,
the `@Factory` annotation should not be necessary.
Whatever code was implemented in your factory can be moved to the configurer.

[[spi]]
== SPI changes

Due to the extensive rewrites involved in Hibernate Search 6,
existing integrations relying on Hibernate Search 5 are likely to require a full rewrite.

We will be glad to help, so feel free to link:https://hibernate.org/community[contact us].

[[behavior]]
== Behavior changes

WARNING: This section is still incomplete. To be completed upon the CR or release.

[[document-id-is-not-a-field]]
=== The document ID is not an index field

TODO

[[faceting-strings-are-normalized]]
=== Faceting returns normalized strings

TODO

[[implicit-container-extraction]]
=== Container extraction for `@*Field` is implied

TODO

[[more-numeric-by-default]]
=== More fields are numeric by default

TODO @IndexedEmbedded.includeEmbeddedObjectId: previously string except if @NumericField, now numeric except if custom bridge

TODO short/byte: previously string except if @NumericField, now numeric except if custom bridge
