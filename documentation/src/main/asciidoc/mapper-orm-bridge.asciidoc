[[mapper-orm-bridge]]
= Bridges
// Search 5 anchors backward compatibility
[[search-mapping-bridge]]

== Basics
// Search 5 anchors backward compatibility
[[section-custom-bridges]]

In Hibernate Search, bridges are the components responsible for converting pieces of data
from the entity model to the document model.

For example, when `@GenericField` is applied to a property of a custom enum type,
a built-in bridge will be used to convert this enum to a string when indexing,
and to convert the string back to an enum when projecting.

Similarly, when a entity identifier of type `Long` is mapped to a document identifier,
a built-in bridge will be used to convert the `Long` to a `String`
(since all document identifiers are strings)
when indexing,
and back from a `String` to a `Long` when loading search results.

Bridges are not limited to one-to-one mapping:
for example, the <<mapper-orm-geopoint-geopointbinding,`@GeoPointBinding`>> annotation,
which maps two properties annotated with `@Latitude` and `@Longitude`
to a single field, is backed by another built-in bridge.

While built-in bridges are provided for a wide range of standard types,
they may not be enough for complex models.
This is why bridges are really interesting:
it is possible to implement custom bridges and to refer to them in the Hibernate Search mapping.
Using custom bridges, custom types can be mapped,
even complex types that require user code to execute at indexing time.

There are multiple types of bridges,
detailed in the next sections.
If you need to implement a custom bridge, but don't quite know which type of bridge you need,
the following table may help:

[cols="h,1,1,1,1,1",options="header"]
.Comparison of available bridge types
|===
|Bridge type
|<<mapper-orm-bridge-valuebridge,`ValueBridge`>>
|<<mapper-orm-bridge-propertybridge,`PropertyBridge`>>
|<<mapper-orm-bridge-typebridge,`TypeBridge`>>
|<<mapper-orm-bridge-identifierbridge,`IdentifierBridge`>>
|<<mapper-orm-bridge-routingkeybridge,`RoutingKeyBridge`>>

|Annotation
|Built-in: <<mapper-orm-directfieldmapping,`@GenericField`, `@FullTextField`, ...>>
|Custom
|Custom
|Built-in: <<mapper-orm-identifiermapping,`@DocumentId`>>
|Custom

|Maps from...
|One property
|One property
|One property or more
|One property (usually the entity identifier)
|One property or more

|Maps to...
|One index field
|One index field or more
|One index field or more
|Document identifier
|<<concepts-sharding-routing,Routing key>>

|Supports <<mapper-orm-containerextractor,container extractors>>
|Yes
|No
|No
|No
|No

|Supports mutable types
|[red]*No*
|Yes
|Yes
|[red]*No*
|Yes
|===

[[mapper-orm-bridge-valuebridge]]
== Value bridges
// Search 5 anchors backward compatibility
[[_stringbridge]]

=== Basics

A value bridge is a pluggable component that implements
the mapping of a property to an index field.
It is applied to a property using a `@*Field` annotation:
`@GenericField`, `@FullTextField`, ...

A value bridge is relatively straightforward to implement:
in its simplest form,
it boils down to converting a value from the property type
to the index field type.
Thanks to the integration to the `@*Field` annotations,
several features come for free:

* The type of the index field can be customized directly in the `@*Field` annotation:
it can be defined as <<mapper-orm-directfieldmapping-sortable,sortable>>,
<<mapper-orm-directfieldmapping-projectable,projectable>>,
it can be assigned an <<mapper-orm-directfieldmapping-analyzer,analyzer>>,
...
* The bridge can be transparently applied to elements of a container.
For example, you can implement a `ValueBridge<ISBN, String>`
and transparently use it on a property of type `List<ISBN>`:
the bridge will simply be applied once per list element
and populate the index field with as many values.

However, due to these features,
several limitations are imposed on a value bridge
which are not present in a <<mapper-orm-bridge-propertybridge,property bridge>> for example:

* A value bridge only allows one-to-one mapping: one property to one index field.
A single value bridge cannot populate more than one index field.
* A value bridge cannot accept custom parameters.
The only parameters available are those exposed by the `@*Field` annotation.
* A value bridge *will not work correctly when applied to a mutable type*.
A value bridge is expected to be applied to "atomic" data, such as a `LocalDate`;
if it is applied to an entity, for example, extracting data from its properties,
Hibernate Search will not be aware of which properties are used
and will not be able to automatically trigger reindexing when these properties change.

Below is an example of a custom value bridge that converts
a custom `ISBN` type to its string representation to index it:

// Search 5 anchors backward compatibility
[[example-custom-string-bridge]]
.Implementing and using a `ValueBridge`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/valuebridge/simple/ISBNValueBridge.java[tags=include]
----
<1> The bridge must implement the `ValueBridge` interface.
Two generic type arguments must be provided:
the first one is the type of property values (values in the entity model),
and the second one is the type of index fields (values in the document model).
<2> The `toIndexedValue` method is the only one that must be implemented: all other methods are optional.
It takes the property value and a context object as parameters,
and is expected to return the corresponding index field value.
It is called when indexing,
but also when parameters to the search DSL <<search-dsl-argument-type,must be transformed>>.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/valuebridge/simple/Book.java[tags=include;!getters-setters]
----
<1> This this is unrelated to the value bridge,
but necessary in order for Hibernate ORM to store the data correctly in the database.
<2> Map the property to an index field.
<3> Instruct Hibernate Search to use our custom value bridge.
It is also possible to reference the bridge by its name, in the case of a CDI/Spring bean.
<4> Customize the field as usual.
====

The example above is just a minimal implementations.
A custom value bridge can do more:

* it can <<mapper-orm-bridge-valuebridge-projection,convert the result of projections back to the property type>>;
* it can <<mapper-orm-bridge-valuebridge-indexnullas,parse the value passed to `indexNullAs`>>;
* ...

See the next sections for more information.

=== Type resolution

By default, the value bridge's property type and index field type are determined automatically,
using reflection to extract the generic type arguments of the `ValueBridge` interface:
the first argument is the property type while the second argument is the index field type.

For example, in `public class MyBridge implements ValueBridge<ISBN, String>`,
the property type is resolved to `ISBN` and the index field type is resolved to `String`:
the bridge will be applied to properties of type `ISBN`
and will populate an index field of type `String`.

The fact that types are resolved automatically using reflection brings a few limitations.
In particular, it means the generic type arguments cannot be just anything;
as a general rule, you should stick to literal types (`MyBridge implements ValueBridge<ISBN, String>`)
and avoid generic type parameters and wildcards (`MyBridge<T> implements ValueBridge<List<T>, T>`).

If you need more complex types,
you can bypass the automatic resolution and specify types explicitly
using a <<mapper-orm-bridge-valuebridge-valuebinder,`ValueBinder`>>.

[[mapper-orm-bridge-valuebridge-annotation-compatibility]]
=== Using value bridges in other `@*Field` annotations

In order to use a custom value bridge with specialized annotations such as `@FullTextField`,
the bridge must declare a compatible index field type.

For example:

* `@FullTextField` and `@KeywordField` require an index field type of type `String` (`ValueBridge<Whatever, String>`);
* `@ScaledNumberField` requires an index field type of type `BigDecimal` (`ValueBridge<Whatever, BigDecimal>`)
or `BigInteger` (`ValueBridge<Whatever, BigInteger>`).

Refer to <<mapper-orm-directfieldmapping-annotations>>
for the specific constraints of each annotation.

Attempts to use a bridge that declares an incompatible type will trigger exceptions at bootstrap.

[[mapper-orm-bridge-valuebridge-projection]]
=== Supporting projections with `fromIndexedValue()`
// Search 5 anchors backward compatibility
[[section-two-way-bridge]]

By default, any attempt to project on a field using a custom bridge will result in an exception,
because Hibernate Search doesn't know how to convert
the projected values obtained from the index back to the property type.

It is possible to <<search-dsl-projected-value-type,disable conversion explicitly>> to get the raw value from the index,
but another way of solving the problem is to simply implement `fromIndexedValue` in the custom bridge.
This method will be called whenever a projected value needs to be converted.

.Implementing `fromIndexedValue` to convert projected values
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/valuebridge/projection/ISBNValueBridge.java[tags=include]
----
<1> Implement `fromIndexedValue` as necessary.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/valuebridge/projection/Book.java[tags=include;!getters-setters]
----
<1> This this is unrelated to the value bridge,
but necessary in order for Hibernate ORM to store the data correctly in the database.
<2> Map the property to an index field.
<3> Instruct Hibernate Search to use our custom value bridge.
<4> Do not forget to configure the field as projectable.
====

[[mapper-orm-bridge-valuebridge-indexnullas]]
=== Supporting `indexNullAs` with `parse()`

By default, the `indexNullAs` attribute of `@*Field` annotations cannot be used together with a custom bridge.

In order to make it work, the bridge needs to implement the `parse` method
so that Hibernate Search can convert the string assigned to `indexNullAs`
to a value of the correct type for the index field.

.Implementing `parse` to support `indexNullAs`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/valuebridge/indexnullas/ISBNValueBridge.java[tags=include]
----
<1> Implement `parse` as necessary.
The bridge may throw exceptions for invalid strings.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/valuebridge/indexnullas/Book.java[tags=include;!getters-setters]
----
<1> This this is unrelated to the value bridge,
but necessary in order for Hibernate ORM to store the data correctly in the database.
<2> Map the property to an index field.
<3> Instruct Hibernate Search to use our custom value bridge.
<4> Set `indexNullAs` to a valid value.
====

=== Compatibility across indexes with `isCompatibleWith()`

A value bridges is involved in indexing,
but also in the various search DSLs,
to convert values passed to the DSL to an index field value that the backend will understand.

When creating a predicate targeting a single field across multiple indexes,
Hibernate Search will have multiple bridges to choose from: one per index.
Since only one predicate with a single value can be created,
Hibernate Search needs to pick a single bridge.
By default, when a custom bridge is assigned to the field,
Hibernate Search will throw an exception because it cannot decide which bridge to pick.

If the bridges assigned to the field in all indexes produce the same result,
it is possible to indicate to Hibernate Search that any bridge will do
by implementing `isCompatibleWith`.

This method accepts another bridge in parameter,
and returns `true` if that bridge can be expected to always behave the same as `this`.

.Implementing `isCompatibleWith` to support multi-index search
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/valuebridge/compatible/ISBNValueBridge.java[tags=include]
----
<1> Implement `isCompatibleWith` as necessary.
Here we just deem any instance of the same class to be compatible.
====

[[mapper-orm-bridge-valuebridge-valuebinder]]
=== Configuring the bridge more finely with `ValueBinder`

To configure a bridge more finely,
it is possible to implement a value binder that will be executed at bootstrap.
This binder will be able in particular to define a custom index field type.

.Implementing a `ValueBinder`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/valuebridge/binder/ISBNValueBinder.java[tags=include]
----
<1> The binder must implement the `ValueBinder` interface.
<2> Implement the `bind` method.
<3> Call `context.setBridge` to define the value bridge to use.
<4> Pass the expected type of property values.
<5> Pass the value bridge instance.
<6> Use the context's type factory to create an index field type.
<7> Pick a base type for the index field using an `as*()` method.
<8> Configure the type as necessary.
This configuration will set defaults that are applied for any type using this bridge,
but they can be overridden.
Type configuration is similar to the attributes found in the various `@*Field` annotations.
See <<mapper-orm-bridge-index-field-type-dsl>> for more information.
<9> The value bridge must still be implemented.
Here the bridge class is nested in the binder class,
because it is more convenient,
but you are obviously free to implement it in a separate java file.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/valuebridge/binder/Book.java[tags=include]
----
<1> This this is unrelated to the value bridge,
but necessary in order for Hibernate ORM to store the data correctly in the database.
<2> Map the property to an index field.
<3> Instruct Hibernate Search to use our custom value binder.
Note the use of `valueBinder` instead of `valueBridge`.
It is also possible to reference the binder by its name, in the case of a CDI/Spring bean.
<4> Customize the field as usual.
Configuration set using annotation attributes take precedence
over the index field type configuration set by the value binder.
For example, in this case, the field with be sortable
even if the binder didn't define the field as sortable.
====

[NOTE]
====
When using a value binder with a specialized `@*Field` annotation,
the index field type must be compatible with the annotation.

For example, `@FullTextField` will only work if the index field type was created using `asString()`.

These restrictions are similar to those when
assigning a value bridge directly;
see <<mapper-orm-bridge-valuebridge-annotation-compatibility>>.
====

=== Accessing the ORM session or session factory from the bridge

Contexts passed to the bridge methods can be used to retrieve the Hibernate ORM session or session factory.

.Retrieving the ORM session or session factory from a `ValueBridge`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/valuebridge/ormcontext/MyDataValueBridge.java[tags=include]
----
<1> Apply an extension to the context to access content specific to Hibernate ORM.
<2> Retrieve the `SessionFactory` from the extended context.
The `Session` is not available here.
<3> Apply an extension to the context to access content specific to Hibernate ORM.
<4> Retrieve the `Session` from the extended context.
====

=== Injecting beans into the value bridge or value binder

With <<configuration-bean-frameworks,compatible frameworks>>,
Hibernate Search supports injection of beans into both the `ValueBridge` and the `ValueBinder`.

NOTE: This only applies to beans instantiated by Hibernate Search itself.
As a rule of thumb, if you need to call `new MyBridge()` at some point,
the bridge won't get auto-magically injected.

The context passed to the value binder's `bind` method
also exposes a `getBeanResolver` method to access the bean resolver and instantiate beans explicitly.

See <<configuration-bean-injection>> for more details.

=== Experimental features

[WARNING]
====
These features are *experimental*.
Usual compatibility policies do not apply: incompatible changes may be introduced in any future release.
====

[[_type_aware_bridge]]
The context passed to the value binder's `bind` method
exposes a `getBridgedElement` method that gives access to metadata about the value being bound,
in particular its type.

See the javadoc for more information.

[[mapper-orm-bridge-propertybridge]]
== Property bridge
// Search 5 anchors backward compatibility
[[section-field-bridge]]

=== Basics

A property bridge, like a <<mapper-orm-bridge-valuebridge,value bridge>>,
is a pluggable component that implements
the mapping of a property to one or more index fields.
It is applied to a property using a custom annotation, specific to each bridge.

Compared to the value bridge, the property bridge is more complex to implement,
but covers a broader range of use cases:

* A property bridge can map a single property to more than one index field.
* A property bridge can support custom parameters, thanks to its custom annotation.
* A property bridge can work correctly when applied to a mutable type,
provided it is implemented correctly.

However, due to its rather flexible nature,
the property bridge does not transparently provide all the features
that come for free with a value bridge.
They can be supported, but have to be implemented manually.
This includes in particular container extractors,
which cannot be combined with a property bridge:
the property bridge must extract container values explicitly.

Implementing a property bridge requires four components:

. A custom annotation, to declare in the entity model that a bridge must be bound to a property.
. A custom implementation of `PropertyMappingAnnotationProcessor`,
to translate the annotation and its attributes into something that Hibernate Search understands: a _binder_.
. A custom implementation of `PropertyBinder`, to bind the bridge to a property at bootstrap.
This involves declaring the parts of the property that will be used,
declaring the index fields that will be populated along with their type,
and instantiating the property bridge.
. A custom implementation of `PropertyBridge`, to perform the conversion at runtime.
This involves extracting data from the property, transforming it if necessary,
and pushing it to index fields.

Below is an example of a custom property bridge that maps
a list of invoice line items
to several fields summarizing the invoice.

// Search 5 anchors backward compatibility
[[example-field-bridge]]
.Implementing and using a `PropertyBridge`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/propertybridge/simple/InvoiceLineItemsSummaryBinding.java[tags=include]
----
<1> Define an annotation with retention `RUNTIME`.
*Any other retention policy will cause the annotation to be ignored by Hibernate Search*.
<2> Since we're defining a property bridge, allow the annotation
to target either methods (getters) or fields.
<3> Mark this annotation as a property mapping,
and instruct Hibernate Search to apply the given processor whenever it finds this annotation.
It is also possible to reference the processor by its name, in the case of a CDI/Spring bean.
<4> Optionally, mark the annotation as documented,
so that it is included in the javadoc of your entities.
<5> The processor must implement the `PropertyMappingAnnotationProcessor` interface,
setting its generic type argument to the type of the corresponding annotation.
Here the processor class is nested in the annotation class,
because it is more convenient,
but you are obviously free to implement it in a separate Java file.
<6> In the `process` method, instantiate the binder
and apply it to the property to which the annotation was applied.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/propertybridge/simple/InvoiceLineItemsSummaryBinder.java[tags=binder]
----
<1> The binder must implement the `PropertyBinder` interface.
<2> Implement the `bind` method in the binder.
<3> Declare the dependencies of the bridge,
i.e. the parts of the property value that the bridge will actually use.
This is *absolutely necessary* in order for Hibernate Search to correctly trigger reindexing
when these parts are modified.
See <<mapper-orm-bridge-bridgedelement-dependencies>>
for more information about declaring dependencies.
<4> Declare the fields that are populated by this bridge.
In this case we're creating a `summary` object field,
which will have multiple sub-fields (see below).
See <<mapper-orm-bridge-index-field-dsl>>
for more information about declaring index fields.
<5> Declare the type of the sub-fields.
We're going to index monetary amounts,
so we will use a `BigDecimal` type with two digits after the decimal point.
See <<mapper-orm-bridge-index-field-type-dsl>>
for more information about declaring index field types.
<6> Call `context.setBridge` to define the property bridge to use,
and pass an instance of the bridge.
<7> Pass a reference to the `summary` object field to the bridge.
<8> Create a sub-field for the `total` amount of the invoice,
a sub-field for the sub-total for `books`,
and a sub-field for the sub-total for `shipping`.
Pass references to these fields to the bridge.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/propertybridge/simple/InvoiceLineItemsSummaryBinder.java[tags=bridge]
----
<1> The bridge must implement the `PropertyBridge` interface.
Here the bridge class is nested in the binder class,
because it is more convenient,
but you are obviously free to implement it in a separate java file.
<2> The bridge stores references to the fields:
it will need them when indexing.
<3> Implement the `write` method in the bridge.
This method is called on indexing.
<4> The bridged element is passed as an `Object`,
so cast it to the correct type.
<5> Extract data from the bridged element,
and optionally transform it.
<6> Add an object to the `summary` object field.
Note the `summary` field was declared at the root,
so we call `addObject` directly on the `target` argument.
<7> Add a value to each of the `summary.total`, `summary.books`
and `summary.shipping` fields.
Note the fields were declared as sub-fields of `summary`,
so we call `addValue` on `summaryValue` instead of `target`.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/propertybridge/simple/Invoice.java[tags=include,!getters-setters]
----
<1> Apply the bridge using its custom annotation.
====

=== Passing parameters
// Search 5 anchors backward compatibility
[[_parameterized_bridge]]

By defining attributes in the property binding annotation,
it is possible to pass parameters to the binder:

// Search 5 anchors backward compatibility
[[example-passing-bridge-parameters]]
.Passing parameters to a `PropertyBinder`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/propertybridge/parameter/InvoiceLineItemsSummaryBinding.java[tags=include]
----
<1> Define an attribute of type `String` to specify the field name.
<2> In the annotation processor, instantiate the binder.
<3> Process the annotation attributes and pass the data to the binder.
Here we're using a setter, but passing the data through the constructor would work, too.
<4> Apply the binder to the property as usual.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/propertybridge/parameter/InvoiceLineItemsSummaryBinder.java[tags=include]
----
<1> Implement setters in the binder.
Alternatively, we could expose a parameterized constructor.
<2> In the `bind` method, use the value of parameters.
Here use the `fieldName` parameter to set the field name,
but we could pass parameters for any purpose:
defining the field as sortable,
defining a normalizer,
...

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/propertybridge/parameter/Invoice.java[tags=include,!getters-setters]
----
<1> Apply the bridge using its custom annotation,
setting the `fieldName` parameter.
====

=== Accessing the ORM session from the bridge

Contexts passed to the bridge methods can be used to retrieve the Hibernate ORM session.

.Retrieving the ORM session from a `PropertyBridge`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/propertybridge/ormcontext/MyDataPropertyBinder.java[tags=include]
----
<1> Apply an extension to the context to access content specific to Hibernate ORM.
<2> Retrieve the `Session` from the extended context.
====

=== Injecting beans into the binder

With <<configuration-bean-frameworks,compatible frameworks>>,
Hibernate Search supports injection of beans into the `PropertyMappingAnnotationProcessor`.

The context passed to the property binder's `bind` method
also exposes a `getBeanResolver` method to access the bean resolver and instantiate beans explicitly.

See <<configuration-bean-injection>> for more details.

=== Experimental features

[WARNING]
====
These features are *experimental*.
Usual compatibility policies do not apply: incompatible changes may be introduced in any future release.
====

The context passed to the property binder's `bind` method
exposes a `getBridgedElement` method that gives access to metadata about the property being bound,
in particular its name and type.

The metadata can also be used to inspect the type of the property in details:

* Getting accessors to properties.
* Detecting properties with markers.
Markers are applied by specific annotations carrying a `@MarkerBinding` meta-annotation.

See the javadoc for more information.

[[mapper-orm-bridge-typebridge]]
== Type bridge
// Search 5 anchors backward compatibility
[[_classbridge]]

=== Basics

A type bridge is a pluggable component that implements
the mapping of a whole type to one or more index fields.
It is applied to a type using a custom annotation, specific to each bridge.

The type bridge is very similar to the property bridge in its core principles and in how it is implemented.
The only (obvious) difference is that the property bridge is applied to properties (fields or getters),
while the type bridge is applied to the type (class or interface).
This entails some slight differences in the APIs exposed to the type bridge.

Implementing a type bridge requires four components:

. A custom annotation, to declare in the entity model that a bridge must be bound to a type.
. A custom implementation of `TypeMappingAnnotationProcessor`,
to translate the annotation and its attributes into something that Hibernate Search understands: a _binder_.
. A custom implementation of `TypeBinder`, to bind the bridge to a type at bootstrap.
This involves declaring the properties of the type that will be used,
declaring the index fields that will be populated along with their type,
and instantiating the type bridge.
. A custom implementation of `TypeBridge`, to perform the conversion at runtime.
This involves extracting data from an instance of the type, transforming the data if necessary,
and pushing it to index fields.

Below is an example of a custom type bridge that maps
a two properties of the `Author` class, the `firstName` and `lastName`,
to a single `fullName` field.

// Search 5 anchors backward compatibility
[[example-class-bridge]]
.Implementing and using a `TypeBridge`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/typebridge/simple/FullNameBinding.java[tags=include]
----
<1> Define an annotation with retention `RUNTIME`.
*Any other retention policy will cause the annotation to be ignored by Hibernate Search*.
<2> Since we're defining a type bridge, allow the annotation to target types.
<3> Mark this annotation as a type mapping,
and instruct Hibernate Search to apply the given binder whenever it finds this annotation.
It is also possible to reference the binder by its name, in the case of a CDI/Spring bean.
<4> Optionally, mark the annotation as documented,
so that it is included in the javadoc of your entities.
<5> The processor must implement the `TypeMappingAnnotationProcessor` interface,
setting its generic type argument to the type of the corresponding annotation.
Here the processor class is nested in the annotation class,
because it is more convenient,
but you are obviously free to implement it in a separate Java file.
<6> In the `process` method, instantiate the binder
and apply it to the type to which the annotation was applied.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/typebridge/simple/FullNameBinder.java[tags=binder]
----
<1> The binder must implement the `TypeBinder` interface.
<2> Implement the `bind` method in the binder.
<3> Declare the dependencies of the bridge,
i.e. the parts of the type instances that the bridge will actually use.
This is *absolutely necessary* in order for Hibernate Search to correctly trigger reindexing
when these parts are modified.
See <<mapper-orm-bridge-bridgedelement-dependencies>>
for more information about declaring dependencies.
<4> Declare the field that will be populated by this bridge.
In this case we're creating a single `fullName` String field.
Multiple index fields can be declared.
See <<mapper-orm-bridge-index-field-dsl>>
for more information about declaring index fields.
<5> Declare the type of the field.
Since we're indexing a full name,
we will use a `String` type with a `name` analyzer (defined separately, see <<concepts-analysis>>).
See <<mapper-orm-bridge-index-field-type-dsl>>
for more information about declaring index field types.
<6> Call `context.setBridge` to define the type bridge to use,
and pass an instance of the bridge.
<7> Pass a reference to the `fullName` field to the bridge.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/typebridge/simple/FullNameBinder.java[tags=bridge]
----
<1> The bridge must implement the `TypeBridge` interface.
Here the bridge class is nested in the binder class,
because it is more convenient,
but you are obviously free to implement it in a separate java file.
<2> The bridge stores references to the fields:
it will need them when indexing.
<3> Implement the `write` method in the bridge.
This method is called on indexing.
<4> The bridged element is passed as an `Object`,
so cast it to the correct type.
<5> Extract data from the bridged element,
and optionally transform it.
<6> Set the value of the `fullName` field.
Note the `fullName` field was declared at the root,
so we call `addValue` directly on the `target` argument.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/typebridge/simple/Author.java[tags=include,!getters-setters]
----
<1> Apply the bridge using its custom annotation.
<2> It is still possible to map properties directly using other annotations,
as long as index field names are distinct from the names used in the type binder.
But no annotation is necessary on the `firstName` and `lastName` properties:
these are already handled by the bridge.
====

=== Passing parameters

By defining attributes on the type binding annotation,
it is possible to pass parameters to the binder:

.Passing parameters to a `TypeBinder`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/typebridge/parameter/FullNameBinding.java[tags=include]
----
<1> Define an attribute of type `boolean` to specify whether a sort field should be added.
<2> In the annotation processor, instantiate the binder.
<3> Process the annotation attributes and pass the data to the binder.
Here we're using a setter, but passing the data through the constructor would work, too.
<4> Apply the binder to the type as usual.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/typebridge/parameter/FullNameBinder.java[tags=include]
----
<1> Implement setters in the binder.
Alternatively, we could expose a parameterized constructor.
<2> In the `bind` method, use the value of parameters.
Here use the `sortField` parameter to decide whether to add a additional, sortable field,
but we could pass parameters for any purpose:
defining the field name,
defining a normalizer,
...

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/typebridge/parameter/Author.java[tags=include,!getters-setters]
----
<1> Apply the bridge using its custom annotation,
setting the `sortField` parameter.
====

=== Accessing the ORM session from the bridge

Contexts passed to the bridge methods can be used to retrieve the Hibernate ORM session.

.Retrieving the ORM session from a `TypeBridge`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/typebridge/ormcontext/MyEntityTypeBinder.java[tags=include]
----
<1> Apply an extension to the context to access content specific to Hibernate ORM.
<2> Retrieve the `Session` from the extended context.
====

=== Injecting beans into the binder

With <<configuration-bean-frameworks,compatible frameworks>>,
Hibernate Search supports injection of beans into the `TypeMappingAnnotationProcessor`.

The context passed to the type binder's `bind` method
also exposes a `getBeanResolver` method to access the bean resolver and instantiate beans explicitly.

See <<configuration-bean-injection>> for more details.

=== Experimental features

[WARNING]
====
These features are *experimental*.
Usual compatibility policies do not apply: incompatible changes may be introduced in any future release.
====

The context passed to the type binder's `bind` method
exposes a `getBridgedElement` method that gives access to metadata about the type being bound.

The metadata can in particular be used to inspect the type in details:

* Getting accessors to properties.
* Detecting properties with markers.
Markers are applied by specific annotations carrying a `@MarkerBinding` meta-annotation.

See the javadoc for more information.

[[mapper-orm-bridge-identifierbridge]]
== Identifier bridges

=== Basics

An identifier bridge is a pluggable component that implements
the mapping of an entity property to a document identifier.
It is applied to a property using the `@DocumentId` annotation.

Implementing an identifier bridge boils down to implementing two methods:

* one method to convert the property value (any type) to the document identifier (a string);
* one method to convert the document identifier back to the original property value.

Below is an example of a custom identifier bridge that converts
a custom `BookId` type to its string representation and back:

.Implementing and using an `IdentifierBridge`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/identifierbridge/simple/BookIdBridge.java[tags=include]
----
<1> The bridge must implement the `IdentifierBridge` interface.
One generic parameters must be provided:
the type of property values (values in the entity model).
<2> The `toDocumentIdentifier` method takes the property value and a context object as parameters,
and is expected to return the corresponding document identifier.
It is called when indexing,
but also when parameters to the search DSL
<<search-dsl-argument-type,must be transformed>>,
in particular for the <<search-dsl-predicate-id,ID predicate>>.
<3> The `fromDocumentIdentifier` methods takes the document identifier and a context object as parameters,
and is expected to return the original property value.
It is called when mapping search hits to the corresponding entity.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/identifierbridge/simple/Book.java[tags=include;!getters-setters]
----
<1> Map the property to the document identifier.
<2> Instruct Hibernate Search to use our custom identifier bridge.
It is also possible to reference the bridge by its name, in the case of a CDI/Spring bean.
====

=== Type resolution

By default, the identifier bridge's property type is determined automatically,
using reflection to extract the generic type argument of the `IdentifierBridge` interface.

For example, in `public class MyBridge implements IdentifierBridge<BookId>`,
the property type is resolved to `BookId`:
the bridge will be applied to properties of type `BookId`.

The fact that the type is resolved automatically using reflection brings a few limitations.
In particular, it means the generic type argument cannot be just anything;
as a general rule, you should stick to literal types (`MyBridge implements IdentifierBridge<BookId>`)
and avoid generic type parameters and wildcards
(`MyBridge<T extends Number> implements IdentifierBridge<T>`,
`MyBridge implements IdentifierBridge<List<? extends Number>>).

If you need more complex types,
you can bypass the automatic resolution and specify types explicitly
using an <<mapper-orm-bridge-identifierbridge-identifierbinder,`IdentifierBinder`>>.

=== Compatibility across indexes with `isCompatibleWith()`

An identifier bridge is involved in indexing,
but also in the search DSLs,
to convert values passed to the <<search-dsl-predicate-id,`id` predicate>>
to a document identifier that the backend will understand.

When creating an `id` predicate targeting multiple entity types (and their indexes),
Hibernate Search will have multiple bridges to choose from: one per entity type.
Since only one predicate with a single value can be created,
Hibernate Search needs to pick a single bridge.

By default, when a custom bridge is assigned to the field,
Hibernate Search will throw an exception because it cannot decide which bridge to pick.

If the bridges assigned to the field in all indexes produce the same result,
it is possible to indicate to Hibernate Search that any bridge will do
by implementing `isCompatibleWith`.

This method accepts another bridge in parameter,
and returns `true` if that bridge can be expected to always behave the same as `this`.

.Implementing `isCompatibleWith` to support multi-index search
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/identifierbridge/compatible/BookOrMagazineIdBridge.java[tags=include]
----
<1> Implement `isCompatibleWith` as necessary.
Here we just deem any instance of the same class to be compatible.
====

[[mapper-orm-bridge-identifierbridge-identifierbinder]]
=== Configuring the bridge more finely with `IdentifierBinder`

To configure a bridge more finely,
it is possible to implement a value binder that will be executed at bootstrap.
This binder will be able in particular to inspect the type of the property.

.Implementing an `IdentifierBinder`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/identifierbridge/binder/BookIdBinder.java[tags=include]
----
<1> The binder must implement the `IdentifierBinder` interface.
<2> Implement the `bind` method.
<3> Call `context.setBridge` to define the identifier bridge to use.
<4> Pass the expected type of property values.
<5> Pass the identifier bridge instance.
<6> The identifier bridge must still be implemented.
Here the bridge class is nested in the binder class,
because it is more convenient,
but you are obviously free to implement it in a separate java file.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/identifierbridge/binder/Book.java[tags=include]
----
<1> Map the property to the document identifier.
<2> Instruct Hibernate Search to use our custom identifier binder.
Note the use of `identifierBinder` instead of `identifierBridge`.
It is also possible to reference the binder by its name, in the case of a CDI/Spring bean.
====

=== Accessing the ORM session or session factory from the bridge

Contexts passed to the bridge methods can be used to retrieve the Hibernate ORM session or session factory.

.Retrieving the ORM session or session factory from an `IdentifierBridge`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/identifierbridge/ormcontext/MyDataIdentifierBridge.java[tags=include]
----
<1> Apply an extension to the context to access content specific to Hibernate ORM.
<2> Retrieve the `SessionFactory` from the extended context.
The `Session` is not available here.
<3> Apply an extension to the context to access content specific to Hibernate ORM.
<4> Retrieve the `Session` from the extended context.
====

=== Injecting beans into the bridge or binder

With <<configuration-bean-frameworks,compatible frameworks>>,
Hibernate Search supports injection of beans into both the `IdentifierBridge` and the `IdentifierBinder`.

NOTE: This only applies to beans instantiated by Hibernate Search itself.
As a rule of thumb, if you need to call `new MyBridge()` at some point,
the bridge won't get auto-magically injected.

The context passed to the identifier binder's `bind` method
also exposes a `getBeanResolver` method to access the bean resolver and instantiate beans explicitly.

See <<configuration-bean-injection>> for more details.

=== Experimental features

[WARNING]
====
These features are *experimental*.
Usual compatibility policies do not apply: incompatible changes may be introduced in any future release.
====

The context passed to the identifier binder's `bind` method
exposes a `getBridgedElement` method that gives access to metadata about the value being bound,
in particular its type.

See the javadoc for more information.

[[mapper-orm-bridge-routingkeybridge]]
== Routing key bridges

=== Basics

include::todo-placeholder.asciidoc[]
//TODO HSEARCH-3709 basic example with annotation, binder, bridge, mapping

=== Passing parameters

include::todo-placeholder.asciidoc[]
//TODO HSEARCH-3709 parameterized example

=== Accessing the ORM session from the bridge

include::todo-placeholder.asciidoc[]
// TODO HSEARCH-3709 HibernateOrmExtension.get()? Make sure to warn that not all operations are valid.

=== Injecting beans into the binder

include::todo-placeholder.asciidoc[]
// TODO HSEARCH-3709 say it's supported, give some basic information and link to <<configuration-bean-injection>>

=== Experimental features

include::todo-placeholder.asciidoc[]
// TODO HSEARCH-3709 experimental support for reflection with getBridgedElement (advanced use, no example)

[[mapper-orm-bridge-bridgedelement-dependencies]]
== Declaring dependencies to bridged elements

include::todo-placeholder.asciidoc[]
// TODO HSEARCH-3710

[[mapper-orm-bridge-index-field-dsl]]
== Declaring index fields

=== Basics

When implementing a <<mapper-orm-bridge-propertybridge,`PropertyBinder`>>
or <<mapper-orm-bridge-typebridge,`TypeBinder`>>,
it is necessary to declare the index fields that the bridge will contribute to.
This declaration is performed using a dedicated DSL.

The entry point to this DSL is the `IndexSchemaElement`.
which represents the part of the document structure that the binder will push data to.

From the `IndexSchemaElement`, it is possible to declare fields.
Below is a simple example using the DSL to declare a single field.

.Declaring a simple index field
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/document/model/dsl/simple/ISBNBinder.java[tags=bind]
----
<1> Get the `IndexSchemaElement`, the entry point to the index field declaration DSL.
<2> Declare a field.
<3> Pass the name of the field.
<4> Declare the type of the field.
This is done through a lambda taking advantage of another DSL.
See <<mapper-orm-bridge-index-field-type-dsl>> for more information.
<5> Get a reference to the declared field.
<6> Pass the reference to the bridge for later use.
====

As shown above, the declaration of each field yields a field _reference_.
This reference is to be stored in the bridge,
which will use it at runtime to set the value of this field in a given document,
represented by a `DocumentElement`.

.Using a field reference to write to a document
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/document/model/dsl/simple/ISBNBinder.java[tags=write]
----
<1> Add a value to the field for the current document.
====

=== Type objects

The lambda syntax to declare the type of each field is convenient,
but sometimes gets in the way,
in particular when multiple fields must be declared with the exact same type.

For that reason, the context object passed to binders exposes a `getIndexFieldTypeFactory()` method.
Using this factory, it is possible to build `IndexFieldType` objects
that can be re-used in multiple field declarations.

.Re-using an index field type in multiple field declarations
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/document/model/dsl/simple/SingleValuedNamesBinder.java[tags=bind]
----
<1> Get the type factory.
<2> Define the type.
<3> Get the resulting type.
<4> Pass the type directly instead of using a lambda when defining the field.
====

=== Multi-valued fields

Fields are considered single-valued by default:
if you attempt to add multiple values to a single-valued field during indexing,
an exception will be thrown.

In order to add multiple values to a field,
this field must be marked as multi-valued during its declaration:

.Declaring a field as multi-valued
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/document/model/dsl/simple/MultiValuedNamesBinder.java[tags=bind]
----
<1> Declare the field as multi-valued.
====

=== Object fields

The previous sections only presented flat schemas with atomic fields,
but the index schema can actually be organized in a tree structure,
with two categories of index fields:

* Value fields, often simply called "fields", which hold an atomic value of a specific type:
string, integer, date, ...
* Object fields, which hold a composite value.

Object fields are declared similarly to value fields,
with an additional step to declare each sub-field,
as shown below.

.Declaring an object field
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/document/model/dsl/object/InvoiceLineItemsSummaryBinder.java[tags=bind]
----
<1> Declare an object field with `objectField`, passing its name in parameter.
<2> Get a reference to the declared object field
and pass it to the bridge for later use.
<3> Create sub-fields, get references to these fields
and pass them to the bridge for later use.
====

[NOTE]
====
The sub-fields of an object field can include object fields.
====

[NOTE]
====
Just as value fields, object fields are single-valued by default.
Be sure to call `.multiValued()` during the object field definition
if you want to make it multi-valued.
====

Object fields as well as their sub-fields are each assigned a reference,
which will be used by the bridge to write to documents,
as shown in the example below.

.Writing to an object field
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/document/model/dsl/object/InvoiceLineItemsSummaryBinder.java[tags=write]
----
<1> Add an object to the `summary` object field for the current document,
and get a reference to to that object.
<2> Add a value to the sub-fields for the object we just added.
Note we're calling `addValue` on the object we just added, not on `target`.
====

=== Object field storage

By default, object fields are flattened,
meaning that the tree structure is not preserved.
See <<mapper-orm-indexedembedded-storage-flattened>> for more information.

It is possible to switch to <<mapper-orm-indexedembedded-storage-nested,nested storage>>
by passing an argument to the `objectField` method, as shown below.
Each value of the object field will then transparently be indexed as a separate nested document,
without any change to the `write` method of the bridge.

.Declaring an object field as nested
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/document/model/dsl/object/InvoiceLineItemsDetailBinder.java[tags=bind]
----
<1> Declare an object field with `objectField`.
<2> Pass the name of the object field.
<3> Pass the storage type of the object field, here `NESTED`.
<4> Declare the object field as multi-valued.
<5> Get a reference to the declared object field
and pass it to the bridge for later use.
<6> Create sub-fields, get references to these fields
and pass them to the bridge for later use.
====

[[mapper-orm-bridge-index-field-type-dsl]]
== Defining index field types

=== Basics

A specificity of Lucene-based search engines (including Elasticsearch) is that field types
are much more complex than just a data type ("string", "integer", ...).

When declaring a field, you must not only declare the data type,
but also various characteristics that will define how the data is stored exactly:
is the field sortable,
is it projectable,
is it analyzed and if so with which analyzer,
...

Because of this complexity,
when field types must be defined in the various binders
(`ValueBinder`, `PropertyBinder`, `TypeBinder`),
they are defined using a dedicated DSL.

The entry point to this DSL is the `IndexFieldTypeFactory`.
The type factory is generally accessible though the context object passed to the binders
(`context.getTypeFactory()`).
In the case of `PropertyBinder` and `TypeBinder`,
the type factory can also be passed to the lambda expression passed to the `field` method
to define the field type inline.

The type factory exposes various `as*()` methods,
for example `asString` or `asLocalDate`.
These are the first steps of the type definition DSL,
where the data type is defined.
They return other steps, from which options
can be set, such as the analyzer.
See below for an example.

.Defining a field type
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/types/dsl/simple/ISBNBinder.java[tags=include]
----
<1> Get the `IndexFieldTypeFactory` from the binding context.
<2> Define the data type.
<3> Define options.
Available options differ based on the field type:
for example, `normalizer` is available for `String` fields,
but not for `Double` fields.
<4> Get the index field type.
====

[NOTE]
====
In `ValueBinder`, the call to `toIndexFieldType()` is omitted:
`context.setBridge(...)` expects to be passed the last DSL step,
not a fully built type.

`toIndexFieldType()` is also omitted in the lambda expressions
passed to the `field` method of
the <<mapper-orm-bridge-index-field-dsl,field declaration DSL>>.
====

=== Available data types

All available data types have a dedicated `as*()` method in `IndexFieldTypeFactory`.
For details, see the javadoc of `IndexFieldTypeFactory`,
or the backend-specific documentation:

* <<backend-lucene-field-types-available,available data types in the Lucene backend>>
* <<backend-elasticsearch-field-types-available,available data types in the Elasticsearch backend>>

=== Available type options

Most of the options available in the index field type DSL are identical
to the options exposed by `@*Field` annotations.
See <<mapper-orm-directfieldmapping-annotation-attributes>> for details about them.

Other options are explained in the following sections.

=== DSL converter

[NOTE]
====
This section is not relevant for `ValueBinder`:
Hibernate Search sets the DSL converter automatically for value bridges,
creating a DSL converter that simply delegates to the value bridge.
====

The various search DSLs expose some methods that expect a field value:
`matching()`, `between()`, `atMost()`, `missingValue().use()`, ...
By default, the expected type will be the same as the data type,
i.e. `String` if you called `asString()`,
`LocalDate` if you called `asLocalDate()`,
etc.

This can be annoying when the bridge converts values from a different type when indexing.
For example, if the bridge converts an enum to a string when indexing,
you probably don't want to pass a string to search predicates,
but rather the enum.

By setting a DSL converter on a field type,
it is possible to change the expected type of values passed to the various DSL,
See below for an example.

.Assigning a DSL converter to a field type
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/types/dsl/dslconverter/ISBNBinder.java[tags=include]
----
<1> Define the data type as `String`.
<2> Define a DSL converter that converts from `ISBN` to `String`.
This converter will be used transparently by the search DSLs.
<3> Define the input type as `ISBN` by passing `ISBN.class` as the first parameter.
<4> Define how to convert an `ISBN` to a `String` by passing a converter as the second parameter.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/types/dsl/dslconverter/IndexFieldTypeDslDslConverterIT.java[tags=include]
----
<1> Thanks to the DSL converter,
predicates targeting fields using our type
accept `ISBN` values by default.
====

NOTE: DSL converters can be disabled in the various DSLs where necessary.
See <<search-dsl-argument-type>>.

=== Projection converter

[NOTE]
====
This section is not relevant for `ValueBinder`:
Hibernate Search sets the projection converter automatically for value bridges,
creating a projection converter that simply delegates to the value bridge.
====

By default, the type of values returned by <<search-dsl-projection-field,field projections>>
or <<search-dsl-aggregation,aggregations>>
will be the same as the data type of the corresponding field,
i.e. `String` if you called `asString()`,
`LocalDate` if you called `asLocalDate()`,
etc.

This can be annoying when the bridge converts values from a different type when indexing.
For example, if the bridge converts an enum to a string when indexing,
you probably don't want projections to return a string,
but rather the enum.

By setting a projection converter on a field type,
it is possible to change the type of values returned by field projections or aggregations.
See below for an example.

.Assigning a projection converter to a field type
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/types/dsl/projectionconverter/ISBNBinder.java[tags=include]
----
<1> Define the data type as `String`.
<2> Define a projection converter that converts from `String` to `ISBN`.
This converter will be used transparently by the search DSLs.
<3> Define the converted type as `ISBN` by passing `ISBN.class` as the first parameter.
<4> Define how to convert a `String` to an `ISBN` by passing a converter as the second parameter.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/types/dsl/projectionconverter/IndexFieldTypeDslProjectionConverterIT.java[tags=include]
----
<1> Thanks to the projection converter,
fields using our type are projected to an `ISBN` by default.
====

NOTE: Projection converters can be disabled in the projection DSL where necessary.
See <<search-dsl-projected-value-type>>.

=== Backend-specific types

Backends define extensions to this DSL
to define backend-specific types.

See:

* <<backend-lucene-field-types-extension,Lucene index field type DSL extension>>
* <<backend-elasticsearch-field-types-extension,Elasticsearch index field type DSL extension>>

[[mapper-orm-bridge-resolver]]
== Assigning default bridges with the bridge resolver
// Search 5 anchors backward compatibility
[[_bridgeprovider_associate_a_bridge_to_a_given_return_type]]

include::todo-placeholder.asciidoc[]

// TODO HSEARCH-3678
