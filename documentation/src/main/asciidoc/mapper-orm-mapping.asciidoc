[[mapper-orm-mapping]]
= Mapping Hibernate ORM entities to indexes
// Search 5 anchors backward compatibility
[[search-mapping]]

[[mapper-orm-mapping-configuration]]
== Configuration

=== Enabling the integration
// Search 5 anchors backward compatibility
[[search-configuration-event]]

The Hibernate ORM integration is enabled by default as soon as it is present in the classpath.
If for some reason you need to disable it,
set the `hibernate.search.enabled` <<configuration-property-types,boolean property>> to `false`.

=== Configuring the mapping

By default, Hibernate Search will automatically process mapping annotations for entity types,
as well as nested types in those entity types, for instance embedded types.
See <<mapper-orm-entityindexmapping>> and <<mapper-orm-directfieldmapping>>
to get started with annotation-based mapping.

If you want to ignore these annotations, set `hibernate.search.mapping.process_annotations` to `false`.

To configure the mapping manually, you can set a mapping configurer.
By setting `hibernate.search.mapping.configurer`
to a <<configuration-property-types,bean reference>> of type `org.hibernate.search.mapper.orm.mapping.HibernateOrmSearchMappingConfigurer`,
you can use a programmatic API to define the mapping.

.Implementing a mapping configurer
====
[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/mappingconfigurer/MySearchMappingConfigurer.java[tags=include]
----
====

See <<mapper-orm-programmatic-mapping>> for more information about the programmatic mapping API.

=== Other configuration properties

Other configuration properties are mentioned in the relevant parts of this documentation.
You can find a full reference of available properties in the Hibernate Search javadoc:
link:{hibernateSearchJavadocUrl}/org/hibernate/search/mapper/orm/cfg/HibernateOrmMapperSettings.html[org.hibernate.search.mapper.orm.cfg.HibernateOrmMapperSettings].

[[mapper-orm-entityindexmapping]]
== Entity/index mapping

In order to index an entity, it must be annotated with `@Indexed`.
All entities not annotated with `@Indexed` will be ignored by the indexing process.

.Marking a class for indexing with `@Indexed`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/entityindexmapping/Book.java[tags=indexed-default]
----
====

By default:

* The index name will be the fully qualified name of the entity.
* The index will be created in the default backend.
See <<getting-started-configuration,the getting stated guide>>
or <<configuration-structure>> for more information about how to configure backends.
* The identifier of indexed documents will be generated from the entity identifier.
Most types commonly used for entity identifiers are supported out of the box,
but for more exotic types you may need specific configuration.
See <<mapper-orm-identifiermapping>> for details.
* The index won't have any field.
Fields must be mapped to properties explicitly.
See <<mapper-orm-directfieldmapping>> for details.

You can change the name of the index by setting `@Indexed(index = ...)`.
Note that index names must be unique in a given application.

.Explicit index name with `@Indexed.index`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/entityindexmapping/Author.java[tags=indexed-explicitindexname]
----
====

If you defined multiple backends, you can map entities to another backend than the default one.
By setting `@Indexed(backend = "backend2")` you inform Hibernate Search that the index
for your entity must be created in the backend named "backend2".
This may be useful if your model has clearly defined sub-parts with very different indexing requirements.

.Explicit backend with `@Indexed.backend`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/entityindexmapping/User.java[tags=indexed-explicitbackend]
----
====

[NOTE]
====
Entities indexed in different backends cannot be targeted by the same query.
For example, with the mappings defined above,
and assuming "backend2" is not the default backend,
the following code will throw an exception,
because `Author` and `User` are indexed in different backends:

[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/entityindexmapping/HibernateOrmIndexedIT.java[tags=cross-backend-search]
----
====

[[mapper-orm-identifiermapping]]
== Mapping the document identifier
// Search 5 anchors backward compatibility
[[id-annotation]]

[[mapper-orm-identifiermapping-basics]]
=== Basics
// Search 5 anchors backward compatibility
[[example-document-id-default-orm]]

Index documents, much like entities, need to be assigned an identifier
so that Hibernate Search can handle updates and deletion.

When indexing Hibernate ORM entities,
the entity identifier is used as a document identifier by default.

Provided the entity identifier has a <<mapper-orm-identifiermapping-supported-types,supported type>>,
identifier mapping will work out of the box and no explicit mapping is necessary.

=== Explicit identifier mapping

Explicit identifier mapping is required in the following cases:

* The document identifier is not the entity identifier.
* OR the entity identifier has a type that is not supported by default.
This is the case of composite identifiers, in particular.

To select a property to map to the document identifier,
just apply the `@DocumentId` annotation to that property:

[[example-document-id-explicit]]
.Mapping a property to the document identifier explicitly with `@DocumentId`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/identifiermapping/naturalid/Book.java[tags=include;!getters-setters]
----
====

When the property type is not supported,
it is also necessary to <<mapper-orm-bridge-identifierbridge,implement a custom identifier bridge>>,
then refer to it in the `@DocumentId` annotation:

.Mapping a property with unsupported type to the document identifier with `@DocumentId`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/identifiermapping/customtype/Book.java[tags=include;!getters-setters]
----
====

[[mapper-orm-identifiermapping-supported-types]]
=== Supported identifier property types
// Search 5 anchors backward compatibility
[[_supported_identifier_types]]

Below is a table listing all types with built-in identifier bridges,
i.e. property types that are supported out of the box
when mapping a property to a document identifier.

The table also explains the value assigned to the document identifier,
i.e. the value passed to the underlying backend.

[cols="l,1",options="header"]
.Property types with built-in identifier bridges
|====
|Property type|Value of document identifiers
|java.lang.String|Unchanged
|java.lang.Short, short|`toString()`
|java.lang.Integer, int|`toString()`
|java.lang.Long, long|`toString()`
|java.math.BigInteger|`toString()`
|All enum types|`name()`
|java.util.UUID|`toString()`
|====

[[mapper-orm-directfieldmapping]]
== Mapping a property to an index field with `@GenericField`, `@FullTextField`, ...

[[mapper-orm-directfieldmapping-basics]]
=== Basics

Properties of an entity can be mapped to an index field directly:
you just need to add an annotation, configure the field through the annotation attributes,
and Hibernate Search will take care of extracting the property value and populating the index field when necessary.

Mapping a property to an index field looks like this:

.Mapping properties to fields directly
====
[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/directfieldmapping/Book.java[tags=direct-field-mapping]
----
<1> Map the `title` property to a full-text field with the same name.
Some options can be set to customize the fields' behavior, in this case the analyzer (for full-text indexing)
and the fact that this field is projectable (its value can be retrieved from the index).
<2> Map the `title` property to *another* field, configured differently:
it is not analyzed, but simply normalized (i.e. it's not split into multiple tokens),
and it is stored in such a way that it can be used in sorts.
+
Mapping a single property to multiple fields is particularly useful when doing full-text search:
at query time, you can use a different field depending on what you need.
You can map a property to as many fields as you want, but each must have a unique name.
<3> Map another property to its own field.
====

Before you map a property, you must consider two things:

The `@*Field` annotation::
In its simplest form, property/field mapping is achieved by applying the `@GenericField` annotation to a property.
This annotation will work for every supported property type, but is rather limited:
it does not allow full-text search in particular.
To go further, you will need to rely on different, more specific annotations,
which offer specific attributes.
The available annotations are described in details in <<mapper-orm-directfieldmapping-annotations>>.
The type of the property::
In order for the `@*Field` annotation to work correctly, the type of the mapped property must be supported by Hibernate Search.
See <<mapper-orm-directfieldmapping-supported-types>> for a list of all types that are supported out of the box,
and <<mapper-orm-directfieldmapping-custom-types>> for indications on how to handle more complex types,
be it simply containers (`List<String>`, `Map<String, Integer>`, ...)
or custom types.

[[mapper-orm-directfieldmapping-annotations]]
=== Available field annotations

Various field annotations exist,
each offering its own set of attributes.

This section lists the different annotations and their use.
For more details about available attributes,
see <<mapper-orm-directfieldmapping-annotation-attributes>>.

`@GenericField`::
A good default choice that will work for every supported property type.
+
Fields mapped using this annotation do not provide any advanced features such as full-text search:
matches on a generic field are exact matches.

[[mapper-orm-directfieldmapping-annotations-fulltextfield]] `@FullTextField`::
A text field whose value is considered as multiple words.
Only works for `String` fields.
+
Matches on a full-text field can be more subtle than exact matches:
match fields which contains a given word,
match fields regardless of case,
match fields ignoring diacritics,
...
+
Full-text fields must be assigned an <<mapper-orm-directfieldmapping-analyzer,analyzer>>, referenced by its name.
See <<concepts-analysis>> for more details about analyzers and full-text analysis.
+
IMPORTANT: Full-text fields cannot be sorted on.
If you need to sort on the value of a property,
it is recommended to use `@KeywordField`, with a normalizer if necessary (see below).
Note that multiple fields can be added to the same property,
so you can use both `@FullTextField` and `@KeywordField` if you need both
full-text search and sorting.

`@KeywordField`::
A text field whose value is considered as a single keyword.
Only works for `String` fields.
+
Keyword fields allow subtle matches, similarly to full-text fields,
with the limitation that keyword fields only contain one token.
On the other hand, this limitation allows keyword fields to be <<mapper-orm-directfieldmapping-sortable,sorted on>>.
+
Keyword fields may be assigned a <<mapper-orm-directfieldmapping-normalizer,normalizer>>, referenced by its name.
See <<concepts-analysis>> for more details about normalizers and full-text analysis.

[[mapper-orm-directfieldmapping-annotations-scalednumberfield]] `@ScaledNumberField`::
A numeric field for integer or floating-point values
that require a higher precision than doubles
but always have roughly the same scale.
Only works for either `java.math.BigDecimal` or `java.math.BigInteger` fields.
+
Scaled numbers are indexed as integers, typically a long (64 bits),
with a fixed scale that is consistent for all values of the field across all documents.
Because scaled numbers are indexed with a fixed precision, they cannot represent all `BigDecimal` or `BigInteger` values.
Values that are too large to be indexed  will trigger a runtime exception.
Values that have trailing decimal digits will be rounded to the nearest integer.
+
This annotation allows to set <<mapper-orm-directfieldmapping-decimalscale, the decimalScale attribute>>.

[[mapper-orm-directfieldmapping-annotation-attributes]]
=== Field annotation attributes

Various field mapping annotations exist,
each offering its own set of attributes.

This section lists the different annotation attributes and their use.
For more details about available annotations,
see <<mapper-orm-directfieldmapping-annotations>>.

`name`::
The name of the index field. By default, it is the same as the property name.
You may want to change it in particular when mapping a single property to multiple fields.
+
Value: `String`. Defaults to the name of the property.

[[mapper-orm-directfieldmapping-sortable]] `sortable`::
Whether the field can be <<search-dsl-sort, sorted on>>,
i.e. whether a specific data structure is added to the index to allow efficient sorts when querying.
+
Value: `Sortable.YES`, `Sortable.NO`, `Sortable.DEFAULT`.
+
[IMPORTANT]
====
This option is not available for `@FullTextField`.
See <<mapper-orm-directfieldmapping-annotations-fulltextfield,here>> for an explanation and some solutions.
====

[[mapper-orm-directfieldmapping-projectable]] `projectable`::
Whether the field can be <<search-dsl-projection, projected on>>,
i.e. whether the field value is stored in the index to allow retrieval later when querying.
+
Value: `Projectable.YES`, `Projectable.NO`, `Projectable.DEFAULT`.

[[mapper-orm-directfieldmapping-aggregable]] `aggregable`::
Whether the field can be <<search-dsl-aggregation, aggregated>>,
i.e. whether the field value is stored in a specific data structure in the index
to allow aggregations later when querying.
+
Value: `Aggregable.YES`, `Aggregable.NO`, `Aggregable.DEFAULT`.

`searchable`::
Whether the field can be searched on.
i.e. whether the field is indexed in order to allow applying predicates later when querying.
+
Value: `Searchable.YES`, `Searchable.NO`, `Searchable.DEFAULT`.

[[mapper-orm-directfieldmapping-indexnullas]] `indexNullAs`::
The value to use as a replacement anytime the property value is null.
+
Disabled by default.
+
[IMPORTANT]
====
The replacement is defined as a String. Thus its value has to be parsed.
Look up the column _Parsing method for 'indexNullAs'_ in <<mapper-orm-directfieldmapping-supported-types>> to find out the format used when parsing.
====

`extraction`::
How elements to index should be extracted from the property in the case of container types
(`List`, `Optional`, `Map`, ...).
+
By default, for properties that have a container type,
the innermost elements will be indexed.
For example for a property of type `List<String>`, elements of type `String` will be indexed.
+
This default behavior and ways to override it are described
in the section <<mapper-orm-containerextractor>>.

[[mapper-orm-directfieldmapping-analyzer]] `analyzer`::
The analyzer to apply to field values when indexing and querying.
Only available on `@FullTextField`.
+
See <<concepts-analysis>> for more details about analyzers and full-text analysis.

[[mapper-orm-directfieldmapping-normalizer]] `normalizer`::
The normalizer to apply to field values when indexing and querying.
Only available on `@KeywordField`.
+
See <<concepts-analysis>> for more details about normalizers and full-text analysis.

`norms`::
Whether index-time scoring information for the field should be stored or not.
Only available on `@KeywordField` and `@FullTextField`.
+
Enabling norms will improve the quality of scoring.
Disabling norms will reduce the disk space used by the index.
+
Value: `Norms.YES`, `Norms.NO`, `Norms.DEFAULT`.

`termVector`::
The term vector storing strategy.
Only available on `@FullTextField`.
+
The different values of this attribute are:
+
[options="header"]
|===============
|Value|Definition
|`TermVector.YES`|Store the term vectors of each document.
	This produces two synchronized arrays, one contains document terms and the other contains the term's frequency.
|`TermVector.NO`|Do not store term vectors.
|`TermVector.WITH_POSITIONS`|Store the term vector and token position information.
	This is the same as `TermVector.YES` plus it contains the ordinal positions of each occurrence of a term in a document.
|`TermVector.WITH_OFFSETS`|Store the term vector and token offset information.
	This is the same as `TermVector.YES` plus it contains the starting and ending offset position information for the terms.
|`TermVector.WITH_POSITION_OFFSETS`|Store the term vector, token position and offset information.
	This is a combination of the `YES`, `WITH_OFFSETS` and `WITH_POSITIONS`.
|`TermVector.WITH_POSITIONS_PAYLOADS`|Store the term vector, token position and token payloads.
	This is the same as `TermVector.WITH_POSITIONS` plus it contains the payload of each occurrence of a term in a document.
|`TermVector.WITH_POSITIONS_OFFSETS_PAYLOADS`|Store the term vector, token position, offset information and token payloads.
	This is the same as `TermVector.WITH_POSITION_OFFSETS` plus it contains the payload of each occurrence of a term in a document.
|===============

[[mapper-orm-directfieldmapping-decimalscale]] `decimalScale`::
How the scale of a large number (`BigInteger` or `BigDecimal`) should be adjusted before it is indexed as a fixed-precision integer.
Only available on `@ScaledNumberField`.
+
To index numbers that have significant digits after the decimal point, set the `decimalScale` to the number of digits you need indexed.
The decimal point will be shifted that many times to the right before indexing, preserving that many digits from the decimal part.
To index very large numbers that cannot fit in a long, set the decimal point to a negative value.
The decimal point will shifted that many times to the left before indexing, dropping all digits from the decimal part.
+
`decimalScale` with strictly positive values is allowed only for `BigDecimal`, since `BigInteger` values have no decimal digits.
+
Note that shifting of the decimal points is completely transparent and will not affect how you use the search DSL:
you be expected to provide "normal" `BigDecimal` or `BigInteger` values,
and Hibernate Search will apply the `decimalScale` and rounding transparently.
+
As a result of the rounding, search predicates and sorts will only be as precise as what the `decimalScale` allows.
+
Note that rounding does not affect projections, which will return the original value without any loss of precision.
+
NOTE: A typical use case is monetary amounts, with a decimal scale of 2
because only two digits are generally needed beyond the decimal point.
+
NOTE: Using Hibernate ORM mapping,
a default `decimalScale` is taken automatically from the underlying `scale` value of the relative SQL `@Column`,
using the Hibernate ORM metadata. The value could be overridden explicitly using the `decimalScale` attribute.

[[mapper-orm-directfieldmapping-spatial-types]]
=== Mapping spatial types
// Search 5 anchors backward compatibility
[[spatial]]

include::todo-placeholder.asciidoc[]

[[mapper-orm-directfieldmapping-supported-types]]
=== Supported property types
// Search 5 anchors backward compatibility
[[section-built-in-bridges]]

Below is a table listing all types with built-in value bridges,
i.e. property types that are supported out of the box
when mapping a property to an index field.

The table also explains the value assigned to the index field,
i.e. the value passed to the underlying backend for indexing.

[NOTE]
====
For information about the underlying indexing and storage used by the backend,
see <<backend-lucene-field-types,Lucene field types>>
or <<backend-elasticsearch-field-types,Elasticsearch field types>> depending on your backend.
====

[cols="l,1,1",options="header"]
.Property types with built-in value bridges
|===
|Property type|Value of index field (if different)| Parsing method for 'indexNullAs'
|All enum types|`name()` as a `java.lang.String`| `Enum.valueOf(String)`
|java.lang.String|- | -
|java.lang.Character, char|A single-character `java.lang.String`| Accepts any single-character `java.lang.String`
|java.lang.Byte, byte|-| `Byte.parseByte(String)`
|java.lang.Short, short|-| `Short.parseShort(String)`
|java.lang.Integer, int|-| `Integer.parseInt(String)`
|java.lang.Long, long|-| `Long.parseLong(String)`
|java.lang.Double, double|-| `Double.parseDouble(String)`
|java.lang.Float, float|-| `Float.parseFloat(String)`
|java.lang.Boolean, boolean|-| Accepts the strings `true` or `false`, ignoring case
|java.math.BigDecimal|-| `new BigDecimal(String)`
|java.math.BigInteger|-| `new BigInteger(String)`
|java.net.URI|`toString()` as a `java.lang.String` | `new URI(String)`
|java.net.URL|`toExternalForm()` as a `java.lang.String`| `new URL(String)`
|java.time.Instant|- | `Instant.parse(String)`
|java.time.LocalDate|- | `LocalDate.parse(String)`
|java.time.LocalTime|- | `LocalTime.parse(String)`
|java.time.LocalDateTime|- | `LocalDateTime.parse(String)`
|java.time.OffsetDateTime|- | `OffsetDateTime.parse(String)`
|java.time.OffsetTime|- | `OffsetTime.parse(String)`
|java.time.ZonedDateTime|- | `ZonedDateTime.parse(String)`
|java.time.ZoneId|`getId()` as a `java.lang.String` | `ZoneId.of(String)`
|java.time.ZoneOffset|`getTotalSeconds()` as a `java.lang.Integer` | `ZoneOffset.of(String)`
|java.time.Period|A formatted `java.lang.String`: `<years on 11 characters><months on 11 characters><days on 11 characters>` |`Period.parse(String)`
|java.time.Duration|`toNanos()` as a `java.lang.Long` | `Duration.parse(String)`
|java.time.Year|- | `Year.parse(String)`
|java.time.YearMonth|- | `YearMonth.parse(String)`
|java.time.MonthDay|- | `MonthDay.parse(String)`
|java.util.UUID|`toString()` as a `java.lang.String` | `UUID.fromString(String)`
|java.util.Calendar|A `java.time.ZonedDateTime` representing the same date/time and timezone; see <<mapper-orm-legacy-date-time-apis>> | `ZonedDateTime.parse(String)`
|java.util.Date|`toInstant()` as a `java.time.Instant`; see <<mapper-orm-legacy-date-time-apis>> | `Instant.parse(String)`
|java.sql.Timestamp|`toInstant()` as a `java.time.Instant`; see <<mapper-orm-legacy-date-time-apis>> | `Instant.parse(String)`
|java.sql.Date|`toInstant()` as a `java.time.Instant`; see <<mapper-orm-legacy-date-time-apis>> | `Instant.parse(String)`
|java.sql.Time|`toInstant()` as a `java.time.Instant`; see <<mapper-orm-legacy-date-time-apis>> | `Instant.parse(String)`
|org.hibernate.search.engine.spatial.GeoPoint and subtypes|-| Latitude as double and longitude as double, separated by a comma. Ex: `41.8919, 12.51133`.
|===

[[mapper-orm-legacy-date-time-apis]]
=== Support for legacy java.util date/time APIs

Using legacy date/time types such as `java.util.Calendar`, `java.util.Date`, `java.sql.Timestamp`, `java.sql.Date`, `java.sql.Time`
is not recommended,
due to their numerous quirks and shortcomings.
The https://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html[`java.time`] package introduced
in Java 8 should generally be preferred.

That being said, integration constraints may force you to rely on the legacy date/time APIs,
which is why Hibernate Search still attempts to support them on a best effort basis.

Since Hibernate Search uses the `java.time` APIs to represent date/time internally,
the legacy date/time types need to be converted before they can be indexed.
Hibernate Search keeps things simple:
`java.util.Date`, `java.util.Calendar`, etc. will be converted using their time-value (number of milliseconds since the epoch),
which will be assumed to represent the same date/time in Java 8 APIs.
In the case of `java.util.Calendar`, timezone information will be preserved for projections.

For all dates after 1900, this will work exactly as expected.

Before 1900, indexing and searching through Hibernate Search APIs will also work as expected,
but *if you need to access the index natively*, for example through direct HTTP calls to an Elasticsearch server,
you will notice that the indexed values are slightly "off".
This is caused by differences in the implementation of `java.time` and legacy date/time APIs
which lead to slight differences in the interpretation of time-values (number of milliseconds since the epoch).

The "drifts" are consistent: they will also happen when building a predicate,
and they will happen in the opposite direction when projecting.
As a result, the differences will not be visible from an application relying on the Hibernate Search APIs exclusively.
They will, however, be visible when accessing indexes natively.

For the large majority of use cases, this will not be a problem.
If this behavior is not acceptable for your application,
you should look into implementing custom <<mapper-orm-bridge-valuebridge,value bridges>>
and instructing Hibernate Search to use them by default for `java.util.Date`, `java.util.Calendar`, etc.:
see <<mapper-orm-bridge-resolver>>.

[TIP]
====
Technically, conversions are difficult because the `java.time` APIs
and the legacy date/time APIs do not have the same internal calendar.

In particular:

* `java.time` assumes a "Local Mean Time" before 1900, while legacy date/time APIs do not support it
(https://bugs.openjdk.java.net/browse/JDK-6281408[JDK-6281408]),
As a result, time values (number of milliseconds since the epoch) reported by the two APIs
will be different for dates before 1900.
* `java.time` uses a proleptic Gregorian calendar before October 15, 1582,
meaning it acts as if the Gregorian calendar, along with its system of leap years, had always existed.
Legacy date/time APIs, on the other hand, use the Julian calendar before that date (by default),
meaning the leap years are not exactly the same ones.
As a result, some dates that are deemed valid by one API will be deemed invalid by the other,
for example February 29, 1500.

Those are the two main problems, but there may be others.
====

[[mapper-orm-directfieldmapping-custom-types]]
=== Mapping custom property types

Even types that are not <<mapper-orm-directfieldmapping-supported-types,supported out of the box>> can be mapped.
There are various solutions, some simple and some more powerful,
but they all come down to extracting data from the unsupported type and converting it to types that are
supported by the backend.

There are two cases to distinguish between:

1. If the unsupported type is simply a container (`List<String>`)
or multiple nested containers (`Map<Integer, List<String>>`)
whose elements have a supported type,
then what you need is a container extractor.
See <<mapper-orm-containerextractor>> for more information.
2. Otherwise, you will have to rely on a custom component, called a bridge, to extract data from your type.
See <<mapper-orm-bridge>> for more information on custom bridges.

[[mapper-orm-indexedembedded]]
== Mapping associated elements with `@IndexedEmbedded`
// Search 5 anchors backward compatibility
[[search-mapping-associated]]

[[mapper-orm-indexedembedded-basics]]
=== Basics

Using only `@Indexed` combined with `@*Field` annotations allows indexing an entity and its direct properties,
which is nice but simplistic.
A real-world model will include multiple object types holding references to one another,
like the `authors` association in the example below.

.A multi-entity model with associations
====
This mapping will declare the following fields in the `Book` index:

* `title`
* ... and nothing else.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/indexedembedded/none/Book.java[tags=include;!getters-setters]
----
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/indexedembedded/none/Author.java[tags=include;!getters-setters]
----
<1> The `Book` entity is indexed.
<2> The `title` of the book is mapped to an index field.
<3> But how to index the `Author` name into the `Book` index?
====

When searching for a book, users will likely need to search by author name.
In the world of high-performance indexes, cross-index joins are costly and usually not an option.
The best way to address such use cases is generally to copy data:
when indexing a `Book`, just copy the name of all its authors into the `Book` document.

That's what `@IndexedEmbedded` does:
it instructs Hibernate Search to _embed_ the fields of an associated object into the main object.
In the example below, it will instruct Hibernate Search to embed the `name` field
defined in `Author` into `Book`, creating the field `authors.name`.

[NOTE]
====
`@IndexedEmbedded` can be used on Hibernate ORM's `@Embedded` properties
as well as associations (`@OneToOne`, `@OneToMany`, `@ManyToMany`, ...).
====

[[example-indexing-associations]]
.Using `@IndexedEmbedded` to index associated elements
====
This mapping will declare the following fields in the `Book` index:

* `title`
* `authors.name`

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/indexedembedded/onelevel/Book.java[tags=include;!getters-setters]
----
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/indexedembedded/onelevel/Author.java[tags=include;!getters-setters]
----
<1> Add an `@IndexedEmbedded` to the `authors` property.
<2> Map `Author.name` to an index field, even though `Author` is not directly mapped to an index (no `@Indexed`).
====

[NOTE]
====
<<mapper-orm-identifiermapping,Document identifiers>> are not index fields.
Consequently, they will be ignored by `@IndexedEmbedded`.

To embed another entity's identifier with `@IndexedEmbedded`,
map that identifier to a field explicitly using `@GenericField` or another `@*Field` annotation.
====

[WARNING]
====
When `@IndexedEmbedded` is applied to an association,
i.e. to a property that refers to entities (like the example above),
*the association must be bi-directional*.
Otherwise, Hibernate Search will throw an exception on startup.

See <<mapper-orm-indexedembedded-reindexing>> for the reasons behind this restriction
and ways to circumvent it.
====

Index-embedding can be nested on multiple levels;
for example you can decide to index-embed the place of birth of authors,
so as to be able to search for books written by Russian authors exclusively:

[[example-nested-index-embedded]]
.Nesting multiple `@IndexedEmbedded`
====
This mapping will declare the following fields in the `Book` index:

* `title`
* `authors.name`
* `authors.placeOfBirth.country`

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/indexedembedded/twolevels/Book.java[tags=include;!getters-setters]
----
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/indexedembedded/twolevels/Author.java[tags=include;!getters-setters]
----
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/indexedembedded/twolevels/Address.java[tags=include;!getters-setters]
----
<1> Add an `@IndexedEmbedded` to the `authors` property.
<2> Map `Author.name` to an index field, even though `Author` is not directly mapped to an index (no `@Indexed`).
<3> Add an `@IndexedEmbedded` to the `placeOfBirth` property.
<4> Map `Address.country` to an index field, even though `Address` is not directly mapped to an index (no `@Indexed`).
====

[WARNING]
====
By default, `@IndexedEmbedded` will nest other `@IndexedEmbedded`
encountered in the indexed-embedded type recursively,
without any sort of limit, which can cause infinite recursion.

To address this, see <<mapper-orm-indexedembedded-filtering>>.
====

[[mapper-orm-indexedembedded-null]]
=== `@IndexedEmbedded` and `null` values
// Search 5 anchors backward compatibility
[[_indexing_null_embeddeds]]

When properties targeted by an `@IndexedEmbedded` contain `null` elements,
these elements are simply not indexed.

On contrary to <<mapper-orm-directfieldmapping>>,
there is no `indexNullAs` feature to index a specific value for `null` objects,
but you can take advantage of the <<search-dsl-predicate-exists,`exists`>> predicate
in search queries to look for documents where a given `@IndexedEmbedded`
has or doesn't have a value:
simply pass the name of the object field to the `exists` predicate,
for example `authors` in the example above.

[[mapper-orm-indexedembedded-multivalued]]
=== `@IndexedEmbedded` on container types

When properties targeted by an `@IndexedEmbedded` have a container type
(`List`, `Optional`, `Map`, ...),
the innermost elements will be embedded.
For example for a property of type `List<MyEntity>`, elements of type `MyEntity` will be embedded.

This default behavior and ways to override it are described
in the section <<mapper-orm-containerextractor>>.

[[mapper-orm-indexedembedded-prefix]]
=== Setting the field name prefix with `prefix`

By default, `@IndexedEmbedded` will prepend the name of embedded fields
with the name of the property it is applied to followed by a dot.
So if `@IndexedEmbedded` is applied to a property named `authors` in a `Book` entity,
the `name` field of the authors will be copied to the `authors.name` field when `Book` is indexed.

It is possible to change this prefix by setting the `prefix` attribute,
for example `@IndexedEmbedded(prefix = "author.")` (do not forget the trailing dot!).

[CAUTION]
====
The prefix should generally be a sequence of non-dots ending with a single dot, for example `my_Property.`.

Changing the prefix to a string that does not include any dot at the end (`my_Property`),
or that includes a dot anywhere but at the very end (`my.Property.`),
will lead to complex, undocumented, legacy behavior.
Do this at your own risk.
====

[[mapper-orm-indexedembedded-reindexing]]
=== Reindexing when embedded elements change
// Search 5 anchors backward compatibility
[[_associated_objects_building_a_dependency_graph_with_containedin]]

When the "embedded" entity changes,
Hibernate Search will handle reindexing of the "embedding" entity.

This will work transparently most of the time,
as long as the association `@IndexedEmbedded` is applied to is bi-directional
(uses Hibernate ORM's `mappedBy`).

When Hibernate Search is unable to handle an association,
it will throw an exception on bootstrap.
If this happens, refer to <<mapper-orm-reindexing-basics>> to know more.

[[mapper-orm-indexedembedded-filtering]]
=== Filtering embedded fields and breaking `@IndexedEmbedded` cycles
// Search 5 anchors backward compatibility
[[search-mapping-associated-viapaths]]

By default, `@IndexedEmbedded` will "embed" everything:
every field encountered in the indexed-embedded element,
and every `@IndexedEmbedded` encountered in the indexed-embedded element,
recursively.

This will work just fine for simpler use cases, but may lead to problems for more complex models:

* If the indexed-embedded element declares many index fields (Hibernate Search fields),
only some of which are actually useful to the "index-embedding" type,
the extra fields will decrease indexing performance needlessly.
* If there is a cycle of `@IndexedEmbedded`
(e.g. `A` index-embeds `b` of type `B`, which index-embeds `a` of type `A`)
the index-embedding type will end up with an infinite amount of fields
(`a.b.someField`, `a.b.a.b.someField`, `a.b.a.b.a.b.someField`, ...),
which Hibernate Search will detect and reject with an exception.

To address these problems, it is possible to filter the fields to embed,
to only include those that are actually useful.
Two filtering attributes are available on `@IndexedEmbedded` and may be combined:

`includePaths`::
The paths of index fields from the indexed-embedded element that should be embedded.
+
Provided paths must be relative to the indexed-embedded element,
i.e. they must not include the <<mapper-orm-indexedembedded-prefix,prefix>>.
+
This takes precedence over `maxDepth` (see below).
`maxDepth`::
The max recursion depth for indexed-embedded processing.
+
`maxDepth` is the number of `@IndexedEmbedded` that will be traversed
and for which all fields of the indexed-embedded element will be included,
even if these fields are not included explicitly through `includePaths`:
+
 * `maxDepth=0` means fields of the indexed-embedded element are *not* included,
nor is any field of nested indexed-embedded elements,
unless these fields are included explicitly through `includePaths`.
 * `maxDepth=1` means fields of the indexed-embedded element *are* included,
but *not* fields of nested indexed-embedded elements,
unless these fields are included explicitly through `includePaths`.
 * And so on.
+
The default value depends on the value of the `includePaths` attribute:
if `includePaths` is empty, the default is `Integer.MAX_VALUE` (no limit)
if `includePaths` is *not* empty, the default is `0`
(only include fields included explicitly).

Below are two examples: one leveraging `includePaths` only,
and one leveraging `includePaths` and `maxDepth`.

[[indexedembedded-includePath]]
.Filtering indexed-embedded fields with `includePaths`
====
This mapping will declare the following fields in the `Human` index:

* `name`
* `nickname`
* `parents.name` (explicitly included using `includePaths`)
* `parents.nickname` (explicitly included using `includePaths`)
* `parents.parents.name` (explicitly included using `includePaths`)

`parents.nickname`, `parents.parents.parents.name`
and other fields not mentioned in the list above will be excluded,
because `maxDepth` defaults to `0` when `includePaths` is used.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/indexedembedded/includepaths/Human.java[tags=include;!getters-setters]
----
====

[[indexedembedded-includePathsAndDepth]]
.Filtering indexed-embedded fields with `includePaths` and `maxDepth`
====
This mapping will declare the following fields in the `Human` index:

* `name`
* `surname`
* `parents.name` (implicitly included because `maxDepth >= 1`)
* `parents.nickname` (implicitly included because `maxDepth >= 1`)
* `parents.parents.name` (implicitly included because `maxDepth >= 2`)
* `parents.parents.nickname` (implicitly included because `maxDepth >= 2`)
* `parents.parents.parents.name` (explicitly included using `includePaths` even though `maxDepth < 3`)

`parents.parents.parents.nickname`, `parents.parents.parents.parents.name`
and other fields not mentioned in the list above will be excluded,
because `maxDepth` is explicitly set to `3`.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/indexedembedded/includepathsanddepth/Human.java[tags=include;!getters-setters]
----
====

[[mapper-orm-indexedembedded-storage]]
=== Storing embedded elements in nested documents using `storage`

Indexed-embedded fields can be stored in one of two ways,
configured through the `storage` attribute of the `@IndexedEmbedded` annotation.
To illustrate storage options, let's consider the following object tree,
assuming the class `Book` is annotated with `@Indexed`
and its `authors` property is annotated with  `@IndexedEmbedded`:

* Book instance
** title = Levianthan Wakes
** authors =
*** Author instance
**** firstName = Daniel
**** lastName = Abraham
*** Author instance
**** firstName = Ty
**** lastName = Frank

==== `DEFAULT` or `FLATTENED` storage

By default, indexed-embedded fields are "flattened",
meaning that the tree structure is not preserved.

The book instance mentioned above would be indexed with a structure roughly similar to this:

 * Book document
 ** title = Levianthan Wakes
 ** authors.firstName = [Daniel, Ty]
 ** authors.lastName = [Abraham, Frank]

The `authors.firstName` and `authors.lastName` fields were "flattened"
and now each has two values;
the knowledge of which last name corresponds to which first name has been lost.

This is more efficient for storage and querying,
but can cause unexpected behavior when querying the index
on both the author's first name and the author's last name.
The book given in example
would show up as a match to a query such as `authors.firstname:Ty AND authors.lastname:Abraham`,
even though "Ty Abraham" is not one of this book's authors.

==== `NESTED` storage

When indexed-embedded elements are "nested",
the tree structure is preserved by transparently creating one separate "nested" document
for every indexed-embedded element.

The book instance mentioned above would be indexed with a structure roughly similar to this:

 * Book document
 ** title = Levianthan Wakes
 ** Nested documents
 *** Nested documents for "authors"
 **** authors.firstName = Daniel
 **** authors.lastName = Abraham
 *** Nested documents for "authors"
 **** authors.firstName = Ty
 **** authors.lastName = Frank

The book is effectively indexed as three documents:
the root document for the book, and two internal, "nested" documents for the authors,
preserving the knowledge of which last name corresponds to which first name
at the cost of degraded performance when indexing and querying.

NOTE: The nested documents are "hidden" and won't directly show up in search results.
No need to worry about nested documents being "mixed up" with root documents.

If special care is taken when building predicates on fields within nested documents,
using a <<search-dsl-predicate-nested,`nested` predicate>>,
queries containing predicates on both the author's first name and the author's last name
will behave as one would (intuitively) expect.
The book given in example
would *not* show up as a match to a query such as `authors.firstname:Ty AND authors.lastname:Abraham`,
as long as a `nested` predicate is used.

[[mapper-orm-containerextractor]]
== Mapping container types with container extractors

=== Basics

Most built-in annotations applied to properties will work transparently when applied to container types:

* `@GenericField` applied to a property of type `String` will index the property value directly.
* `@GenericField` applied to a property of type `OptionalInt` will index the optional's value (an integer).
* `@GenericField` applied to a property of type `List<String>` will index the list elements (strings).
* `@GenericField` applied to a property of type `Map<Integer, String>` will index the map values (strings).
* `@GenericField` applied to a property of type `Map<Integer, List<String>>` will index the list elements in the map values (strings).
* Etc.

Same goes for other field annotations such as `@FullTextField`,
as well as `@IndexedEmbedded` in particular.

What happens behind the scenes is that Hibernate Search will inspect the property type
and attempt to apply "container extractors", picking the first that works.

=== Explicit container extraction

In some cases, you will want to pick the container extractors to use explicitly.
This is the case when a map's keys must be indexed, instead of the values.
Relevant annotations offer an `extraction` attribute to configure this,
as shown in the example below.

TIP: All built-in extractor names are available as constants
in `org.hibernate.search.mapper.pojo.extractor.builtin.BuiltinContainerExtractors`.

.Mapping map keys to an index field using explicit container extractor definition
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/containerextractor/Book.java[tags=explicit-extractor]
----
<1> This annotation, and those below, are just Hibernate ORM configuration.
<2> Declare an index field based on the `priceByFormat` property.
<3> By default, Hibernate Search would index the map values (the book prices).
This uses the `extraction` attribute to specify that map keys (the book formats)
must be indexed instead.
====

TIP: When multiple levels of extractions are necessary,
multiple extractors can be configured:
`extraction = @ContainerExtraction(BuiltinContainerExtractors.MAP_KEY, BuiltinContainerExtractors.OPTIONAL)`.
However, such complex mappings are unlikely since they are generally not supported by Hibernate ORM.

[NOTE]
====
It is possible to implement and use custom container extractors,
but at the moment these extractors will not be handled correctly for automatic reindexing,
so the corresponding property must <<mapper-orm-reindexing-reindexonupdate,have automatic reindexing disabled>>.

See https://hibernate.atlassian.net/browse/HSEARCH-3688[HSEARCH-3688] for more information.
====

=== Disabling container extraction

In some rare cases, container extraction is not wanted,
and the `@GenericField`/`@IndexedEmbedded` is meant to be applied to the `List`/`Optional`/etc. directly.
To ignore the default container extractors,
most annotations offer an `extraction` attribute.
Set it as below to disable extraction altogether:

.Disabling container extraction
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/containerextractor/Book.java[tags=no-extractor]
----
<1> Declare an index field based on the `authors` property.
<2> Instruct Hibernate Search to use the given bridge,
which will extract the collection size (the number of authors).
<3> Because the bridge is applied to the collection as a whole,
and not to each author,
the `extraction` attribute is used to disable container extraction.
====

[[mapper-orm-reindexing]]
== Tuning automatic reindexing

[[mapper-orm-reindexing-basics]]
=== Basics

include::todo-placeholder.asciidoc[]
// TODO

[[mapper-orm-reindexing-associationinverseside]]
=== Enriching the entity model with `@AssociationInverseSide`

include::todo-placeholder.asciidoc[]
// TODO

[[mapper-orm-reindexing-derivedfrom]]
=== Reindexing when a derived value changes with `@IndexingDependency`

include::todo-placeholder.asciidoc[]
// TODO

[[mapper-orm-reindexing-reindexonupdate]]
=== Disabling reindexing with `@IndexingDependency`

include::todo-placeholder.asciidoc[]
// TODO

[[mapper-orm-bridge]]
== Bridges
// Search 5 anchors backward compatibility
[[search-mapping-bridge]]

include::todo-placeholder.asciidoc[]

////
TODO The getting started section has a link pointing here and expects the section to
include a detailed description of how to define and use bridges.
////

Starting with Hibernate Search 6, there are five separate interfaces for bridges:

* <<mapper-orm-bridge-valuebridge,`ValueBridge`>> can be used for simple use cases when mapping an object's property.
+
The `ValueBridge` is applied at the property level using one of the pre-defined `@*Field` annotations:
`@GenericField`, `@FullTextField`, ...
+
`ValueBridge` is a suitable interface for your custom bridge if:
+
** The property value should be mapped to a single index field.
** The bridge should be applied to a property whose type is effectively immutable.
For example `Integer`, or a custom `enum` type, or a custom bean type whose content never changes would be suitable candidates,
but a custom bean type with setters would most definitely not.
* <<mapper-orm-bridge-typeandpropertybridge,`PropertyBridge`>> can be used for more complex uses cases when mapping an object's property.
+
The `PropertyBridge` is applied at the property level using a custom annotation.
+
`PropertyBridge` can be used even if the property being mapped has a mutable type,
or if its value should be mapped to multiple index fields.
* <<mapper-orm-bridge-typeandpropertybridge,`TypeBridge`>> should be used when mapping multiple properties of an object, potentially combining them in the process.
+
The `TypeBridge` is applied at the type level using a custom annotation.
+
Similarly to `PropertyBridge`, `TypeBridge` can be used even if the properties being mapped have a mutable type,
or if their values should be mapped to multiple index fields.
* <<mapper-orm-bridge-identifierbridge,`IdentifierBridge`>> can be used together with `@DocumentId`
to map an unusual entity identifier to a document identifier.
* <<mapper-orm-bridge-routingkeybridge,`RoutingKeyBridge`>> can be used to define a "routing key",
i.e. a key that will be used to determine the shard where corresponding documents must be stored in the index.

You can find example of custom bridges in the
https://github.com/hibernate/hibernate-search[Hibernate Search source code]:

* `org.hibernate.search.integrationtest.showcase.library.bridge.ISBNBridge` implements `ValueBridge`.
* `org.hibernate.search.integrationtest.showcase.library.bridge.MultiKeywordStringBridge` implements `PropertyBridge`.
The corresponding annotation is `org.hibernate.search.integrationtest.showcase.library.bridge.annotation.MultiKeywordStringBridge`.
* `org.hibernate.search.integrationtest.showcase.library.bridge.AccountBorrowalSummaryBridge` implements `TypeBridge`.
The corresponding annotation is `org.hibernate.search.integrationtest.showcase.library.bridge.annotation.AccountBorrowalSummaryBridge`.

[[mapper-orm-bridge-valuebridge]]
=== Value bridges

include::todo-placeholder.asciidoc[]

[[mapper-orm-bridge-typeandpropertybridge]]
=== Type bridges and property bridges

include::todo-placeholder.asciidoc[]

[[mapper-orm-bridge-identifierbridge]]
=== Identifier bridges

include::todo-placeholder.asciidoc[]

[[mapper-orm-bridge-routingkeybridge]]
=== Routing key bridges

include::todo-placeholder.asciidoc[]

[[mapper-orm-bridge-resolver]]
=== Default bridge resolver

include::todo-placeholder.asciidoc[]

[[mapper-orm-programmatic-mapping]]
== Programmatic mapping
// Search 5 anchors backward compatibility
[[hsearch-mapping-programmaticapi]]

include::todo-placeholder.asciidoc[]

////
TODO Detailed description of the programmatic mapping API.
////