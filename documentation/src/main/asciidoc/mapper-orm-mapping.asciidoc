[[mapper-orm-mapping]]
= Mapping Hibernate ORM entities to indexes
// Search 5 anchors backward compatibility
[[search-mapping]]

[[mapper-orm-mapping-configuration]]
== Configuration

=== Enabling/disabling Hibernate Search
// Search 5 anchors backward compatibility
[[search-configuration-event]]

The Hibernate Search integration into Hibernate ORM is enabled by default as soon as it is present in the classpath.
If for some reason you need to disable it,
set the `hibernate.search.enabled` <<configuration-property-types,boolean property>> to `false`.

=== Configuring the mapping

By default, Hibernate Search will automatically process mapping annotations for entity types,
as well as nested types in those entity types, for instance embedded types.
See <<mapper-orm-entityindexmapping>> and <<mapper-orm-directfieldmapping>>
to get started with annotation-based mapping.

If you want to ignore these annotations, set `hibernate.search.mapping.process_annotations` to `false`.

To configure the mapping manually, you can set a mapping configurer.
By setting `hibernate.search.mapping.configurer`
to a <<configuration-property-types,bean reference>> of type `org.hibernate.search.mapper.orm.mapping.HibernateOrmSearchMappingConfigurer`,
you can use a programmatic API to define the mapping.

.Implementing a mapping configurer
====
[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/mappingconfigurer/MySearchMappingConfigurer.java[tags=include]
----
====

See <<mapper-orm-programmatic-mapping>> for more information about the programmatic mapping API.

=== Other configuration properties

Other configuration properties are mentioned in the relevant parts of this documentation.
You can find a full reference of available properties in the Hibernate Search javadoc:
link:{hibernateSearchJavadocUrl}/org/hibernate/search/mapper/orm/cfg/HibernateOrmMapperSettings.html[org.hibernate.search.mapper.orm.cfg.HibernateOrmMapperSettings].

[[mapper-orm-entityindexmapping]]
== Entity/index mapping

In order to index an entity, it must be annotated with `@Indexed`.
All entities not annotated with `@Indexed` will be ignored by the indexing process.

.Marking a class for indexing with `@Indexed`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/entityindexmapping/Book.java[tags=indexed-default]
----
====

By default:

* The index name will be equal to the entity name,
which in Hibernate ORM is set using the `@Entity` annotation
and defaults to the simple class name.
* The index will be created in the default backend.
See <<getting-started-configuration,the getting stated guide>>
or <<configuration-structure>> for more information about how to configure backends.
* The identifier of indexed documents will be generated from the entity identifier.
Most types commonly used for entity identifiers are supported out of the box,
but for more exotic types you may need specific configuration.
See <<mapper-orm-identifiermapping>> for details.
* The index won't have any field.
Fields must be mapped to properties explicitly.
See <<mapper-orm-directfieldmapping>> for details.

You can change the name of the index by setting `@Indexed(index = ...)`.
Note that index names must be unique in a given application.

.Explicit index name with `@Indexed.index`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/entityindexmapping/Author.java[tags=indexed-explicitindexname]
----
====

If you defined multiple backends, you can map entities to another backend than the default one.
By setting `@Indexed(backend = "backend2")` you inform Hibernate Search that the index
for your entity must be created in the backend named "backend2".
This may be useful if your model has clearly defined sub-parts with very different indexing requirements.

.Explicit backend with `@Indexed.backend`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/entityindexmapping/User.java[tags=indexed-explicitbackend]
----
====

[NOTE]
====
Entities indexed in different backends cannot be targeted by the same query.
For example, with the mappings defined above,
and assuming "backend2" is not the default backend,
the following code will throw an exception,
because `Author` and `User` are indexed in different backends:

[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/entityindexmapping/HibernateOrmIndexedIT.java[tags=cross-backend-search]
----
====

[[mapper-orm-identifiermapping]]
== Mapping the document identifier
// Search 5 anchors backward compatibility
[[id-annotation]]

[[mapper-orm-identifiermapping-basics]]
=== Basics
// Search 5 anchors backward compatibility
[[example-document-id-default-orm]]

Index documents, much like entities, need to be assigned an identifier
so that Hibernate Search can handle updates and deletion.

When indexing Hibernate ORM entities,
the entity identifier is used as a document identifier by default.

Provided the entity identifier has a <<mapper-orm-identifiermapping-supported-types,supported type>>,
identifier mapping will work out of the box and no explicit mapping is necessary.

=== Explicit identifier mapping

Explicit identifier mapping is required in the following cases:

* The document identifier is not the entity identifier.
* OR the entity identifier has a type that is not supported by default.
This is the case of composite identifiers, in particular.

To select a property to map to the document identifier,
just apply the `@DocumentId` annotation to that property:

[[example-document-id-explicit]]
.Mapping a property to the document identifier explicitly with `@DocumentId`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/identifiermapping/naturalid/Book.java[tags=include;!getters-setters]
----
====

When the property type is not supported,
it is also necessary to <<mapper-orm-bridge-identifierbridge,implement a custom identifier bridge>>,
then refer to it in the `@DocumentId` annotation:

.Mapping a property with unsupported type to the document identifier with `@DocumentId`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/identifiermapping/customtype/Book.java[tags=include;!getters-setters]
----
====

[[mapper-orm-identifiermapping-supported-types]]
=== Supported identifier property types
// Search 5 anchors backward compatibility
[[_supported_identifier_types]]

Below is a table listing all types with built-in identifier bridges,
i.e. property types that are supported out of the box
when mapping a property to a document identifier.

The table also explains the value assigned to the document identifier,
i.e. the value passed to the underlying backend.

[cols="l,1",options="header"]
.Property types with built-in identifier bridges
|====
|Property type|Value of document identifiers
|java.lang.String|Unchanged
|java.lang.Short, short|`toString()`
|java.lang.Integer, int|`toString()`
|java.lang.Long, long|`toString()`
|java.math.BigInteger|`toString()`
|All enum types|`name()`
|java.util.UUID|`toString()`
|====

[[mapper-orm-directfieldmapping]]
== Mapping a property to an index field with `@GenericField`, `@FullTextField`, ...

[[mapper-orm-directfieldmapping-basics]]
=== Basics

Properties of an entity can be mapped to an index field directly:
you just need to add an annotation, configure the field through the annotation attributes,
and Hibernate Search will take care of extracting the property value and populating the index field when necessary.

Mapping a property to an index field looks like this:

.Mapping properties to fields directly
====
[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/directfieldmapping/Book.java[tags=direct-field-mapping]
----
<1> Map the `title` property to a full-text field with the same name.
Some options can be set to customize the fields' behavior, in this case the analyzer (for full-text indexing)
and the fact that this field is projectable (its value can be retrieved from the index).
<2> Map the `title` property to *another* field, configured differently:
it is not analyzed, but simply normalized (i.e. it's not split into multiple tokens),
and it is stored in such a way that it can be used in sorts.
+
Mapping a single property to multiple fields is particularly useful when doing full-text search:
at query time, you can use a different field depending on what you need.
You can map a property to as many fields as you want, but each must have a unique name.
<3> Map another property to its own field.
====

Before you map a property, you must consider two things:

The `@*Field` annotation::
In its simplest form, property/field mapping is achieved by applying the `@GenericField` annotation to a property.
This annotation will work for every supported property type, but is rather limited:
it does not allow full-text search in particular.
To go further, you will need to rely on different, more specific annotations,
which offer specific attributes.
The available annotations are described in details in <<mapper-orm-directfieldmapping-annotations>>.
The type of the property::
In order for the `@*Field` annotation to work correctly, the type of the mapped property must be supported by Hibernate Search.
See <<mapper-orm-directfieldmapping-supported-types>> for a list of all types that are supported out of the box,
and <<mapper-orm-directfieldmapping-custom-types>> for indications on how to handle more complex types,
be it simply containers (`List<String>`, `Map<String, Integer>`, ...)
or custom types.

[[mapper-orm-directfieldmapping-annotations]]
=== Available field annotations

Various field annotations exist,
each offering its own set of attributes.

This section lists the different annotations and their use.
For more details about available attributes,
see <<mapper-orm-directfieldmapping-annotation-attributes>>.

`@GenericField`::
A good default choice that will work for every property type with built-in support.
+
Fields mapped using this annotation do not provide any advanced features such as full-text search:
matches on a generic field are exact matches.

[[mapper-orm-directfieldmapping-annotations-fulltextfield]] `@FullTextField`::
A text field whose value is considered as multiple words.
Only works for `String` fields.
+
Matches on a full-text field can be more subtle than exact matches:
match fields which contains a given word,
match fields regardless of case,
match fields ignoring diacritics,
...
+
Full-text fields must be assigned an <<mapper-orm-directfieldmapping-analyzer,analyzer>>, referenced by its name.
See <<concepts-analysis>> for more details about analyzers and full-text analysis.
Moreover, you can define <<mapper-orm-directfieldmapping-search-analyzer,a specific analyzer>>
a search analyzer to analyze searched terms differently.
+
IMPORTANT: Full-text fields cannot be sorted on.
If you need to sort on the value of a property,
it is recommended to use `@KeywordField`, with a normalizer if necessary (see below).
Note that multiple fields can be added to the same property,
so you can use both `@FullTextField` and `@KeywordField` if you need both
full-text search and sorting.

`@KeywordField`::
A text field whose value is considered as a single keyword.
Only works for `String` fields.
+
Keyword fields allow subtle matches, similarly to full-text fields,
with the limitation that keyword fields only contain one token.
On the other hand, this limitation allows keyword fields to be <<mapper-orm-directfieldmapping-sortable,sorted on>>.
+
Keyword fields may be assigned a <<mapper-orm-directfieldmapping-normalizer,normalizer>>, referenced by its name.
See <<concepts-analysis>> for more details about normalizers and full-text analysis.

[[mapper-orm-directfieldmapping-annotations-scalednumberfield]] `@ScaledNumberField`::
A numeric field for integer or floating-point values
that require a higher precision than doubles
but always have roughly the same scale.
Only works for either `java.math.BigDecimal` or `java.math.BigInteger` fields.
+
Scaled numbers are indexed as integers, typically a long (64 bits),
with a fixed scale that is consistent for all values of the field across all documents.
Because scaled numbers are indexed with a fixed precision, they cannot represent all `BigDecimal` or `BigInteger` values.
Values that are too large to be indexed  will trigger a runtime exception.
Values that have trailing decimal digits will be rounded to the nearest integer.
+
This annotation allows to set <<mapper-orm-directfieldmapping-decimalscale, the decimalScale attribute>>.

`@NonStandardField`::
An annotation for advanced use cases
where a <<mapper-orm-bridge-valuebridge-valuebinder,value binder>> is used
and that binder is expected to define an index field type that does not support
any of the standard options: `searchable`, `sortable`, ...
+
This annotation is very useful for cases when a field type native to the backend is necessary:
<<backend-elasticsearch-field-types-extension,defining the mapping directly as JSON>> for Elasticsearch,
or <<backend-lucene-field-types-extension,manipulating `IndexableField` directly>> for Lucene.
+
Fields mapped using this annotation have very limited configuration options from the annotation
(no `searchable`/`sortable`/etc.),
but the value binder will be able to pick a non-standard field type,
which generally gives much more flexibility.

[[mapper-orm-directfieldmapping-annotation-attributes]]
=== Field annotation attributes

Various field mapping annotations exist,
each offering its own set of attributes.

This section lists the different annotation attributes and their use.
For more details about available annotations,
see <<mapper-orm-directfieldmapping-annotations>>.

`name`::
The name of the index field. By default, it is the same as the property name.
You may want to change it in particular when mapping a single property to multiple fields.
+
Value: `String`. Defaults to the name of the property.

[[mapper-orm-directfieldmapping-sortable]] `sortable`::
Whether the field can be <<search-dsl-sort, sorted on>>,
i.e. whether a specific data structure is added to the index to allow efficient sorts when querying.
+
Value: `Sortable.YES`, `Sortable.NO`, `Sortable.DEFAULT`.
+
[IMPORTANT]
====
This option is not available for `@FullTextField`.
See <<mapper-orm-directfieldmapping-annotations-fulltextfield,here>> for an explanation and some solutions.
====

[[mapper-orm-directfieldmapping-projectable]] `projectable`::
Whether the field can be <<search-dsl-projection, projected on>>,
i.e. whether the field value is stored in the index to allow retrieval later when querying.
+
Value: `Projectable.YES`, `Projectable.NO`, `Projectable.DEFAULT`.

[[mapper-orm-directfieldmapping-aggregable]] `aggregable`::
Whether the field can be <<search-dsl-aggregation, aggregated>>,
i.e. whether the field value is stored in a specific data structure in the index
to allow aggregations later when querying.
+
Value: `Aggregable.YES`, `Aggregable.NO`, `Aggregable.DEFAULT`.

`searchable`::
Whether the field can be searched on.
i.e. whether the field is indexed in order to allow applying predicates later when querying.
+
Value: `Searchable.YES`, `Searchable.NO`, `Searchable.DEFAULT`.

[[mapper-orm-directfieldmapping-indexnullas]] `indexNullAs`::
The value to use as a replacement anytime the property value is null.
+
Disabled by default.
+
[IMPORTANT]
====
The replacement is defined as a String. Thus its value has to be parsed.
Look up the column _Parsing method for 'indexNullAs'_ in <<mapper-orm-directfieldmapping-supported-types>> to find out the format used when parsing.
====

`extraction`::
How elements to index should be extracted from the property in the case of container types
(`List`, `Optional`, `Map`, ...).
+
By default, for properties that have a container type,
the innermost elements will be indexed.
For example for a property of type `List<String>`, elements of type `String` will be indexed.
+
This default behavior and ways to override it are described
in the section <<mapper-orm-containerextractor>>.

[[mapper-orm-directfieldmapping-analyzer]] `analyzer`::
The analyzer to apply to field values when indexing and querying.
Only available on `@FullTextField`.
+
See <<concepts-analysis>> for more details about analyzers and full-text analysis.

[[mapper-orm-directfieldmapping-search-analyzer]] `searchAnalyzer`::
An optional different analyzer, overriding the one defined with the `analyzer` attribute,
to use only when analyzing searched terms.
If not defined, the same `analyzer` will be used.
+
See <<concepts-analysis>> for more details about analyzers and full-text analysis.

[[mapper-orm-directfieldmapping-normalizer]] `normalizer`::
The normalizer to apply to field values when indexing and querying.
Only available on `@KeywordField`.
+
See <<concepts-analysis>> for more details about normalizers and full-text analysis.

`norms`::
Whether index-time scoring information for the field should be stored or not.
Only available on `@KeywordField` and `@FullTextField`.
+
Enabling norms will improve the quality of scoring.
Disabling norms will reduce the disk space used by the index.
+
Value: `Norms.YES`, `Norms.NO`, `Norms.DEFAULT`.

`termVector`::
The term vector storing strategy.
Only available on `@FullTextField`.
+
The different values of this attribute are:
+
[options="header"]
|===============
|Value|Definition
|`TermVector.YES`|Store the term vectors of each document.
	This produces two synchronized arrays, one contains document terms and the other contains the term's frequency.
|`TermVector.NO`|Do not store term vectors.
|`TermVector.WITH_POSITIONS`|Store the term vector and token position information.
	This is the same as `TermVector.YES` plus it contains the ordinal positions of each occurrence of a term in a document.
|`TermVector.WITH_OFFSETS`|Store the term vector and token offset information.
	This is the same as `TermVector.YES` plus it contains the starting and ending offset position information for the terms.
|`TermVector.WITH_POSITION_OFFSETS`|Store the term vector, token position and offset information.
	This is a combination of the `YES`, `WITH_OFFSETS` and `WITH_POSITIONS`.
|`TermVector.WITH_POSITIONS_PAYLOADS`|Store the term vector, token position and token payloads.
	This is the same as `TermVector.WITH_POSITIONS` plus it contains the payload of each occurrence of a term in a document.
|`TermVector.WITH_POSITIONS_OFFSETS_PAYLOADS`|Store the term vector, token position, offset information and token payloads.
	This is the same as `TermVector.WITH_POSITION_OFFSETS` plus it contains the payload of each occurrence of a term in a document.
|===============

[[mapper-orm-directfieldmapping-decimalscale]] `decimalScale`::
How the scale of a large number (`BigInteger` or `BigDecimal`) should be adjusted before it is indexed as a fixed-precision integer.
Only available on `@ScaledNumberField`.
+
To index numbers that have significant digits after the decimal point, set the `decimalScale` to the number of digits you need indexed.
The decimal point will be shifted that many times to the right before indexing, preserving that many digits from the decimal part.
To index very large numbers that cannot fit in a long, set the decimal point to a negative value.
The decimal point will shifted that many times to the left before indexing, dropping all digits from the decimal part.
+
`decimalScale` with strictly positive values is allowed only for `BigDecimal`, since `BigInteger` values have no decimal digits.
+
Note that shifting of the decimal points is completely transparent and will not affect how you use the search DSL:
you be expected to provide "normal" `BigDecimal` or `BigInteger` values,
and Hibernate Search will apply the `decimalScale` and rounding transparently.
+
As a result of the rounding, search predicates and sorts will only be as precise as what the `decimalScale` allows.
+
Note that rounding does not affect projections, which will return the original value without any loss of precision.
+
NOTE: A typical use case is monetary amounts, with a decimal scale of 2
because only two digits are generally needed beyond the decimal point.
+
NOTE: Using Hibernate ORM mapping,
a default `decimalScale` is taken automatically from the underlying `scale` value of the relative SQL `@Column`,
using the Hibernate ORM metadata. The value could be overridden explicitly using the `decimalScale` attribute.

[[mapper-orm-directfieldmapping-supported-types]]
=== Supported property types
// Search 5 anchors backward compatibility
[[section-built-in-bridges]]

Below is a table listing all types with built-in value bridges,
i.e. property types that are supported out of the box
when mapping a property to an index field.

The table also explains the value assigned to the index field,
i.e. the value passed to the underlying backend for indexing.

[NOTE]
====
For information about the underlying indexing and storage used by the backend,
see <<backend-lucene-field-types,Lucene field types>>
or <<backend-elasticsearch-field-types,Elasticsearch field types>> depending on your backend.
====

[cols="l,1,1,1",options="header"]
.Property types with built-in value bridges
|===
|Property type|Value of index field (if different)|Limitations|Parsing method for 'indexNullAs'
|All enum types|`name()` as a `java.lang.String`|-|`Enum.valueOf(String)`
|java.lang.String|-|-|-
|java.lang.Character, char|A single-character `java.lang.String`|-|Accepts any single-character `java.lang.String`
|java.lang.Byte, byte|-|-|`Byte.parseByte(String)`
|java.lang.Short, short|-|-|`Short.parseShort(String)`
|java.lang.Integer, int|-|-|`Integer.parseInt(String)`
|java.lang.Long, long|-|-|`Long.parseLong(String)`
|java.lang.Double, double|-|-|`Double.parseDouble(String)`
|java.lang.Float, float|-|-|`Float.parseFloat(String)`
|java.lang.Boolean, boolean|-|-|Accepts the strings `true` or `false`, ignoring case
|java.math.BigDecimal|-|-|`new BigDecimal(String)`
|java.math.BigInteger|-|-|`new BigInteger(String)`
|java.net.URI|`toString()` as a `java.lang.String`|-|`new URI(String)`
|java.net.URL|`toExternalForm()` as a `java.lang.String`|-|`new URL(String)`
|java.time.Instant
 |-
 |<<mapper-orm-directfieldmapping-supported-types-date-time>>
 |`Instant.parse(String)`
|java.time.LocalDate
 |-
 |<<mapper-orm-directfieldmapping-supported-types-date-time>>
 |`LocalDate.parse(String)`.
|java.time.LocalTime
 |-
 |<<mapper-orm-directfieldmapping-supported-types-date-time>>
 |`LocalTime.parse(String)`
|java.time.LocalDateTime
 |-
 |<<mapper-orm-directfieldmapping-supported-types-date-time>>
 |`LocalDateTime.parse(String)`
|java.time.OffsetDateTime
 |-
 |<<mapper-orm-directfieldmapping-supported-types-date-time>>
 |`OffsetDateTime.parse(String)`
|java.time.OffsetTime
 |-
 |<<mapper-orm-directfieldmapping-supported-types-date-time>>
 |`OffsetTime.parse(String)`
|java.time.ZonedDateTime
 |-
 |<<mapper-orm-directfieldmapping-supported-types-date-time>>
 |`ZonedDateTime.parse(String)`
|java.time.ZoneId|`getId()` as a `java.lang.String`|-|`ZoneId.of(String)`
|java.time.ZoneOffset|`getTotalSeconds()` as a `java.lang.Integer`|-|`ZoneOffset.of(String)`
|java.time.Period|A formatted `java.lang.String`: `<years on 11 characters><months on 11 characters><days on 11 characters>`|-|`Period.parse(String)`
|java.time.Duration
 |`toNanos()` as a `java.lang.Long`
 |<<mapper-orm-directfieldmapping-supported-types-date-time>>
 |`Duration.parse(String)`
|java.time.Year
 |-
 |<<mapper-orm-directfieldmapping-supported-types-date-time>>
 |`Year.parse(String)`
|java.time.YearMonth
 |-
 |<<mapper-orm-directfieldmapping-supported-types-date-time>>
 |`YearMonth.parse(String)`
|java.time.MonthDay|-|-|`MonthDay.parse(String)`
|java.util.UUID|`toString()` as a `java.lang.String`|-|`UUID.fromString(String)`
|java.util.Calendar
 |A `java.time.ZonedDateTime` representing the same date/time and timezone.
 |See <<mapper-orm-legacy-date-time-apis>>.
 |`ZonedDateTime.parse(String)`
|java.util.Date
 |`Instant.ofEpochMilli(long)` as a `java.time.Instant`.
 |See <<mapper-orm-legacy-date-time-apis>>.
 |`Instant.parse(String)`
|java.sql.Timestamp
 |`Instant.ofEpochMilli(long)` as a `java.time.Instant`.
 |See <<mapper-orm-legacy-date-time-apis>>.
 |`Instant.parse(String)`
|java.sql.Date
 |`Instant.ofEpochMilli(long)` as a `java.time.Instant`.
 |See <<mapper-orm-legacy-date-time-apis>>.
 |`Instant.parse(String)`
|java.sql.Time
 |`Instant.ofEpochMilli(long)` as a `java.time.Instant`.
 |See <<mapper-orm-legacy-date-time-apis>>.
 |`Instant.parse(String)`
|org.hibernate.search.engine.spatial.GeoPoint and subtypes|-|-|Latitude as double and longitude as double, separated by a comma. Ex: `41.8919, 12.51133`.
|===

[[mapper-orm-directfieldmapping-supported-types-date-time,Possibly lower range/resolution]]
[NOTE]
.Range and resolution of date/time fields
====
With a few exceptions, most date and time values are passed as-is to the backend;
e.g. a `LocalDateTime` property would be passed as a `LocalDateTime` to the backend.

Internally, however, the Lucene and Elasticsearch backend use a different representation of date/time types.
As a result, date and time fields stored in the index may have a smaller range and resolution
than the corresponding Java type.

The documentation of each backend provides more information:
see <<backend-lucene-field-types-date-time,here for Lucene>>
and <<backend-elasticsearch-field-types-date-time,here for Elasticsearch>>.
====

[[mapper-orm-legacy-date-time-apis]]
=== Support for legacy `java.util` date/time APIs

Using legacy date/time types such as `java.util.Calendar`, `java.util.Date`, `java.sql.Timestamp`, `java.sql.Date`, `java.sql.Time`
is not recommended,
due to their numerous quirks and shortcomings.
The https://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html[`java.time`] package introduced
in Java 8 should generally be preferred.

That being said, integration constraints may force you to rely on the legacy date/time APIs,
which is why Hibernate Search still attempts to support them on a best effort basis.

Since Hibernate Search uses the `java.time` APIs to represent date/time internally,
the legacy date/time types need to be converted before they can be indexed.
Hibernate Search keeps things simple:
`java.util.Date`, `java.util.Calendar`, etc. will be converted using their time-value (number of milliseconds since the epoch),
which will be assumed to represent the same date/time in Java 8 APIs.
In the case of `java.util.Calendar`, timezone information will be preserved for projections.

For all dates after 1900, this will work exactly as expected.

Before 1900, indexing and searching through Hibernate Search APIs will also work as expected,
but *if you need to access the index natively*, for example through direct HTTP calls to an Elasticsearch server,
you will notice that the indexed values are slightly "off".
This is caused by differences in the implementation of `java.time` and legacy date/time APIs
which lead to slight differences in the interpretation of time-values (number of milliseconds since the epoch).

The "drifts" are consistent: they will also happen when building a predicate,
and they will happen in the opposite direction when projecting.
As a result, the differences will not be visible from an application relying on the Hibernate Search APIs exclusively.
They will, however, be visible when accessing indexes natively.

For the large majority of use cases, this will not be a problem.
If this behavior is not acceptable for your application,
you should look into implementing custom <<mapper-orm-bridge-valuebridge,value bridges>>
and instructing Hibernate Search to use them by default for `java.util.Date`, `java.util.Calendar`, etc.:
see <<mapper-orm-bridge-resolver>>.

[TIP]
====
Technically, conversions are difficult because the `java.time` APIs
and the legacy date/time APIs do not have the same internal calendar.

In particular:

* `java.time` assumes a "Local Mean Time" before 1900, while legacy date/time APIs do not support it
(https://bugs.openjdk.java.net/browse/JDK-6281408[JDK-6281408]),
As a result, time values (number of milliseconds since the epoch) reported by the two APIs
will be different for dates before 1900.
* `java.time` uses a proleptic Gregorian calendar before October 15, 1582,
meaning it acts as if the Gregorian calendar, along with its system of leap years, had always existed.
Legacy date/time APIs, on the other hand, use the Julian calendar before that date (by default),
meaning the leap years are not exactly the same ones.
As a result, some dates that are deemed valid by one API will be deemed invalid by the other,
for example February 29, 1500.

Those are the two main problems, but there may be others.
====

[[mapper-orm-directfieldmapping-custom-types]]
=== Mapping custom property types

Even types that are not <<mapper-orm-directfieldmapping-supported-types,supported out of the box>> can be mapped.
There are various solutions, some simple and some more powerful,
but they all come down to extracting data from the unsupported type and converting it to types that are
supported by the backend.

There are two cases to distinguish between:

1. If the unsupported type is simply a container (`List<String>`)
or multiple nested containers (`Map<Integer, List<String>>`)
whose elements have a supported type,
then what you need is a container extractor.
See <<mapper-orm-containerextractor>> for more information.
2. Otherwise, you will have to rely on a custom component, called a bridge, to extract data from your type.
See <<mapper-orm-bridge>> for more information on custom bridges.

[[mapper-orm-indexedembedded]]
== Mapping associated elements with `@IndexedEmbedded`
// Search 5 anchors backward compatibility
[[search-mapping-associated]]

[[mapper-orm-indexedembedded-basics]]
=== Basics

Using only `@Indexed` combined with `@*Field` annotations allows indexing an entity and its direct properties,
which is nice but simplistic.
A real-world model will include multiple object types holding references to one another,
like the `authors` association in the example below.

.A multi-entity model with associations
====
This mapping will declare the following fields in the `Book` index:

* `title`
* ... and nothing else.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/indexedembedded/none/Book.java[tags=include;!getters-setters]
----
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/indexedembedded/none/Author.java[tags=include;!getters-setters]
----
<1> The `Book` entity is indexed.
<2> The `title` of the book is mapped to an index field.
<3> But how to index the `Author` name into the `Book` index?
====

When searching for a book, users will likely need to search by author name.
In the world of high-performance indexes, cross-index joins are costly and usually not an option.
The best way to address such use cases is generally to copy data:
when indexing a `Book`, just copy the name of all its authors into the `Book` document.

That's what `@IndexedEmbedded` does:
it instructs Hibernate Search to _embed_ the fields of an associated object into the main object.
In the example below, it will instruct Hibernate Search to embed the `name` field
defined in `Author` into `Book`, creating the field `authors.name`.

[NOTE]
====
`@IndexedEmbedded` can be used on Hibernate ORM's `@Embedded` properties
as well as associations (`@OneToOne`, `@OneToMany`, `@ManyToMany`, ...).
====

[[example-indexing-associations]]
.Using `@IndexedEmbedded` to index associated elements
====
This mapping will declare the following fields in the `Book` index:

* `title`
* `authors.name`

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/indexedembedded/onelevel/Book.java[tags=include;!getters-setters]
----
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/indexedembedded/onelevel/Author.java[tags=include;!getters-setters]
----
<1> Add an `@IndexedEmbedded` to the `authors` property.
<2> Map `Author.name` to an index field, even though `Author` is not directly mapped to an index (no `@Indexed`).
====

[NOTE]
====
<<mapper-orm-identifiermapping,Document identifiers>> are not index fields.
Consequently, they will be ignored by `@IndexedEmbedded`.

To embed another entity's identifier with `@IndexedEmbedded`,
map that identifier to a field explicitly using `@GenericField` or another `@*Field` annotation.
====

[WARNING]
====
When `@IndexedEmbedded` is applied to an association,
i.e. to a property that refers to entities (like the example above),
*the association must be bi-directional*.
Otherwise, Hibernate Search will throw an exception on startup.

See <<mapper-orm-indexedembedded-reindexing>> for the reasons behind this restriction
and ways to circumvent it.
====

Index-embedding can be nested on multiple levels;
for example you can decide to index-embed the place of birth of authors,
so as to be able to search for books written by Russian authors exclusively:

[[example-nested-index-embedded]]
.Nesting multiple `@IndexedEmbedded`
====
This mapping will declare the following fields in the `Book` index:

* `title`
* `authors.name`
* `authors.placeOfBirth.country`

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/indexedembedded/twolevels/Book.java[tags=include;!getters-setters]
----
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/indexedembedded/twolevels/Author.java[tags=include;!getters-setters]
----
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/indexedembedded/twolevels/Address.java[tags=include;!getters-setters]
----
<1> Add an `@IndexedEmbedded` to the `authors` property.
<2> Map `Author.name` to an index field, even though `Author` is not directly mapped to an index (no `@Indexed`).
<3> Add an `@IndexedEmbedded` to the `placeOfBirth` property.
<4> Map `Address.country` to an index field, even though `Address` is not directly mapped to an index (no `@Indexed`).
====

[WARNING]
====
By default, `@IndexedEmbedded` will nest other `@IndexedEmbedded`
encountered in the indexed-embedded type recursively,
without any sort of limit, which can cause infinite recursion.

To address this, see <<mapper-orm-indexedembedded-filtering>>.
====

[[mapper-orm-indexedembedded-null]]
=== `@IndexedEmbedded` and `null` values
// Search 5 anchors backward compatibility
[[_indexing_null_embeddeds]]

When properties targeted by an `@IndexedEmbedded` contain `null` elements,
these elements are simply not indexed.

On contrary to <<mapper-orm-directfieldmapping>>,
there is no `indexNullAs` feature to index a specific value for `null` objects,
but you can take advantage of the <<search-dsl-predicate-exists,`exists`>> predicate
in search queries to look for documents where a given `@IndexedEmbedded`
has or doesn't have a value:
simply pass the name of the object field to the `exists` predicate,
for example `authors` in the example above.

[[mapper-orm-indexedembedded-multivalued]]
=== `@IndexedEmbedded` on container types

When properties targeted by an `@IndexedEmbedded` have a container type
(`List`, `Optional`, `Map`, ...),
the innermost elements will be embedded.
For example for a property of type `List<MyEntity>`, elements of type `MyEntity` will be embedded.

This default behavior and ways to override it are described
in the section <<mapper-orm-containerextractor>>.

[[mapper-orm-indexedembedded-prefix]]
=== Setting the field name prefix with `prefix`

By default, `@IndexedEmbedded` will prepend the name of embedded fields
with the name of the property it is applied to followed by a dot.
So if `@IndexedEmbedded` is applied to a property named `authors` in a `Book` entity,
the `name` field of the authors will be copied to the `authors.name` field when `Book` is indexed.

It is possible to change this prefix by setting the `prefix` attribute,
for example `@IndexedEmbedded(prefix = "author.")` (do not forget the trailing dot!).

[CAUTION]
====
The prefix should generally be a sequence of non-dots ending with a single dot, for example `my_Property.`.

Changing the prefix to a string that does not include any dot at the end (`my_Property`),
or that includes a dot anywhere but at the very end (`my.Property.`),
will lead to complex, undocumented, legacy behavior.
Do this at your own risk.

In particular, a prefix that does not end with a dot will lead to incorrect behavior
in <<mapper-orm-bridge-index-field-dsl,some APIs exposed to custom bridges>>:
the `addValue`/`addObject` methods that accept a field name.
====

[[mapper-orm-indexedembedded-reindexing]]
=== Reindexing when embedded elements change
// Search 5 anchors backward compatibility
[[_associated_objects_building_a_dependency_graph_with_containedin]]

When the "embedded" entity changes,
Hibernate Search will handle reindexing of the "embedding" entity.

This will work transparently most of the time,
as long as the association `@IndexedEmbedded` is applied to is bi-directional
(uses Hibernate ORM's `mappedBy`).

When Hibernate Search is unable to handle an association,
it will throw an exception on bootstrap.
If this happens, refer to <<mapper-orm-reindexing-basics>> to know more.

[[mapper-orm-indexedembedded-filtering]]
=== Filtering embedded fields and breaking `@IndexedEmbedded` cycles
// Search 5 anchors backward compatibility
[[search-mapping-associated-viapaths]]

By default, `@IndexedEmbedded` will "embed" everything:
every field encountered in the indexed-embedded element,
and every `@IndexedEmbedded` encountered in the indexed-embedded element,
recursively.

This will work just fine for simpler use cases, but may lead to problems for more complex models:

* If the indexed-embedded element declares many index fields (Hibernate Search fields),
only some of which are actually useful to the "index-embedding" type,
the extra fields will decrease indexing performance needlessly.
* If there is a cycle of `@IndexedEmbedded`
(e.g. `A` index-embeds `b` of type `B`, which index-embeds `a` of type `A`)
the index-embedding type will end up with an infinite amount of fields
(`a.b.someField`, `a.b.a.b.someField`, `a.b.a.b.a.b.someField`, ...),
which Hibernate Search will detect and reject with an exception.

To address these problems, it is possible to filter the fields to embed,
to only include those that are actually useful.
Two filtering attributes are available on `@IndexedEmbedded` and may be combined:

`includePaths`::
The paths of index fields from the indexed-embedded element that should be embedded.
+
Provided paths must be relative to the indexed-embedded element,
i.e. they must not include the <<mapper-orm-indexedembedded-prefix,prefix>>.
+
This takes precedence over `maxDepth` (see below).
`maxDepth`::
The max recursion depth for indexed-embedded processing.
+
`maxDepth` is the number of `@IndexedEmbedded` that will be traversed
and for which all fields of the indexed-embedded element will be included,
even if these fields are not included explicitly through `includePaths`:
+
 * `maxDepth=0` means fields of the indexed-embedded element are *not* included,
nor is any field of nested indexed-embedded elements,
unless these fields are included explicitly through `includePaths`.
 * `maxDepth=1` means fields of the indexed-embedded element *are* included,
but *not* fields of nested indexed-embedded elements,
unless these fields are included explicitly through `includePaths`.
 * And so on.
+
The default value depends on the value of the `includePaths` attribute:
if `includePaths` is empty, the default is `Integer.MAX_VALUE` (no limit)
if `includePaths` is *not* empty, the default is `0`
(only include fields included explicitly).

[NOTE]
.Dynamic fields and filtering
====
<<mapper-orm-bridge-index-field-dsl-dynamic,Dynamic fields>> are not directly affected by filtering rules:
a dynamic field will be included if and only if its parent is included.

This means in particular that `maxDepth` and `includePaths`
constraints only need to match the nearest static parent of a dynamic field
in order for that field to be included.
====

Below are two examples: one leveraging `includePaths` only,
and one leveraging `includePaths` and `maxDepth`.

[[indexedembedded-includePath]]
.Filtering indexed-embedded fields with `includePaths`
====
This mapping will declare the following fields in the `Human` index:

* `name`
* `nickname`
* `parents.name`: explicitly included because `includePaths` on `parents` includes `name`.
* `parents.nickname`: explicitly included because `includePaths` on `parents` includes `nickname`.
* `parents.parents.name`: explicitly included because `includePaths` on `parents` includes `parents.name`.

The following fields in particular are excluded:

* `parents.parents.nickname`: *not* implicitly included because `maxDepth` is not set and defaults to `0`,
and *not* explicitly included either because `includePaths` on `parents` does not include `parents.nickname`.
* `parents.parents.parents.name`: *not* implicitly included because `maxDepth` is not set and defaults to `0`,
and *not* explicitly included either because `includePaths` on `parents` does not include `parents.parents.name`.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/indexedembedded/includepaths/Human.java[tags=include;!getters-setters]
----
====

[[indexedembedded-includePathsAndDepth]]
.Filtering indexed-embedded fields with `includePaths` and `maxDepth`
====
This mapping will declare the following fields in the `Human` index:

* `name`
* `surname`
* `parents.name`: implicitly at depth `0` because `maxDepth > 0`
(so `parents.*` is included implicitly).
* `parents.nickname`: implicitly included at depth `0` because `maxDepth > 0`
(so `parents.*` is included implicitly).
* `parents.parents.name`: implicitly included at depth `1` because `maxDepth > 1`
(so `parents.parents.*` is included implicitly).
* `parents.parents.nickname`: implicitly included at depth `1` because `maxDepth > 1`
(so `parents.parents.*` is included implicitly).
* `parents.parents.parents.name`: *not* implicitly included at depth `2` because `maxDepth = 2`
(so `parents.parents.parents` is included implicitly,
but sub-fields can only be included explicitly)
but explicitly included because `includePaths` on `parents` includes `parents.parents.name`.

The following fields in particular are excluded:

* `parents.parents.parents.nickname`: *not* implicitly included at depth `2` because `maxDepth = 2`
(so `parents.parents.parents` is included implicitly, but sub-fields must be included explicitly)
and *not* explicitly included either because `includePaths` on `parents` does not include `parents.parents.nickname`.
* `parents.parents.parents.parents.name`: *not* implicitly included at depth `3` because `maxDepth = 2`
(so `parents.parents.parents` is included implicitly,
but `parents.parents.parents.parents` and sub-fields can only be included explicitly)
and *not* explicitly included either because `includePaths` on `parents` does not include `parents.parents.parents.name`.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/indexedembedded/includepathsanddepth/Human.java[tags=include;!getters-setters]
----
====

[[mapper-orm-indexedembedded-storage]]
=== Storing embedded elements in nested documents using `storage`

Indexed-embedded fields can be stored in one of two ways,
configured through the `storage` attribute of the `@IndexedEmbedded` annotation.
To illustrate storage options, let's consider the following object tree,
assuming the class `Book` is annotated with `@Indexed`
and its `authors` property is annotated with  `@IndexedEmbedded`:

* Book instance
** title = Levianthan Wakes
** authors =
*** Author instance
**** firstName = Daniel
**** lastName = Abraham
*** Author instance
**** firstName = Ty
**** lastName = Frank

[[mapper-orm-indexedembedded-storage-flattened]]
==== `DEFAULT` or `FLATTENED` storage

By default, indexed-embedded fields are "flattened",
meaning that the tree structure is not preserved.

The book instance mentioned above would be indexed with a structure roughly similar to this:

 * Book document
 ** title = Levianthan Wakes
 ** authors.firstName = [Daniel, Ty]
 ** authors.lastName = [Abraham, Frank]

The `authors.firstName` and `authors.lastName` fields were "flattened"
and now each has two values;
the knowledge of which last name corresponds to which first name has been lost.

This is more efficient for storage and querying,
but can cause unexpected behavior when querying the index
on both the author's first name and the author's last name.
The book given in example
would show up as a match to a query such as `authors.firstname:Ty AND authors.lastname:Abraham`,
even though "Ty Abraham" is not one of this book's authors.

[[mapper-orm-indexedembedded-storage-nested]]
==== `NESTED` storage

When indexed-embedded elements are "nested",
the tree structure is preserved by transparently creating one separate "nested" document
for every indexed-embedded element.

The book instance mentioned above would be indexed with a structure roughly similar to this:

 * Book document
 ** title = Levianthan Wakes
 ** Nested documents
 *** Nested documents for "authors"
 **** authors.firstName = Daniel
 **** authors.lastName = Abraham
 *** Nested documents for "authors"
 **** authors.firstName = Ty
 **** authors.lastName = Frank

The book is effectively indexed as three documents:
the root document for the book, and two internal, "nested" documents for the authors,
preserving the knowledge of which last name corresponds to which first name
at the cost of degraded performance when indexing and querying.

NOTE: The nested documents are "hidden" and won't directly show up in search results.
No need to worry about nested documents being "mixed up" with root documents.

If special care is taken when building predicates on fields within nested documents,
using a <<search-dsl-predicate-nested,`nested` predicate>>,
queries containing predicates on both the author's first name and the author's last name
will behave as one would (intuitively) expect.
The book given in example
would *not* show up as a match to a query such as `authors.firstname:Ty AND authors.lastname:Abraham`,
as long as a `nested` predicate is used.

[[mapper-orm-containerextractor]]
== Mapping container types with container extractors

=== Basics

Most built-in annotations applied to properties will work transparently when applied to container types:

* `@GenericField` applied to a property of type `String` will index the property value directly.
* `@GenericField` applied to a property of type `OptionalInt` will index the optional's value (an integer).
* `@GenericField` applied to a property of type `List<String>` will index the list elements (strings).
* `@GenericField` applied to a property of type `Map<Integer, String>` will index the map values (strings).
* `@GenericField` applied to a property of type `Map<Integer, List<String>>` will index the list elements in the map values (strings).
* Etc.

Same goes for other field annotations such as `@FullTextField`,
as well as `@IndexedEmbedded` in particular.

What happens behind the scenes is that Hibernate Search will inspect the property type
and attempt to apply "container extractors", picking the first that works.

=== Explicit container extraction

In some cases, you will want to pick the container extractors to use explicitly.
This is the case when a map's keys must be indexed, instead of the values.
Relevant annotations offer an `extraction` attribute to configure this,
as shown in the example below.

TIP: All built-in extractor names are available as constants
in `org.hibernate.search.mapper.pojo.extractor.builtin.BuiltinContainerExtractors`.

.Mapping map keys to an index field using explicit container extractor definition
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/containerextractor/Book.java[tags=explicit-extractor]
----
<1> This annotation, and those below, are just Hibernate ORM configuration.
<2> Declare an index field based on the `priceByFormat` property.
<3> By default, Hibernate Search would index the map values (the book prices).
This uses the `extraction` attribute to specify that map keys (the book formats)
must be indexed instead.
====

TIP: When multiple levels of extractions are necessary,
multiple extractors can be configured:
`extraction = @ContainerExtraction(BuiltinContainerExtractors.MAP_KEY, BuiltinContainerExtractors.OPTIONAL)`.
However, such complex mappings are unlikely since they are generally not supported by Hibernate ORM.

[NOTE]
====
It is possible to implement and use custom container extractors,
but at the moment these extractors will not be handled correctly for automatic reindexing,
so the corresponding property must <<mapper-orm-reindexing-reindexonupdate,have automatic reindexing disabled>>.

See https://hibernate.atlassian.net/browse/HSEARCH-3688[HSEARCH-3688] for more information.
====

=== Disabling container extraction

In some rare cases, container extraction is not wanted,
and the `@GenericField`/`@IndexedEmbedded` is meant to be applied to the `List`/`Optional`/etc. directly.
To ignore the default container extractors,
most annotations offer an `extraction` attribute.
Set it as below to disable extraction altogether:

.Disabling container extraction
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/containerextractor/Book.java[tags=no-extractor]
----
<1> Declare an index field based on the `authors` property.
<2> Instruct Hibernate Search to use the given bridge,
which will extract the collection size (the number of authors).
<3> Because the bridge is applied to the collection as a whole,
and not to each author,
the `extraction` attribute is used to disable container extraction.
====

[[mapper-orm-geopoint]]
== Mapping geo-point types
// Search 5 anchors backward compatibility
[[spatial]]

=== Basics

Hibernate Search provides a variety of spatial features
such as <<search-dsl-predicate-spatial-within,a distance predicate>>
and <<search-dsl-sort-distance,a distance sort>>.
These features require that spatial coordinates are indexed.
More precisely, it requires that a *geo-point*,
i.e. a latitude and longitude in the geographic coordinate system, are indexed.

Geo-points are a bit of an exception,
because there isn't any type in the standard Java library to represent them.
For that reason, Hibernate Search defines its own interface,
`org.hibernate.search.engine.spatial.GeoPoint`.
Since your model probably uses a different type to represent geo-points,
mapping geo-points requires some extra steps.

Two options are available:

* If your geo-points are represented by a dedicated, immutable type,
simply use `@GenericField` and the `GeoPoint` interface,
as explained <<mapper-orm-geopoint-genericfield, here>>.
* For every other case, use the more complex (but more powerful) `@GeoPointBinding`,
as explained <<mapper-orm-geopoint-geopointbinding, here>>.

[[mapper-orm-geopoint-genericfield]]
=== Using `@GenericField` and the `GeoPoint` interface
// Search 5 anchors backward compatibility
[[spatial-coordinatesinterface]]

When geo-points are represented in your entity model by a dedicated, *immutable* type,
you can simply make that type implement the `GeoPoint` interface,
and use simple <<mapper-orm-directfieldmapping,property/field mapping>> with `@GenericField`:

.Mapping spatial coordinates by implementing `GeoPoint`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/spatial/genericfield/MyCoordinates.java[tags=include]
----
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/spatial/genericfield/Author.java[tags=include;!getters-setters]
----
<1> Model the geo-point as an embeddable implementing `GeoPoint`.
A custom type with a corresponding Hibernate ORM `UserType` would work as well.
<2> The geo-point type *must be immutable*: it does not declare any setter.
<3> Apply the `@GenericField` annotation to the `placeOfBirth` property holding the coordinates.
An index field named `placeOfBirth` will be added to the index.
Options generally used on `@GenericField` can be used here as well.
====

[WARNING]
====
The geo-point type *must be immutable*,
i.e. the latitude and longitude of a given instance may never change.

This is a core assumption of `@GenericField` and generally all `@*Field` annotations:
changes to the coordinates will be ignored and will not trigger reindexing as one would expect.

If the type holding your coordinates is mutable,
do not use `@GenericField`
and refer to <<mapper-orm-geopoint-geopointbinding>> instead.
====

[TIP]
====
If your geo-point type is immutable, but extending the `GeoPoint` interface is not an option,
you can also use a custom <<mapper-orm-bridge-valuebridge,value bridge>>
converting between the custom geo-point type and `GeoPoint`.
`GeoPoint` offers static methods to quickly build a `GeoPoint` instance.
====

[[mapper-orm-geopoint-geopointbinding]]
=== Using `@GeoPointBinding`, `@Latitude` and `@Longitude`
// Search 5 anchors backward compatibility
[[spatial-indexing-range]]
[[spatial-indexing-spatialHash]]

For cases where coordinates are stored in a mutable object,
the solution is the `@GeoPointBinding` annotation.
Combined with the `@Latitude` and `@Longitude` annotation,
it can map the coordinates of any type that declares a latitude and longitude of type `double`:

.Mapping spatial coordinates using `@GeoPointBinding`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/spatial/geopointbinding/type/Author.java[tags=include;!getters-setters]
----
<1> Apply the `@GeoPointBinding` annotation to the type,
setting `fieldName` to the name of the index field.
<2> Apply `@Latitude` to the property holding the latitude. It must be of `double` or `Double` type.
<3> Apply `@Longitude` to the property holding the longitude. It must be of `double` or `Double` type.
====

The `@GeoPointBinding` annotation may also be applied to a property,
in which case the `@Latitude` and `@Longitude` must be applied to properties of the property's type:

.Mapping spatial coordinates using `@GeoPointBinding` on a property
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/spatial/geopointbinding/property/MyCoordinates.java[tags=include]
----
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/spatial/geopointbinding/property/Author.java[tags=include;!getters-setters]
----
<1> Model the geo-point as an embeddable.
An entity would work as well.
<2> In the geo-point type, apply `@Latitude` to the property holding the latitude.
<3> In the geo-point type, apply `@Longitude` to the property holding the longitude.
<4> The geo-point type may safely declare setters (it can be mutable).
<5> Apply the `@GeoPointBinding` annotation to the property.
Setting `fieldName` to the name of the index field is possible, but optional:
the property name will be used by default.
====

It is possible to handle multiple sets of coordinates by applying the annotations multiple times
and setting the `markerSet` attribute to a unique value:

[[spatial-multiplecoordinates]]
.Mapping spatial coordinates using `@GeoPointBinding` on a property
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/spatial/geopointbinding/multiple/Author.java[tags=include;!getters-setters]
----
<1> Apply the `@GeoPointBinding` annotation to the type,
setting `fieldName` to the name of the index field, and `markerSet` to a unique value.
<2> Apply the `@GeoPointBinding` annotation to the type a second time,
setting `fieldName` to the name of the index field (different from the first one),
and `markerSet` to a unique value (different from the first one).
<3> Apply `@Latitude` to the property holding the latitude for the first geo-point field.
Set the `markerSet` attribute to the same value as the corresponding `@GeoPointBinding` annotation.
<4> Apply `@Longitude` to the property holding the longitude for the first geo-point field.
Set the `markerSet` attribute to the same value as the corresponding `@GeoPointBinding` annotation.
<5> Apply `@Latitude` to the property holding the latitude for the second geo-point field.
Set the `markerSet` attribute to the same value as the corresponding `@GeoPointBinding` annotation.
<6> Apply `@Longitude` to the property holding the longitude for the second geo-point field.
Set the `markerSet` attribute to the same value as the corresponding `@GeoPointBinding` annotation.
====

[[mapper-orm-reindexing]]
== Tuning automatic reindexing

[[mapper-orm-reindexing-basics]]
=== Basics

When an entity property is mapped to the index,
be it through `@GenericField`, `@IndexedEmbedded`,
or a <<mapper-orm-bridge,custom bridge>>,
this mapping introduces a dependency:
the document will need to be updated when the property changes.

For simpler, single-entity mappings,
this only means that Hibernate Search will need to detect when an entity changes
and reindex the entity.
This will be handled transparently.

If the mapping includes a "derived" property,
i.e. a property that is not persisted directly,
but instead is dynamically computed in a getter that uses other properties as input,
Hibernate Search will be unable to guess which part of the persistent state
these properties are based on.
In this case, some explicit configuration will be required;
see <<mapper-orm-reindexing-derivedfrom>> for more information.

When the mapping crosses the entity boundaries,
things get more complicated.
Let's consider a mapping where a `Book` entity is mapped to a document,
and that document must include the `name` property of the `Author` entity
(for example using <<mapper-orm-indexedembedded,`@IndexedEmbedded`>>).
Hibernate Search will need to track changes to the author's name,
and whenever that happens,
it will need to _retrieve all the books of that author_,
so as to reindex these books automatically.

In practice, this means that whenever an entity mapping relies on an association to another entity,
this association must be bi-directional:
if `Book.authors` is `@IndexedEmbedded`,
Hibernate Search must be aware of an inverse association `Author.books`.
An exception will be thrown on startup if the inverse association cannot be resolved.

Most of the time, Hibernate Search is able to take advantage of Hibernate ORM metadata
(the `mappedBy` attribute of `@OneToOne` and `@OneToMany`)
to resolve the inverse side of an association,
so this is all handled transparently.

In some rare cases, with the more complex mappings,
it is possible that even Hibernate ORM is not aware that an association is bi-directional,
because `mappedBy` cannot be used.
A few solutions exist:

* The association can simply be ignored.
This means the index will be out of date whenever associated entities change,
but this can be an acceptable solution if the index
is rebuilt periodically.
See <<mapper-orm-reindexing-reindexonupdate>> for more information.
* If the association is actually bi-directional,
its inverse side can be specified to Hibernate Search
explicitly using `@AssociationInverseSide`.
See <<mapper-orm-reindexing-associationinverseside>> for more information.

[[mapper-orm-reindexing-associationinverseside]]
=== Enriching the entity model with `@AssociationInverseSide`

Given an association from an entity type `A` to entity type `B`,
`@AssociationInverseSide` defines the inverse side of an association,
i.e. the path from `B` to `A`.

This is mostly useful when a bi-directional association
is not mapped as such in Hibernate ORM (no `mappedBy`).

.Mapping the inverse side of an association with `@AssociationInverseSide`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/reindexing/associationinverseside/Book.java[tags=include;!getters-setters]
----
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/reindexing/associationinverseside/BookEdition.java[tags=include;!getters-setters]
----
<1> This annotation and the following ones are the Hibernate ORM mapping for a `Map<BookEdition, BigDecimal>`
where the keys are `BookEdition` entities and the values are the price of that edition.
<2> Index-embed the editions that are actually for sale.
<3> In Hibernate ORM, it is not possible to use `mappedBy` for an association modeled by a `Map` key.
Thus we use `@AssociationInverseSide` to tell Hibernate Search what the inverse side
of this association is.
<4> We could have applied the `@AssociationInverseSide` annotation here instead:
either side will do.
====

[[mapper-orm-reindexing-derivedfrom]]
=== Reindexing when a derived value changes with `@IndexingDependency`

When a property is not persisted directly,
but instead is dynamically computed in a getter that uses other properties as input,
Hibernate Search will be unable to guess which part of the persistent state
these properties are based on,
and thus will be unable to trigger automatic reindexing when the relevant persistent state changes.
By default, Hibernate Search will detect such cases on bootstrap and throw an exception.

Annotating the property with `@IndexingDependency(derivedFrom = ...)`
will give Hibernate Search the information it needs and allow automatic reindexing.

.Mapping a derived value with `@IndexingDependency.derivedFrom`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/reindexing/derivedfrom/Book.java[tags=include;!getters-setters]
----
<1> Authors are modeled as a list of string containing the author names.
<2> The transient `mainAuthor` property dynamically returns the main author (the first one).
<3> We use `@FullTextField` to on the `getMainAuthor()` getter to index the name of the main author.
<4> We use `@IndexingDependency.derivedFrom` to tell Hibernate Search
that whenever the list of authors changes, the result of `getMainAuthor()` main author may have changed.
====

[[mapper-orm-reindexing-reindexonupdate]]
=== Disabling reindexing with `@IndexingDependency`

In some cases, automatic reindexing is not realistically achievable:

* When a property mapped to the index is updated very frequently,
leading to a very frequent reindexing and unacceptable usage of disks or database.
* When an association is massive,
for example a single entity instance is <<mapper-orm-indexedembedded,indexed-embedded>>
in thousands of other entities.
* Etc.

When that happens, it is possible to tell Hibernate Search to ignore updates
to a particular property (and, in the case of `@IndexedEmbedded`, anything beyond that property).
The index will become slightly out-of-sync whenever the property is modified,
but this can be solved by <<mapper-orm-indexing-massindexer,reindexing>>,
for example every night.

.Disabling automatic reindexing with `@IndexingDependency.reindexOnUpdate`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/reindexing/reindexonupdate/Book.java[tags=include;!getters-setters]
----
<1> Each book has an association to a `BookCategory` entity.
There are many, potentially thousands of books for each category.
<2> We want to index-embed the `BookCategory` into the `Book` ...
<3> ... but we really don't want to model the (huge) inverse association from `BookCategory` to `Book`.
Thus we use `@IndexingDependency.reindexOnUpdate` to tell Hibernate Search that `Book`
should not be reindexed when the content of a `BookCategory` changes.
If we rename a `BookCategory`, we will need to reindex the corresponding books manually.
====

[[mapper-orm-mapping-changes]]
== Changing the mapping of an existing application

Over the lifetime of an application,
it will happen that the mapping of a particular indexed entity type has to change.
When this happens, the mapping changes are likely to require changes to the structure of the index,
i.e. its _schema_.
Hibernate Search does *not* handle this structure change automatically,
so manual intervention is required.

The simplest solution when the index structure needs to change is to simply:

1. Drop and re-create the index and its schema,
either manually by deleting the filesystem directory for Lucene
or using the REST API to delete the index for Elasticsearch,
or using Hibernate Search's <<mapper-orm-schema-management,schema management features>>.
2. Re-populate the index, for example using the <<mapper-orm-indexing-massindexer,mass indexer>>.

[TIP]
====
Technically, dropping the index and reindexing is not _strictly_ required if the mapping changes include _only_:

* *adding* new indexed entities that will not have any persisted instance,
e.g. adding an `@Indexed` annotation on an entity which has no rows in database.
* *adding* new fields that will be empty for all currently persisted entities,
e.g. adding a new property on an entity type and mapping it to a field,
but with the guarantee that this property will initially be null for every instance of this entity;
* and/or *removing* data from existing indexes/fields,
e.g. removing an index field, or removing the need for a field to be stored.

However, you will still need to:

* create missing indexes: this can generally be done automatically
by starting up the application with the <<mapper-orm-schema-management-strategy-create,`create`>>,
<<mapper-orm-schema-management-strategy-create-or-validate,`create-or-validate`>>,
or <<mapper-orm-schema-management-strategy-create-or-update,`create-or-update`>>
schema management strategy.
* (Elasticsearch only:) update the schema of existing indexes to declare the new fields.
This will be more complex: either do it manually using Elasticsearch's REST API,
or start up the application with the <<mapper-orm-schema-management-strategy-create-or-update,`create-or-update` strategy>>,
but be warned that it <<mapper-orm-schema-management-concepts-update-failure,may fail>>.
====

[[mapper-orm-programmatic-mapping]]
== Programmatic mapping
// Search 5 anchors backward compatibility
[[hsearch-mapping-programmaticapi]]

include::todo-placeholder.asciidoc[]

////
TODO HSEARCH-3680 Detailed description of the programmatic mapping API.

TODO In particular, explain how to use type/property bridges in the programmatic mapping
////

[TIP]
====
Using the programmatic mapping API,
it is possible to map a "dynamic-map" entity model,
i.e. a model based on maps.
You just need to refer to the types by their name using `context.programmaticMapping().type("thename")`:

* The entity name for dynamic entity types.
* The "role" for dynamic embedded/component types,
i.e. the name of the owning entity, followed by a dot ("."),
followed by the dot-separated path to the component in that entity.
For example `MyEntity.myEmbedded` or `MyEntity.myEmbedded.myNestedEmbedded`.

However, support for "dynamic-map" entity models is limited. In particular:

* The <<mapper-orm-identifiermapping,document ID>> must be mapped to the entity ID:
it can't be mapped propery, even if it is unique.
* <<mapper-orm-indexing-massindexer,Mass indexing>> dynamic-map entities is not supported.
====

[[mapper-orm-custom-annotations]]
== Custom mapping annotations

By default, Hibernate Search only recognizes built-in mapping annotations
such as `@Indexed`, `@GenericField` or `@IndexedEmbedded`.

To use custom annotations in a Hibernate Search mapping,
two steps are required:

. Implementing a processor for that annotation:
`TypeMappingAnnotationProcessor` for type annotations
or `PropertyMappingAnnotationProcessor` for method/field annotations.
. Annotating the custom annotation with either `@TypeMapping` or `@PropertyMapping`,
passing as an argument the reference to the annotation processor.

Once this is done, Hibernate Search will be able to detect custom annotations in indexed classes.
Whenever a custom annotation is encountered,
Hibernate Search will instantiate the annotation processor
and call its `process` method, passing the following as arguments:

* A `mapping` parameter allowing to define the mapping for the type or property
using the <<mapper-orm-programmatic-mapping,programmatic mapping API>>.
* An `annotation` parameter representing the annotation instance.
* A `context` object with various helpers.

Custom annotations are most frequently used to apply to apply custom, parameterized bridges.
You can find examples in these sections in particular:

* <<mapper-orm-bridge-valuebridge-parameters,Passing parameters to a value bridge>>
* <<mapper-orm-bridge-propertybridge-parameters,Passing parameters to a property bridge>>
* <<mapper-orm-bridge-typebridge-parameters,Passing parameters to a type bridge>>

[TIP]
====
It is completely possible to use custom annotations for parameter-less bridges,
or even for more complex features such as indexed-embedded:
every feature available in the programmatic API
can be triggered by a custom annotation.
====
