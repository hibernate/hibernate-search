[[search-dsl]]
= Searching
// Search 5 anchors backward compatibility
[[search-query-querydsl]]

include::todo-placeholder.asciidoc[]

[[search-dsl-query]]
== Query DSL
// Search 5 anchors backward compatibility
[[search-query]]

[[search-dsl-query-generality]]
=== Generality
// Search 5 anchors backward compatibility
[[_building_a_hibernate_search_query]]

include::todo-placeholder.asciidoc[]

////
TODO explain the general concepts around querying the index.
It's not as obvious as it seems, in particular in the Hibernate Search / ORM integration:
we're querying the index, but getting the results from the database...
See the Search 5 docs, it's probably explained in detail there.
Also briefly explain the main features (predicate, sort, projection, ...)
and point to the various other sections (predicate DSL, sort DSL, projection DSL, ...) where relevant.
////

[[search-dsl-query-fetching-results]]
=== Fetching results
// Search 5 anchors backward compatibility
[[_retrieving_the_results]]

include::todo-placeholder.asciidoc[]

// TODO [[_pagination]] https://docs.jboss.org/hibernate/search/5.11/reference/en-US/html_single/#_pagination
// TODO [[_performance_considerations]] https://docs.jboss.org/hibernate/search/5.11/reference/en-US/html_single/#_performance_considerations
// TODO [[_result_size]] https://docs.jboss.org/hibernate/search/5.11/reference/en-US/html_single/#_result_size

[[search-dsl-query-timeout]]
=== Timeout
// Search 5 anchors backward compatibility
[[_limiting_the_time_of_a_query]]

include::todo-placeholder.asciidoc[]

// TODO [[]]:
// TODO [[_raise_an_exception_on_time_limit]] https://docs.jboss.org/hibernate/search/5.11/reference/en-US/html_single/#_raise_an_exception_on_time_limit
// TODO [[_limit_the_number_of_results_when_the_time_limit_is_reached]] https://docs.jboss.org/hibernate/search/5.11/reference/en-US/html_single/#_limit_the_number_of_results_when_the_time_limit_is_reached

[[search-dsl-query-entity-loading-options]]
=== Entity loading options
// Search 5 anchors backward compatibility
[[_fetching_strategy]]
//[[_customizing_object_initialization_strategies]] // There can only be one anchor per paragraph, unfortunately...

include::todo-placeholder.asciidoc[]

// TODO https://docs.jboss.org/hibernate/search/5.11/reference/en-US/html_single/#_fetching_strategy
// TODO https://docs.jboss.org/hibernate/search/5.11/reference/en-US/html_single/#_customizing_object_initialization_strategies

[[search-dsl-query-turning-into-jpa-query]]
=== Turning the `SearchQuery` into a JPA or Hibernate ORM query

include::todo-placeholder.asciidoc[]

// TODO turning a SearchQuery into a JPA/ORM query

// TODO [[_resulttransformer]] https://docs.jboss.org/hibernate/search/5.11/reference/en-US/html_single/#_resulttransformer

[[search-dsl-query-debugging]]
=== Debugging a query
// Search 5 anchors backward compatibility
[[_understanding_results]]

include::todo-placeholder.asciidoc[]

// TODO https://docs.jboss.org/hibernate/search/5.11/reference/en-US/html_single/#_understanding_results
// TODO toString(), getQueryString(), and logging, too?

[[search-dsl-predicate]]
== Predicate DSL
// Search 5 anchors backward compatibility
[[query-predicate]]

include::todo-placeholder.asciidoc[]

[[search-dsl-predicate-concepts]]
=== Generality

include::todo-placeholder.asciidoc[]

// TODO introduction, common concepts, entry point, ...

////
TODO Include a detailed description of all available predicates.
////

[[search-dsl-predicate-boolean]]
=== Boolean junction

include::todo-placeholder.asciidoc[]

[[search-dsl-sort]]
== Sort DSL
// Search 5 anchors backward compatibility
[[query-sorting]]

include::todo-placeholder.asciidoc[]

[[search-dsl-sort-concepts]]
=== Generality

By default, query results are sorted by relevance.
Other sorts, including the sort by field value, can be configured when building the search query:

.Using custom sorts
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/directfieldmapping/HibernateOrmSimpleMappingIT.java[tags=sort-simple-lambdas]
----
<1> Start building the query as usual.
<2> Mention that the results of the query are expected to be sorted on field "pageCount" in descending order,
then (for those with the same page count) on field "title_sort" in ascending order.
If the field does not exist or cannot be sorted on, an exception will be thrown.
<3> The results are sorted according to instructions.
====

Or alternatively, if you don't want to use lambdas:

.Using custom sorts - object-based syntax
====
[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/directfieldmapping/HibernateOrmSimpleMappingIT.java[tags=sort-simple-objects]
----
====

[NOTE]
====
There are a few constraints regarding sorts by field.
In particular, in order for a field to be "sortable", it must be <<mapper-orm-directfieldmapping-sortable,marked as such in the mapping>>,
so that the correct data structures are available in the index.
====

The sort DSL offers more sort types, and multiple options for each type of sort.
To learn more about the field sort, and all the other types of sort,
refer to the following sections.

////
TODO The ORM mapper query section has a link pointing here and expects the section to
include a detailed description of all available sorts.
////

[[search-dsl-projection]]
== Projection DSL
// Search 5 anchors backward compatibility
[[projections]]

include::todo-placeholder.asciidoc[]

[[search-dsl-projection-concepts]]
=== Generality

For some use cases, you only need the query to return a small subset of the data contained in your domain object.
In these cases, returning managed entities and extracting data from these entities may be overkill:
extracting the data from the index itself would avoid the database round-trip.

Projections do just that: they allow the query to return something more precise than just "the matching entities".
Projections can be configured when building the search query:

.Using projections to extract data from the index
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/directfieldmapping/HibernateOrmSimpleMappingIT.java[tags=projection-simple-lambdas]
----
<1> Start building the query as usual.
<2> Mention that the expected result of the query is a projection on field "title", of type String.
If that type is not appropriate or if the field does not exist, an exception will be thrown.
<3> The query is type-safe and will return results of the expected type.
====

Or alternatively, if you don't want to use lambdas:

.Using projections to extract data from the index - object-based syntax
====
[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/directfieldmapping/HibernateOrmSimpleMappingIT.java[tags=projection-simple-objects]
----
====

[NOTE]
====
There are a few constraints regarding field projections.
In particular, in order for a field to be "projectable", it must be <<mapper-orm-directfieldmapping-projectable,marked as such in the mapping>>,
so that it is correctly stored in the index.
====

While field projections are certainly the most common,
they are not the only type of projection.
Other projections allow to compose custom beans containing extracted data,
get references to the extracted documents or the corresponding entities,
or get information about the search query itself (score, ...).

The following example shows how to retrieve the managed entity corresponding to each matched document
along with the score of that document, and wraps this information into a custom bean:

.Using advanced projection types
====
[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/directfieldmapping/HibernateOrmSimpleMappingIT.java[tags=projection-advanced-bean]
----
[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/directfieldmapping/HibernateOrmSimpleMappingIT.java[tags=projection-advanced]
----
====

The projection DSL offers more projection types, and multiple options for each type of projection.
To learn more about the field projection, and all the other types of projection,
refer to the following sections.

////
TODO The ORM mapper query section has a link pointing here and expects the section to
include a detailed description of all available projections.
////

[[search-dsl-argument-type]]
== Type of arguments passed to the DSL

Some predicates, such as the `match` predicate or the `range` predicate,
require a parameter of type `Object` at some point (`matching(Object)`, `above(Object)`, ...).
Similarly, it is possible to pass an argument of type `Object` in the sort DSL
when defining the behavior for missing values (`onMissingValue().use(Object)`).

These methods do not actually accept *any* object,
and will throw an exception when passed an argument with the wrong type.

Generally the expected type of this argument should be rather obvious:
for example if you created a field by mapping an `Integer` property,
then an `Integer` value will be expected when building a predicate;
if you mapped a `java.time.LocalDate`, then a `java.time.LocalDate` will be expected,
etc.

Things get a little more complex if you start defining and using custom bridges.
You will then have properties of type `A` mapped to an index field of type `B`.
What should you pass to the DSL?
To answer that question, we need to understand DSL converters.

DSL converters are a feature of Hibernate Search that allows the DSL to accept
arguments that match the type of the indexed property,
instead of the type of the underlying index field.

Each custom bridge has the possibility to define a DSL converter for the index fields it populates.
When it does, every time that field is mentioned in the predicate DSL,
Hibernate Search will use that DSL converter to convert the value passed to the DSL to a value that the backend understands.

For example, let's imagine an `AuthenticationEvent` entity with an `outcome` property of type `AuthenticationOutcome`.
This `AuthenticationOutcome` type is an enum.
We index the `AuthenticationEvent` entity and its `outcome` property in order to allow users to find events by their outcome.

The default bridge for enums puts the result of `Enum.name()` into a `String` field.
However, this default bridge also defines a DSL converter under the hood.
As a result, any call to the DSL will be expected to pass an `AuthenticationOutcome` instance:

.Transparent conversion of DSL parameters
====
[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/searchdsl/DslConverterIT.java[tags=dsl-converter-enabled]
----
====

This is handy, and especially appropriate if users are asked to select an outcome in a list of choices.
But what if we want users to type in some words instead, i.e. what if we want full-text search on the `outcome` field?
Then we will not have an `AuthenticationOutcome` instance to pass to the DSL, only a `String`...

In that case, we will first need to assign some text to each enum.
This can be achieved by defining a custom <<mapper-orm-bridge-valuebridge,`ValueBridge<AuthenticationOutcome, String>`>>
and applying it to the `outcome` property so as to index a textual description of the outcome,
instead of the default `Enum#name()`.

Then, we will need to tell Hibernate Search that the value passed to the DSL should not be passed to the DSL converter,
but should be assumed to match the type of the index field directly (in this case, `String`).
To that end, one can simply use the variant of the `matching` method that accepts a `DslConverter` parameter,
and pass `DslConverter.DISABLED`:

.Disabling the DSL converter
====
[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/searchdsl/DslConverterIT.java[tags=dsl-converter-disabled]
----
====

All methods that apply DSL converters offer a variant that accepts a `DslConverter` parameter:
`matching`, `from`, `to`, `above`, `below`, ...

[NOTE]
====
A DSL converter is always automatically generated for value bridges.
However, more complex bridges will require explicit configuration.

See <<mapper-orm-bridge-typeandpropertybridge>> for more information.
====

[[search-dsl-projected-value-type]]
== Type of projected values

Generally the type of values returned by projections argument should be rather obvious:
for example if you created a field by mapping an `Integer` property,
then an `Integer` value will be returned when projecting;
if you mapped a `java.time.LocalDate`, then a `java.time.LocalDate` will be returned,
etc.

Things get a little more complex if you start defining and using custom bridges.
You will then have properties of type `A` mapped to an index field of type `B`.
What will be returned by projections?
To answer that question, we need to understand projection converters.

Projection converters are a feature of Hibernate Search that allows the projections to return
values that match the type of the indexed property,
instead of the type of the underlying index field.

Each custom bridge has the possibility to define a projection converter for the index fields it populates.
When it does, every time that field is projected on,
Hibernate Search will use that projection converter to convert the projected value returned by the index.

For example, let's imagine an `Order` entity with a `status` property of type `OrderStatus`.
This `OrderStatus` type is an enum.
We index the `Order` entity and its `status` property.

The default bridge for enums puts the result of `Enum.name()` into a `String` field.
However, this default bridge also defines a projection converter.
As a result, any projection on the `status` field will return an `OrderStatus` instance:

.Transparent conversion of projections
====
[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/searchdsl/ProjectionConverterIT.java[tags=projection-converter-enabled]
----
====

This is probably what you want in general.
But in some cases, you may want to disable this conversion and return the index value instead
(i.e. the value of `Enum.name()`).

In that case, we will need to tell Hibernate Search that the value returned by the backend should not be passed to the projection converter.
To that end, one can simply use the variant of the `field` method that accepts a `ProjectionConverter` parameter,
and pass `ProjectionConverter.DISABLED`:

.Disabling the projection converter
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/searchdsl/ProjectionConverterIT.java[tags=projection-converter-disabled]
----
====

[NOTE]
====
Projection converters must be configured explicitly in custom bridges.

See <<mapper-orm-bridge-valuebridge>> and <<mapper-orm-bridge-typeandpropertybridge>> for more information.
====

[[search-dsl-multiple-fields]]
== Targeting multiple fields

Sometimes a predicate/sort/projection targets *multiple* field, which may have conflicting definitions:

* when multiple field names are passed to the `onFields` method in the predicate DSL (each field has its own definition);
* or when the search query targets multiple indexes (each index has its own definition of each field).

In such cases, the definition of the targeted fields is expected to be compatible.
For example targeting an `Integer` field and a `java.time.LocalDate` field
in the same `match` predicate will not work,
because you won't be able to pass a non-null argument to the `matching(Object)` method
that is both an `Integer` and a `java.time.LocalDate`.

If you are looking for a simple rule of thumb, here it is:
if the indexed properties do not have the same type, or are mapped differently,
the corresponding fields are probably not going to be compatible.

However, if you're interested in the details, Hibernate Search is a bit more flexible than that.

There are three different constraints when it comes to field compatibility:

1. The fields must be "encoded" in a compatible way.
This means the backend must use the same representation for the two fields,
for example they are both `Integer`,
or they are both `BigDecimal` with the same decimal scale,
or they are both `LocalDate` with the same date format, etc.
2. The fields must have a compatible DSL converter (for predicates and sorts) or projection converter (for projections).
3. For full-text predicates, the fields must have a compatible analyzer.

The following sections describe all the possible incompatibilities, and how to solve them.

=== Incompatible codec

In a search query targeting multiple indexes,
if a field is encoded differently in each index,
you cannot apply predicates, sorts or projections on that field.

NOTE: Encoding is not only about the field type, such as `LocalDate` or `BigDecimal`.
Some codecs are parameterized and two codecs with different parameters will often be considered incompatible.
Examples of parameters include the format for temporal types
or the <<mapper-orm-directfieldmapping-annotations-scalednumberfield, decimal scale>>
for `BigDecimal` and `BigInteger`.

In that case, your only option is to change your mapping to avoid the conflict:

1. rename the field in one index
2. OR change the field type in one index
3. OR if the problem is simply different codec parameters (date format, decimal scale, ...),
align the value of these parameters in one index with the other index.

If you choose to rename the field in one index,
you will still be able to apply a similar predicate
to the two fields in a single query:
you will have to create one predicate per field
and combine them with a <<search-dsl-predicate-boolean,boolean junction>>.

=== Incompatible DSL converters

Incompatible DSL converters are only a problem when you need to pass an argument to the DSL in certain methods:
`matching(Object)`/`to(Object)`/`above(Object)`/`below(Object)`/etc. in the predicate DSL,
or `onMissingValue().use(Object) in the sort DSL.

If two fields encoded in a compatible way (for example both as `String`),
but that have different DSL converters
(for example the first one converts from `String` to `String`, but the second one converts from `Integer` to `String`),
you can still use these methods, but you will need to disable the DSL converter
as explained in <<search-dsl-argument-type>>:
you will just pass the "index" value to the DSL (using the same example, a `String`).

=== Incompatible projection converters

If, in a search query targeting multiple indexes,
a field is encoded in a compatible way in every indexes (for example both as `String`),
but that has a different projection converters
(for example the first one converts from `String` to `String`, but the second one converts from `String` to `Integer`),
you can still project on this field, but you will need to disable the projection converter
as explained in <<search-dsl-projected-value-type>>:
the projection will return the "index", unconverted value (using the same example, a `String`).

=== Incompatible analyzer

Incompatible analyzers are only a problem with full-text predicates:
match predicate on a text field, phrase predicate, simple query string predicate, ...

If two fields encoded in a compatible way (for example both as `String`),
but that have different analyzers,
you can still use these predicates, but you will need to explicitly configure the predicate to either
set the search analyzer to an analyzer of your choosing with `.analyzer(analyzerName)`,
or skip analysis completely with `.skipAnalysis()`.

See <<search-dsl-predicate>> for more information about how to create predicates
and about the available options.
