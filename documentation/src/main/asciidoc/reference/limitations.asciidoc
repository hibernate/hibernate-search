[[limitations]]
= Limitations
// Search 5 anchors backward compatibility
[[elasticsearch-limitations]]

[[limitations-parallel-embedded-update]]
== Without coordination, in rare cases, automatic indexing involving `@IndexedEmbedded` may lead to out-of sync indexes

=== Description

With the default settings (<<coordination-none,no coordination>>),
if two entity instances are <<mapper-orm-indexedembedded,indexed-embedded>> in the same "index-embedding" entity,
and these two entity instance are updated in parallel transactions,
there is a small risk that the transaction commits happen in just the wrong way,
leading to the index-embedding entity being reindexed with only part of the updates.

For example, consider indexed entity A, which index-embeds B and C.
The following course of events involving two parallel transactions (T1 and T2)
will lead to an out of date index:

* T1: Load B.
* T1: Change B in a way that will require reindexing A.
* T2: Load C.
* T2: Change C in a way that will require reindexing A.
* T2: Request the transaction commit.
  Hibernate Search builds the document for A.
  While doing so, it automatically loads B. B appears unmodified, as T1 wasn't committed yet.
* T1: Request the transaction commit.
  Hibernate Search builds documents to index.
  While doing so, it automatically loads C. C appears unmodified, as T2 wasn't committed yet.
* T1: Transaction is committed.
  Hibernate Search automatically sends the updated A to the index.
  In this version, B is updated, but C is not.
* T2: Transaction is committed.
  Hibernate Search automatically sends the updated A to the index.
  In this version, C is updated, but B is not.

This chain of events ends with the index containing a version of A where C is updated, but B is not.

=== Workaround

The following solutions can help circumvent this limitation:

1. Use a safer <<coordination,coordination strategy>>,
e.g. the <<coordination-database-polling,database-polling coordination strategy>>.
See in particular <<architecture-examples>>.
2. OR avoid parallel updates to entities that are indexed-embedded in the same indexed entity.
This is only possible in very specific setups.
3. OR schedule a <<mapper-orm-indexing-massindexer,full reindexing>> of your database periodically (e.g. every night)
to get the index back in sync with the database.

=== Roadmap

This limitation is caused directly by the lack of coordination between threads or application nodes,
so it can only be addressed completely by configuring <<coordination,coordination>>.

There are no other solutions currently on the roadmap.

[[limitations-backend-indexing-error]]
== Without coordination, backend errors during automatic indexing may lead to out-of sync indexes

=== Description

With the default settings (<<coordination-none,no coordination>>),
<<mapper-orm-indexing-automatic,automatic indexing>>
will actually apply index changes in the backend *just after* the transaction commit,
without any kind of transaction log for the index changes.

Consequently, should an error occur in the backend while indexing (i.e. an I/O error),
this indexing will be cancelled, with no way to cancel the corresponding database transaction:
the index will thus become out of sync.

NOTE: The risk is exclusively related to errors in the backend, mostly to filesystem or network issues.
Errors occurring in user code (getters, custom <<mapper-orm-bridge,bridges>>, ...)
will safely cancel the whole database transaction without indexing anything,
ensuring that indexes are still in sync with the database.

=== Workaround

The following solutions can help circumvent this limitation:

1. Use a safer <<coordination,coordination strategy>>,
e.g. the <<coordination-database-polling,database-polling coordination strategy>>.
See in particular <<architecture-examples>>.
2. OR schedule a <<mapper-orm-indexing-massindexer,full reindexing>> of your database periodically (e.g. every night)
to get the index back in sync with the database.

=== Roadmap

This limitation is caused directly by the lack of persistence of entity change events,
so it can only be addressed completely by persisting those events,
e.g. by switching to the <<coordination-database-polling,database-polling coordination strategy>>.

Some incomplete countermeasures may be considered in future versions,
such as automatic in-thread retries,
but they will never solve the problem completely,
and they are not currently on the roadmap.

[[limitations-indexing-plan-serialization]]
== Automatic indexing is not compatible with `Session` serialization

=== Description

When <<mapper-orm-indexing-automatic,automatic indexing>> is enabled,
Hibernate Search collects entity change events
to build an "indexing plan" inside the ORM `EntityManager`/`Session`.
The indexing plan holds information relative to which entities need to be reindexed,
and sometimes documents that have not been indexed yet.

The indexing plan cannot be serialized.

If the ORM `Session` gets serialized,
all collected change events will be lost upon deserializing the session,
and Hibernate Search will likely "forget" to reindex some entities.

This is fine in most applications, since they do not rely on serializing the session,
but it might be a problem with some JEE applications relying on Bean Passivation.

=== Workaround

Avoid serializing an ORM `EntityManager`/`Session` after changing entities.

=== Roadmap

There are no plans to address this limitation.
We do not intend to support `Session` serialization when Hibernate Search is enabled.

[[limitations-database-polling-event-order]]
== With database-polling coordination, in rare cases, rapid deletion then re-creation of an entity may lead to out-of-sync indexes

=== Description

With <<coordination-database-polling,database-polling coordination>>,
entity change events are always processed in the order they happen
(or in an order that is close enough to produce the same indexing results),
except in the following case:

* An entity is deleted, then re-created with the same identifier.
* The deletion and re-creation happen very rapidly one after another,
so rapidly that the database date/time functions do not have enough resolution
to assign a different timestamp to the two events.
This generally means the two events happen **within ~1 microsecond** of each other.
* The deletion event is automatically assigned an identifier higher than the re-creation event.
This generally means link:{hibernateDocUrl}#identifiers-generators-optimizer[identifier generator optimizers] are used;
they may lead to out-of-order ID generation.

In this **very** specific case, the entity may end up being deleted from the index,
and not added until another change happens for that entity.

=== Workaround

The following solutions can help circumvent this limitation:

1. Do not reuse identifiers when an indexed entity is deleted then re-created:
assign a different identifier to the re-created entity.
This should be the case with the vast majority of applications,
as long as they rely on automatically generated identifiers.
2. OR if you do reuse an identifier, ensure the entity re-creation
happens significantly more than 1 microsecond after its deletion.
3. OR schedule a <<mapper-orm-indexing-massindexer,full reindexing>> of your database periodically (e.g. every night)
to get the index back in sync with the database.

=== Roadmap

Several countermeasures are already in place,
and they are the reason the problem only occurs when the entity re-creation
happens shortly after (~1 microsecond) after the deletion.

https://hibernate.atlassian.net/browse/HSEARCH-4287[HSEARCH-4287] is expected to get rid of the limitation completely.
