[[limitations]]
= Known issues and limitations
// Search 5 anchors backward compatibility
[[elasticsearch-limitations]]

[[limitations-parallel-embedded-update]]
== Without coordination, in rare cases, automatic indexing involving `@IndexedEmbedded` may lead to out-of sync indexes

=== Description

With the default settings (<<coordination-none,no coordination>>),
if two entity instances are <<mapper-orm-indexedembedded,indexed-embedded>> in the same "index-embedding" entity,
and these two entity instance are updated in parallel transactions,
there is a small risk that the transaction commits happen in just the wrong way,
leading to the index-embedding entity being reindexed with only part of the updates.

For example, consider indexed entity A, which index-embeds B and C.
The following course of events involving two parallel transactions (T1 and T2)
will lead to an out of date index:

* T1: Load B.
* T1: Change B in a way that will require reindexing A.
* T2: Load C.
* T2: Change C in a way that will require reindexing A.
* T2: Request the transaction commit.
  Hibernate Search builds the document for A.
  While doing so, it automatically loads B. B appears unmodified, as T1 wasn't committed yet.
* T1: Request the transaction commit.
  Hibernate Search builds documents to index.
  While doing so, it automatically loads C. C appears unmodified, as T2 wasn't committed yet.
* T1: Transaction is committed.
  Hibernate Search automatically sends the updated A to the index.
  In this version, B is updated, but C is not.
* T2: Transaction is committed.
  Hibernate Search automatically sends the updated A to the index.
  In this version, C is updated, but B is not.

This chain of events ends with the index containing a version of A where C is updated, but B is not.

=== Solutions and workarounds

The following solutions can help circumvent this limitation:

1. Use a safer <<coordination,coordination strategy>>,
e.g. the <<coordination-database-polling,database-polling coordination strategy>>.
See in particular <<architecture-examples>>.
2. OR avoid parallel updates to entities that are indexed-embedded in the same indexed entity.
This is only possible in very specific setups.
3. OR schedule a <<mapper-orm-indexing-massindexer,full reindexing>> of your database periodically (e.g. every night)
to get the index back in sync with the database.

=== Roadmap

This limitation is caused directly by the lack of coordination between threads or application nodes,
so it can only be addressed completely by configuring <<coordination,coordination>>.

There are no other solutions currently on the roadmap.

[[limitations-backend-indexing-error]]
== Without coordination, backend errors during automatic indexing may lead to out-of sync indexes

=== Description

With the default settings (<<coordination-none,no coordination>>),
<<mapper-orm-indexing-automatic,automatic indexing>>
will actually apply index changes in the backend *just after* the transaction commit,
without any kind of transaction log for the index changes.

Consequently, should an error occur in the backend while indexing (i.e. an I/O error),
this indexing will be cancelled, with no way to cancel the corresponding database transaction:
the index will thus become out of sync.

NOTE: The risk is exclusively related to errors in the backend, mostly to filesystem or network issues.
Errors occurring in user code (getters, custom <<mapper-orm-bridge,bridges>>, ...)
will safely cancel the whole database transaction without indexing anything,
ensuring that indexes are still in sync with the database.

=== Solutions and workarounds

The following solutions can help circumvent this limitation:

1. Use a safer <<coordination,coordination strategy>>,
e.g. the <<coordination-database-polling,database-polling coordination strategy>>.
See in particular <<architecture-examples>>.
2. OR schedule a <<mapper-orm-indexing-massindexer,full reindexing>> of your database periodically (e.g. every night)
to get the index back in sync with the database.

=== Roadmap

This limitation is caused directly by the lack of persistence of entity change events,
so it can only be addressed completely by persisting those events,
e.g. by switching to the <<coordination-database-polling,database-polling coordination strategy>>.

Some incomplete countermeasures may be considered in future versions,
such as automatic in-thread retries,
but they will never solve the problem completely,
and they are not currently on the roadmap.

[[limitations-changes-in-session]]
== Automatic indexing only considers changes applied directly to entity instances in Hibernate ORM sessions

=== Description

Due to <<mapper-orm-indexing-automatic-concepts-changes-in-session,how Hibernate Search uses internal events of Hibernate ORM>>
in order to detect changes,
it will not detect changes resulting from `insert`/`delete`/`update` queries,
be it SQL or JPQL/HQL queries.

This is because queries are executed on the database side,
without Hibernate ORM or Search having any knowledge of which entities are actually created, deleted or updated.

=== Solutions and workarounds

One workaround is to reindex explicitly after you run JPQL/SQL queries,
either using the <<mapper-orm-indexing-massindexer,`MassIndexer`>>
or <<mapper-orm-indexing-manual,manually>>.

=== Roadmap

One solution to actually detect these changes would be to source entity change events
directly from the database, using for example Debezium.

This is tracked as https://hibernate.atlassian.net/browse/HSEARCH-3513[HSEARCH-3513],
but is long-term goal.

[[limitations-changes-asymmetric-association-updates]]
== Automatic indexing ignores asymmetric association updates
// Old anchors backwards compatibility
[[mapper-orm-indexing-automatic-concepts-session-consistency]]

=== Description

Hibernate ORM is able to handle asymmetric updates of associations,
where only the owning side of association is updated and the other side is ignored.
The entities in the session will be inconsistent for the duration of the session,
but upon reloading they will be consistent once again,
due to how entity loading works.

This practice of asymmetric updates of associations
can cause problems in applications in general,
but also in Hibernate Search specifically,
where it may lead to out-of-sync indexes.
Thus, it must be avoided.

For example, let's assume an indexed entity `A` has an `@IndexedEmbedded` association `A.b` to entity `B`,
and that `B` owns that association on its side, `B.a`.
One can just set `B.a` to `null` in order to remove the association between `A` and `B`,
and the effect on the database will be exactly what we want.

However, Hibernate Search will only be able to detect that `B.a` changed,
and by the time it tries to infer which entities need to be reindexed,
it will no longer be able to know what `B.a` used to refer to.
That change in itself is useless to Hibernate Search:
Hibernate Search will not know that `A`, specifically, needs to be reindexed.
It will "forget" to reindex `A`, leading to an out-of-sync index where `A.b` still contains `B`.

In the end, the only way for Hibernate Search to know that `A` needs to be reindexed
is to also set `A.b` to `null`, which will cause Hibernate Search to detect that `A.b` changed,
and thus that `A` changed too.

=== Solutions and workarounds

The following solutions can help circumvent this limitation:

1. When you update one side of an association,
always update the other side consistently.
2. When the above is not possible,
reindex affected entities explicitly after the association update,
either using the <<mapper-orm-indexing-massindexer,`MassIndexer`>>
or <<mapper-orm-indexing-manual,manually>>.

=== Roadmap

Hibernate Search may handle asymmetric association updates in the future,
by keeping tracks of entities added to / removed from an association.
However, this will only solve the problem completely if indexing happens asynchronously in a background thread,
such as with the <<coordination-database-polling,database-polling coordination strategy>>.
This is tracked as https://hibernate.atlassian.net/browse/HSEARCH-3567[HSEARCH-3567].

Alternatively, sourcing entity change events directly from the database, using for example Debezium,
would also solve the problem.
This is tracked as https://hibernate.atlassian.net/browse/HSEARCH-3513[HSEARCH-3513],
but is long-term goal.

[[limitations-indexing-plan-serialization]]
== Automatic indexing is not compatible with `Session` serialization

=== Description

When <<mapper-orm-indexing-automatic,automatic indexing>> is enabled,
Hibernate Search collects entity change events
to build an "indexing plan" inside the ORM `EntityManager`/`Session`.
The indexing plan holds information relative to which entities need to be reindexed,
and sometimes documents that have not been indexed yet.

The indexing plan cannot be serialized.

If the ORM `Session` gets serialized,
all collected change events will be lost upon deserializing the session,
and Hibernate Search will likely "forget" to reindex some entities.

This is fine in most applications, since they do not rely on serializing the session,
but it might be a problem with some JEE applications relying on Bean Passivation.

=== Solutions and workarounds

Avoid serializing an ORM `EntityManager`/`Session` after changing entities.

=== Roadmap

There are no plans to address this limitation.
We do not intend to support `Session` serialization when Hibernate Search is enabled.

[[limitations-database-polling-event-order]]
== With database-polling coordination, in rare cases, rapid deletion then re-creation of an entity may lead to out-of-sync indexes

=== Description

With <<coordination-database-polling,database-polling coordination>>,
entity change events are always processed in the order they happen
(or in an order that is close enough to produce the same indexing results),
except in the following case:

* An entity is deleted, then re-created with the same identifier.
* The deletion and re-creation happen very rapidly one after another,
so rapidly that the database date/time functions do not have enough resolution
to assign a different timestamp to the two events.
This generally means the two events happen **within ~1 microsecond** of each other.
* The deletion event is automatically assigned an identifier higher than the re-creation event.
This generally means link:{hibernateDocUrl}#identifiers-generators-optimizer[identifier generator optimizers] are used;
they may lead to out-of-order ID generation.

In this **very** specific case, the entity may end up being deleted from the index,
and not added until another change happens for that entity.

=== Solutions and workarounds

The following solutions can help circumvent this limitation:

1. Do not reuse identifiers when an indexed entity is deleted then re-created:
assign a different identifier to the re-created entity.
This should be the case with the vast majority of applications,
as long as they rely on automatically generated identifiers.
2. OR if you do reuse an identifier, ensure the entity re-creation
happens significantly more than 1 microsecond after its deletion.
3. OR schedule a <<mapper-orm-indexing-massindexer,full reindexing>> of your database periodically (e.g. every night)
to get the index back in sync with the database.

=== Roadmap

Several countermeasures are already in place,
and they are the reason the problem only occurs when the entity re-creation
happens shortly after (~1 microsecond) after the deletion.

https://hibernate.atlassian.net/browse/HSEARCH-4287[HSEARCH-4287] is expected to get rid of the limitation completely.
