[[search-dsl-highlighting]]
= Highlighting

include::components/incubating-warning.asciidoc[]

[[search-dsl-highlighting-basics]]
== Basics

Highlights are a special type of projection that allows seeing what caused a query match.
This projection wraps a portion of a full-text field that caused a query match
with a pair of opening and closing tags. It can help to quickly identify the information a user was searching for on a results page.

Highlight projections are only available for the full-text fields with a `highlightable` attribute configuration that allows it.

[[search-dsl-highlighting-configuring-fields-for-highlighting]]
.Configuring fields for highlighting
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/highlighting/Book.java[tags=basics]
----
<1> Allow plain and unified highlighter types to be applied to the `title` field.
<2> Allow any highlighter types to be applied to the `description` field.
====

[[search-dsl-highlighting-using-highlight-projection]]
.Using highlight projection
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/highlighting/HighlightingDslIT.java[tags=basics]
----
<1> <<entrypoints-search-session,Retrieve the `SearchSession`>>.
<2> Start building the query as usual.
<3> Mention that the expected result of the query is the highlights on the "title" field.
An exception will be thrown if the field is not a full-text field with enabled highlighting or if it does not exist.
<4> The predicate from the where clause will be used to determine which documents to include in the results
and highlight the text from the "title" field.
<5> Fetch the results, which will have highlighted fragments.
====

[NOTE]
====
Note that even though the "title" filed in the <<search-dsl-highlighting-using-highlight-projection,example above>>
is a single value field, the resulting projection is a list of strings.
This applies to any highlighting projection.
====

Highlight projections, same as <<search-dsl-projection-field,field projections>> can also be used in a combination with
other projection types as well as with other highlight projections:

[[search-dsl-highlighting-using-highlight-projection-composite]]
.Using a composite highlight projection
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/highlighting/HighlightingDslIT.java[tags=composite]
----
<1> Start building the query as usual.
<2> Add a regular field projection on a "title" field.
<3> Add a highlight projection on a "description" field.
<4> Note that to get a nonempty list for a highlight projection,
the field we apply such projection to should be a part of a predicate.
If there's no match within the field, we want to highlight - an empty list will be returned by default.
See <<search-dsl-highlighting-highlighter-options-no-match-size,no match size configuration>> option for more details on how this can be adjusted.
<5> Fetch the results.
====

Sometimes we might want to apply different highlighter types to various fields or specify some non-default configurations for a highlighter.
To accomplish this, a highlight projection can have an optional `highlighter(..)` parameter set to a name of a named highlighter.
As for the highlighter configurations - those can be passed to a query after the where clause.
There are named highlighters and a query highlighter. Named highlighters must be of the same type as a query one if such was configured.
Named highlighters override the settings of a query highlighter.

.Configuring both query and named highlighters
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/highlighting/HighlightingDslIT.java[tags=basic-config]
----
<1> Add a highlight projection on a "title" field. This projection uses a query highlighter.
<2> Add a highlight projection on a "description" field and specify a name of a named highlighter.
<3> Specify the details of a query highlighter.
<4> Specify the details of a named highlighter. Note that the name matches the name passed to the configuration of the "description"
highlight projection. Named highlighters can be reused by multiple highlight projections.
<5> Fetch the results.
====

[[search-dsl-highlighting-highlighter-type]]
== Highlighter type

There are four options to choose from when it comes to the highlighter type:

Default::
The default highlighter type will use one of the three other highlighters described below.
Which type will be used is backend-specific and might change in the future.
For now, both Lucene and Elasticsearch backends will use the unified highlighter.
+
Default highlighter exposes a set of simple configuration options available for all highlighter types.
Plain::
Plain highlighter can be useful for simple queries targeting a single field on a small number of documents.
This highlighter uses a standard Lucene highlighter. It reads the string value of a highlighted field,
then creates a small in-memory index from it and applies query logic to perform highlighting.
Unified::
Unified highlighter is used by default and does not necessarily rely on re-analyzing the text, as it can
get the offsets either from postings or from term vectors.
+
This highlighter uses a break iterator (breaks text into sentences by default) to break the text into later scored passages.
It better supports more complex queries. Since it can work with prebuilt data, it performs better in case of a larger amount
of documents compared to plain highlighter.
Fast vector::
Fast vector highlighter requires term vectors to be set to either `TermVector.WITH_POSITIONS_OFFSETS` or `TermVector.WITH_POSITIONS_OFFSETS_PAYLOADS`.
+
In addition to using a break iterator similar to the unified highlighter, it can use the boundary characters
to control the highlighted snippet.
+
This is the only highlighter that can assign different weights to highlighted fragments, allowing it to show
a fragment score differences by wrapping it with a different tag.
For more on tags, see <<search-dsl-highlighting-highlighter-options-tags,the corresponding section>>.

[NOTE]
====
If a full-text field that requires the `Highlightable.FAST_VECTOR` highlighter does not specify the term vectors,
or set them to anything else besides the two mentioned options - then the term vectors for that field
will get "upgraded" to one of `TermVector.WITH_POSITIONS_OFFSETS`/`TermVector.WITH_POSITIONS_OFFSETS_PAYLOADS`
depending on the initially specified value.
====

Picking the highlighter type is the first step in highlighter definition:

.Specifying highlighter type
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/highlighting/HighlightingDslIT.java[tags=various-highlighter-types]
----
<1> Starting a definition of a default highlighter.
Configuration options are limited to the most common ones that can be found in other highlighters.
<2> Starting a definition of a plain highlighter.
<3> Starting a definition of a unified highlighter.
<4> Starting a definition of a fast vector highlighter.
====

[[search-dsl-highlighting-highlighter-options]]
== Highlighter options

[NOTE]
====
Any optional highlighter settings can be set in a query highlighter and later overridden in a named highlighter.
If a query highlighter is set, then named highlighters must be of the same type, as an exception will be thrown otherwise.
====

[[search-dsl-highlighting-highlighter-options-tags]]
=== Tags

By default, the highlighted text is wrapped with a pair of `<em>`/`</em>` tags. A custom pair of tags can be provided to change this behaviour.
Usually, tags are a pair of HTML tags, but they can be a pair of any character sequences.

.Setting custom tags
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/highlighting/HighlightingDslIT.java[tags=basic-tags]
----
<1> Passing a pair of open/close tags that will be used to highlight the text.
====

[NOTE]
====
This setting is supported by all highlighter types.
====

Fast vector highlighter, which can handle multiple tags, has a few additional methods that accept a collection of tags.

.Setting multiple custom tags
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/highlighting/HighlightingDslIT.java[tags=fvh-tags]
----
*Note:* only one of the calls is required. Calling different tags configuration methods or the same one multiple times
within the same highlighter will *not* combine the tags. Only the tags set by the last call will be applied.


<1> Passing a pair of open/close tags that will be used to highlight the text.
<2> Passing a collection of open tags and a single closing tag that will be used to highlight the text.
It can be helpful when configuring a tag schema that differs only in an attribute of an opening tag.
<3> Passing a pair of collections containing open/close tags that will be used to highlight the text.
====

Additionally, fast vector highlighter has the option to enable a tag schema and set it to `HighlighterTagSchema.STYLED`
to use a predefined set of tags.

.Setting styled tags schema
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/highlighting/HighlightingDslIT.java[tags=fvh-schema]
----
<1> Passing a styled tags schema that will be used to highlight the text.
====

Using a styled tags schema is just a shortcut to defining the tags as:

.Setting tags as if the styled tags schema is used
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/highlighting/HighlightingDslIT.java[tags=fvh-schema-alternative]
----
<1> Passing the same collection of tags used when a styled schema is applied.
====

[NOTE]
====
If a styled tags schema is applied to a highlighter, then any other tag configurations are ignored, and the schema tags are used.
====

[[search-dsl-highlighting-highlighter-options-encoder]]
=== Encoder
Encoding can be applied to the highlighted snippets when highlighting the fields that store HTML. Applying an
HTML encoder to a highlighter will encode the text but keep the highlighting tags as is. By default, a `HighlighterEncoder.DEFAULT`
encoder is used, which keeps the text as is.

.Setting the HTML encoder
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/highlighting/HighlightingDslIT.java[tags=basic-encoder]
----
<1> Configuring the HTML encoder.
====

[NOTE]
====
This setting is supported by all highlighter types.
====

[[search-dsl-highlighting-highlighter-options-no-match-size]]
=== No match size
In case of more complex queries or when highlighting is performed for multiple fields, it might lead to a situation
where the query matched a document, but a particular highlighted field did not contribute to that match.
This will lead to an empty list of highlights for that particular document and that field.
No match size configuration allows you to still get some text returned even if the field didn't contribute to the document match,
and there's nothing to be highlighted in it.
The number set by this property defines the number of characters to be included starting at the beginning of a field.
Depending on the highlighter type, the amount of text returned might not precisely match the configured setting since
highlighters usually try not to break the text in the middle of a word/sentence, depending on their configuration.
By default, this setting is set to `0` and text will only be returned if there's something to highlight.

.Setting the no match size
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/highlighting/HighlightingDslIT.java[tags=no-match-size]
----
<1> We are looking for matches in the title.
<2> In case a word can also be found in the description - we'd want it to be highlighted.
<3> Setting no match size to `100` to still get at least `100` first characters of a description even if the match for
a word we are searching for is not found.
====

[NOTE]
====
This setting is supported by all highlighter types.
====

[[search-dsl-highlighting-highlighter-options-fragment-size]]
=== Fragment size and number of fragments
Fragment size limits the amount of text included in each highlighted fragment. Depending on the highlighter type/configuration,
the amount of text per fragment might be more than specified. By default, the fragment size is equal to `100` characters.

A number of fragments configuration sets the maximum number of strings included in the resulting highlighted list.
By default, the number of fragments is equal to `5`.

A combination of these settings can be helpful when highlighting large text fields.

.Setting the fragment size and number of fragments
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/highlighting/HighlightingDslIT.java[tags=fragment-size]
----
<1> Configuring the fragment size.
<2> Configuring the maximum number of fragments to be returned.
====

[NOTE]
====
These settings are supported by all highlighter types except for Lucene's default/unified highlighters.
====

[[search-dsl-highlighting-highlighter-options-order]]
=== Order
By default, highlighted fragments are returned in the order of occurrence in the text.
By enabling the order by score setting most relevant fragments will be returned at the top of the list.

.Setting the fragment size and number of fragments
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/highlighting/HighlightingDslIT.java[tags=basic-order]
----
<1> A query that would boost the match of one of the searched words.
<2> Configuring the order by the score to be enabled.
====

[NOTE]
====
This setting is supported by all highlighter types.
====

[[search-dsl-highlighting-highlighter-options-fragmenter]]
=== Fragmenter
By default, the plain highlighter breaks up text into same-sized fragments but tries to avoid breaking up a phrase to be highlighted.
This is the behaviour of the `HighlighterFragmenter.SPAN` fragmenter. Alternatively, fragmenter can be set to `HighlighterFragmenter.SIMPLE`
that simply breaks up text into same-sized fragments.

.Setting the fragmenter
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/highlighting/HighlightingDslIT.java[tags=basic-fragmenter]
----
<1> Configuring the simple fragmenter.
====

[NOTE]
====
This setting is supported only by the plain highlighter.
====

[[search-dsl-highlighting-highlighter-options-boundary-scanner]]
=== Boundary scanner

Unified and fast vector highlighters use boundary scanners to create highlighted fragments. They use a break iterator
when looking for a fragment's word/sentence boundaries. An optional locale parameter can be supplied to specify how to search
for sentence and word boundaries. A sentence boundary scanner is a default option for the unified highlighters.

There are two ways to supply boundary scanner configuration to a highlighter.

.Setting the boundary scanner with DSL
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/highlighting/HighlightingDslIT.java[tags=scanner-dsl]
----
<1> Start the definition of a boundary scanner.
<2> Pick a boundary scanner type - a word scanner in this case.
<3> Set an optional locale.
<4> End the definition of a boundary scanner.
<5> Set any other configurations.
====

.Setting the boundary scanner using lambda
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/highlighting/HighlightingDslIT.java[tags=scanner-lambda]
----
<1> Pass a lambda configurer to set up a boundary scanner.
<2> Set any other configurations
====

Additionally, fast vector highlighter can use a character boundary scanner which relies on two other configurations -
boundary characters and boundary max scan. When a character boundary scanner is used after a highlighted fragment is formed
with highlighted text centred, the highlighter checks for the first occurrence of any configured boundary characters to the left and right
of a currently created fragment. This lookup happens only for a maximum number of characters configured by the boundary max scan option.
If boundary characters were not found - no additional text will be included besides the already highlighted phrase
with surrounding text based on a fragment size setting. The default list of boundary characters includes `.,!? \t\n`.
The default boundary max scan is equal to `20` characters.

Character boundary scanner is a default option for the fast vector highlighters.

.Setting the character boundary scanner
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/highlighting/HighlightingDslIT.java[tags=scanner-char]
----
Assuming that we have a text that contains multiple paragraphs separated with a new line (`\n`), we want to
get the entire paragraph containing the highlighted phrase. To do so, boundary characters will be set to `\n`, and
the max scan option will be based on the number of characters in paragraphs.

<1> Start the definition of a boundary scanner.
<2> Pick a boundary scanner type - a character scanner.
<3> Set a string containing boundary characters. The overloaded methods can accept a `String` or a `Character` array.
<4> Set the max scan option.
<5> End the definition of a boundary scanner.
<6> Set any other configurations.
====

[NOTE]
====
This setting is supported by the unified and fast vector highlighter types.
====

[[search-dsl-highlighting-highlighter-options-phrase-limit]]
=== Phrase limit
Phrase limit allows to specify the maximum number of matching phrases in a document for highlighting. By default, it is equal to `256`.
This setting can be helpful if a field contains many matches and has a lot of text overall, but we are not interested in
highlighting every occurrence.

.Setting the phrase limit
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/highlighting/HighlightingDslIT.java[tags=phrase-limit]
----
<1> Configuring the phrase limit.
====

[NOTE]
====
This setting is supported only by the fast vector highlighter type.
====
