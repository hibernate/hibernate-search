[[search-dsl-predicate]]
= [[query-predicate]] Predicate DSL

[[search-dsl-predicate-concepts]]
== Basics

The main component of a search query is the _predicate_,
i.e. the condition that every document must satisfy in order to be included in search results.

The predicate is configured when building the search query:

.Defining the predicate of a search query
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=entryPoint-lambdas]
----
<1> <<entrypoints-search-session,Retrieve the `SearchSession`>>.
<2> Start building the query.
<3> Mention that the results of the query are expected to have a `title` field matching the value `robot`.
If the field does not exist or cannot be searched on, an exception will be thrown.
<4> Fetch the results, which will match the given predicate.
====

Alternatively, if you don't want to use lambdas:

.Defining the predicate of a search query -- object-based syntax
====
[source, JAVA, indent=0]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=entryPoint-objects]
----
====

The predicate DSL offers more predicate types, and multiple options for each type of predicate.
To learn more about the `match` predicate, and all the other types of predicate,
refer to the following sections.

[[search-dsl-predicate-match-all]]
== `matchAll`: match all documents

The `matchAll` predicate simply matches all documents.

.Matching all documents
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=matchAll]
----
====

[[search-dsl-predicate-match-all-except]]
=== `except(...)`: exclude documents matching a given predicate

Optionally, you can exclude a few documents from the hits:

.Matching all documents except those matching a given predicate
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=matchAll-except]
----
====

[[search-dsl-predicate-match-all-other]]
=== Other options

* The score of a `matchAll` predicate is constant and equal to 1 by default,
but can be <<search-dsl-predicate-common-boost,boosted with `.boost(...)`>>.

[[search-dsl-predicate-match-none]]
== `matchNone`: match no documents

The `matchNone` predicate is the inverse of `matchAll` and matches no documents.

.Matching no documents
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=matchNone]
----
====

[[search-dsl-predicate-id]]
== `id`: match a document identifier

The `id` predicate matches documents by their identifier.

.Matching a document with a given identifier
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=id]
----
====

You can also match multiple ids in a single predicate:

.Matching all documents with an identifier among a given collection
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=id-matchingAny]
----
====

[[search-dsl-predicate-id-argument-type]]
=== Expected type of arguments

By default, the `id` predicate expects arguments to the `matching(...)`/`matchingAny(...)` methods
to have the same type as the entity property corresponding to the document id.

For example, if the document identifier is generated from an entity identifier of type `Long`,
the document identifier will still be of type `String`.
`matching(...)`/`matchingAny(...)` will expect its argument to be of type `Long` regardless.

This should generally be what you want,
but if you ever need to bypass conversion and pass an unconverted argument (of type `String`)
to `matching(...)`/`matchingAny(...)`, see <<search-dsl-argument-type>>.

[[search-dsl-predicate-id-other]]
=== Other options

* The score of an `id` predicate is constant and equal to 1 by default,
but can be <<search-dsl-predicate-common-boost,boosted with `.boost(...)`>>.

[[search-dsl-predicate-match]]
== [[_keyword_queries]] `match`: match a value

The `match` predicate matches documents for which a given field has a given value.

.Matching a value
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=match]
----
====

[[search-dsl-predicate-match-argument-type]]
=== Expected type of arguments

By default, the `match` predicate expects arguments to the `matching(...)` method
to have the same type as the entity property corresponding to the target field.

For example, if an entity property is of an enum type,
<<mapping-directfieldmapping-supported-types,the corresponding field may be of type `String`>>.
`.matching(...)` will expect its argument to have the enum type regardless.

This should generally be what you want,
but if you ever need to bypass conversion and pass an unconverted argument
(of type `String` in the example above)
to `.matching(...)`, see <<search-dsl-argument-type>>.

[[search-dsl-predicate-match-multiple-fields]]
=== Targeting multiple fields

Optionally, the predicate can target multiple fields.
In that case, the predicate will match documents for which _any_ of the given fields matches.

See <<search-dsl-predicate-common-multiple-fields>>.

[[search-dsl-predicate-match-analysis]]
=== Analysis

For most field types (number, date, ...), the match is exact.
However, for <<mapping-directfieldmapping-annotations-fulltextfield,full-text>> fields
or <<mapping-directfieldmapping-annotations-keywordfield,normalized keyword>> fields,
the value passed to the `matching(...)` method is analyzed or normalized before being compared to the values in the index.
This means the match is more subtle in two ways.

First, the predicate will not just match documents for which a given field has the exact same value:
it will match all documents for which this field has a value whose normalized form is identical.
See below for an example.

.Matching normalized terms
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=match-normalized]
----
<1> For analyzed/normalized fields, the value passed to `matching` will be analyzed/normalized.
In this case, the result of analysis is a lowercase string: `asimov`.
<2> All returned hits will have a value whose normalized form is identical.
In this case, `Asimov` was normalized to `asimov` too, so it matched.
====

Second, for <<mapping-directfieldmapping-annotations-fulltextfield,full-text>> fields,
the value passed to the `matching(...)` method is tokenized.
This means multiple terms may be extracted from the input value,
and the predicate will match all documents for which the given field has a value that _contains any of those terms_,
at any place and in any order.
See below for an example.

.Matching multiple terms
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=match-multipleTerms]
----
<1> For full-text fields, the value passed to `matching` will be tokenized and normalized.
In this case, the result of analysis is the terms `robot` and `dawn` (notice they were lowercased).
<2> All returned hits will match *at least one* term of the given string.
`The Robots of Dawn` contained both normalized terms `robot` and `dawn`, so it matched,
but so did `I, Robot`, even though it didn't contain `dawn`: only one term is required.
====

[TIP]
====
Hits matching multiple terms, or matching more relevant terms, will have a higher <<search-dsl-predicate-common-score,score>>.
Thus, if you sort by score, the most relevant hits will appear to the top of the result list.
This usually makes up for the fact that the predicate does not require _all_ terms to be present in matched documents.
====

// TODO HSEARCH-917 add an option to match all terms instead of any term, then document it here
// In the meantime, we'll just provide the following tip.

[TIP]
====
If you need _all_ terms to be present in matched documents,
you should be able to do so by using the <<search-dsl-predicate-simple-query-string,`simpleQueryString`>> predicate,
in particular its ability to define a <<search-dsl-predicate-simple-query-string-boolean-operators-default,default operator>>.
Just make sure to define which <<search-dsl-predicate-simple-query-string-flags,syntax features>>
you want to expose to your users.
====

[[search-dsl-predicate-match-fuzzy]]
=== [[_fuzzy_queries]] `fuzzy`: match a text value approximately

The `.fuzzy()` option allows for approximate matches,
i.e. it allows matching documents for which a given field has a value that is not exactly the value passed to `matching(...)`,
but a close value, for example with one letter that was switched for another.

NOTE: This option is only available on text fields.

.Matching a text value approximately
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=match-fuzzy]
----
====

Roughly speaking, the edit distance is the number of changes between two terms:
switching characters, removing them, ...
It defaults to `2` when fuzzy matching is enabled,
but can also be set to `0` (fuzzy matching disabled) or `1` (only one change allowed, so "less fuzzy").
Values higher than 2 are not allowed.

.Matching a text value approximately with explicit edit distance
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=match-fuzzy-maxEditDistance]
----
====

Optionally, you can force the match to be exact for the first `n` characters.
`n` is called the "exact-prefix length".
Setting this to a non-zero value is recommended for indexes containing a large amount of distinct terms,
for performance reasons.

.Matching a text value approximately with exact prefix length
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=match-fuzzy-exactPrefixLength]
----
====

[[search-dsl-predicate-match-other]]
=== Other options

* The score of a `match` predicate is variable for text fields by default,
but can be <<search-dsl-predicate-common-constantScore,made constant with `.constantScore()`>>.
* The score of a `match` predicate can be <<search-dsl-predicate-common-boost,boosted>>,
either on a per-field basis with a call to `.boost(...)` just after `.field(...)`/`.fields(...)`
or for the whole predicate with a call to `.boost(...)` after `.matching(...)`.
* The `match` predicate uses the <<mapping-directfieldmapping-search-analyzer,search analyzer>>
of targeted fields to analyze searched text by default,
but this can be <<search-dsl-predicate-common-overriding-analysis,overridden>>.

[[search-dsl-predicate-range]]
== [[_range_queries]] `range`: match a range of values

The `range` predicate matches documents for which a given field has a value within a given range.

.Matching a range of values
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=range-between]
----
====

The `between` method includes both bounds,
i.e. documents whose value is exactly one of the bounds will match the `range` predicate.

At least one bound must be provided.
If a bound is `null`, it will not constrain matches.
For example `.between( 2, null )` will match all values higher than or equal to 2.

Different methods can be called instead of `between` in order to control the inclusion of the lower and upper bound:

`atLeast`::
+
.Matching values equal to or greater than a given value
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=range-atLeast]
----
====
`greaterThan`::
+
.Matching values strictly greater than a given value
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=range-greaterThan]
----
====
`atMost`::
+
.Matching values equal to or less than a given value
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=range-atMost]
----
====
`lessThan`::
+
.Matching values strictly less than a given value
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=range-lessThan]
----
====

Alternatively, you can specify whether bounds are included or excluded explicitly:

.Matching a range of values with explicit bound inclusion/exclusion
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=range-between-advanced]
----
====

[[search-dsl-predicate-range-argument-type]]
=== Expected type of arguments

By default, the `range` predicate expects arguments to the `between(...)`/`atLeast(...)`/etc. method
to have the same type as the entity property corresponding to the target field.

For example, if an entity property is of type `java.util.Date`,
<<mapping-directfieldmapping-supported-types,the corresponding field may be of type `java.time.Instant`>>;
`between(...)`/`atLeast(...)`/etc. will expect its arguments to have type `java.util.Date` regardless.
Similarly, `range(...)` will expect an argument of type `Range<java.util.Date>`.

This should generally be what you want,
but if you ever need to bypass conversion and pass an unconverted argument
(of type `java.time.Instant` in the example above)
to `between(...)`/`atLeast(...)`/etc., see <<search-dsl-argument-type>>.

[[search-dsl-predicate-range-multiple-fields]]
=== Targeting multiple fields

Optionally, the predicate can target multiple fields.
In that case, the predicate will match documents for which _any_ of the given fields matches.

See <<search-dsl-predicate-common-multiple-fields>>.

[[search-dsl-predicate-range-other]]
=== Other options

* The score of a `range` predicate is constant and equal to 1 by default,
but can be <<search-dsl-predicate-common-boost,boosted>>,
either on a per-field basis with a call to `.boost(...)` just after `.field(...)`/`.fields(...)`
or for the whole predicate with a call to `.boost(...)` after `.between(...)`/`atLeast(...)`/etc.

[[search-dsl-predicate-phrase]]
== [[_phrase_queries]] `phrase`: match a sequence of words

The `phrase` predicate matches documents for which a given field contains a given sequence of words, in the given order.

NOTE: This predicate is only available on <<mapping-directfieldmapping-annotations-fulltextfield,full-text fields>>.

.Matching a sequence of words
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=phrase]
----
====

[[search-dsl-predicate-phrase-slop]]
=== `slop`: match a sequence of words approximately

Specifying a _slop_ allows for approximate matches,
i.e. it allows matching documents for which a given field contains the given sequence of words,
but in a slightly different order, or with extra words.

The slop represents the number of edit operations that can be applied to the sequence of words to match,
where each edit operation moves one word by one position.
So `quick fox` with a slop of `1` can become `quick <word> fox`, where `<word>` can be any word.
`quick fox` with a slop of `2` can become `quick <word> fox`, or `quick <word1> <word2> fox`
or even `fox quick` (two operations: moved `fox` to the left and `quick` to the right).
And similarly for higher slops and for phrases with more words.

.Matching a sequence of words approximately with `slop(...)`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=phrase-slop]
----
====

[[search-dsl-predicate-phrase-multiple-fields]]
=== Targeting multiple fields

Optionally, the predicate can target multiple fields.
In that case, the predicate will match documents for which _any_ of the given fields matches.

See <<search-dsl-predicate-common-multiple-fields>>.

[[search-dsl-predicate-phrase-other]]
=== Other options

* The score of a `phrase` predicate is variable by default,
but can be <<search-dsl-predicate-common-constantScore,made constant with `.constantScore()`>>.
* The score of a `phrase` predicate can be <<search-dsl-predicate-common-boost,boosted>>,
either on a per-field basis with a call to `.boost(...)` just after `.field(...)`/`.fields(...)`
or for the whole predicate with a call to `.boost(...)` after `.matching(...)`.
* The `phrase` predicate uses the <<mapping-directfieldmapping-search-analyzer,search analyzer>>
of targeted fields  to analyze searched text by default,
but this can be <<search-dsl-predicate-common-overriding-analysis,overridden>>.

[[search-dsl-predicate-exists]]
== `exists`: match fields with content

The `exists` predicate matches documents for which a given field has a non-null value.

.Matching fields with content
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=exists]
----
====

[TIP]
====
There isn't any built-in predicate to match documents for which a given field is null,
but you can easily create one yourself by negating an `exists` predicate.

This can be achieved by using an `exists` predicate
in a <<search-dsl-predicate-boolean-mustNot,`mustNot` clause in a boolean predicate>>,
or in an <<search-dsl-predicate-match-all-except,`except` clause in a `matchAll` predicate>>.
====

[[search-dsl-predicate-exists-object-field]]
=== Object fields

The `exists` predicate can also be applied to an object field.
In that case, it will match all documents for which at least one inner field of the given object field has a non-null value.

.Matching object fields with content
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=exists-object]
----
====

[IMPORTANT]
====
Object fields need to have at least one inner field with content in order to be considered as "existing".

Let's consider the example above, and let's assume the `placeOfBirth` object field
only has one inner field: `placeOfBirth.country`:

* an author whose `placeOfBirth` is null will not match.
* an author whose `placeOfBirth` is not null and has the `country` filled in will match.
* an author whose `placeOfBirth` is not null but does not have the `country` filled in **will not match**.

Because of this, it is preferable to use the `exists` predicate
on object fields that are known to have at least one inner field that is never null: an identifier, a name, ...
====

[[search-dsl-predicate-exists-other]]
=== Other options

* The score of an `exists` predicate is constant and equal to 1 by default,
but can be <<search-dsl-predicate-common-boost,boosted with a call to `.boost(...)`>>.

[[search-dsl-predicate-wildcard]]
== [[_wildcard_queries]] `wildcard`: match a simple pattern

The `wildcard` predicate matches documents for which a given field contains a word matching the given pattern.

.Matching a simple pattern
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=wildcard]
----
====

The pattern may include the following characters:

* `*` matches zero, one or multiple characters.
* `?` matches zero or one character.
* `\` escape the following character,
e.g. `\?` is interpreted as a literal `?`, `\\` as a literal `\`, etc.
* any other character is interpreted as a literal.

[IMPORTANT]
====
If a normalizer has been defined on the field, the patterns used in wildcard predicates
will be normalized.

If an analyzer has been defined on the field:

* when using the Elasticsearch backend, the patterns won't be analyzed nor normalized,
and will be expected to match a *single* indexed token, not a sequence of tokens.
This may behave differently on an older versions of the underlying search engine
(for example with Elasticsearch 7.7-7.11 or OpenSearch prior to 2.5 the wildcard pattern will get normalized).
Hence, please refer to the documentation of your particular version for the exact behaviour.
* when using the Lucene backend the patterns will be normalized, but not tokenized:
the pattern will still be expected to match a *single* indexed token, not a sequence of tokens.

For example, a pattern such as `Cat*` could match `cat`
when targeting a field having a normalizer that applies a lowercase filter when indexing.

A pattern such as `john gr*` will not match anything
when targeting a field that tokenizes on spaces.
`gr*` may match, since it doesn't include any space.

When the goal is to match user-provided query strings,
the <<search-dsl-predicate-simple-query-string,simple query string predicate>> should be preferred.
====

[[search-dsl-predicate-wildcard-multiple-fields]]
=== Targeting multiple fields

Optionally, the predicate can target multiple fields.
In that case, the predicate will match documents for which _any_ of the given fields matches.

See <<search-dsl-predicate-common-multiple-fields>>.

[[search-dsl-predicate-wildcard-other]]
=== Other options

* The score of a `wildcard` predicate is constant and equal to 1 by default,
but can be <<search-dsl-predicate-common-boost,boosted>>,
either on a per-field basis with a call to `.boost(...)` just after `.field(...)`/`.fields(...)`
or for the whole predicate with a call to `.boost(...)` after `.matching(...)`.

[[search-dsl-predicate-regexp]]
== `regexp`: match a regular expression pattern

The `regexp` predicate matches documents for which a given field contains a word matching the given regular expression.

.Matching a regular expression pattern
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=regexp]
----
====

[[search-dsl-predicate-regexp-analysis]]
=== [[_regexp_predicates_and_analysis]] Regexp predicates and analysis

NOTE: For an introduction to analysis and how to configure it,
refer to the <<concepts-analysis>> section.

The behavior of regexp predicates on analyzed/normalized fields is a bit complex,
so here is a summary of how it works.

Regexps must match **the entirety** of analyzed/normalized tokens::
For a field that is lowercased and tokenized on spaces (using an analyzer), the regexp `pass:[robots?]`:
+
* will match `Robot`: the indexed token `robot` matches.
* will match `I love robots`: the indexed token `robots` matches.
* will **not** match `Mr. Roboto`: the indexed token `roboto` does not match.
+
For a field that is lowercased but not tokenized (using a normalizer), the regexp `pass:[robots?]`:
+
* will match `Robot`: the indexed token `robot` matches.
* will **not** match `I love robots`: the indexed token `i love robots` does not match.
* will **not** match `Mr. Roboto`: the indexed token `mr. roboto` does not match.

Regexps are never tokenized, even if fields are::
Beware of spaces in regexps, in particular.
+
For a field that is tokenized on spaces (using an analyzer), the regexp `pass:[.*love .* robots?]` will never match anything,
because it requires a space inside the token and indexed tokens don't contain any (since tokenization happens on spaces).
+
For a field that is lowercased, but not tokenized (using a normalizer), the regexp `pass:[.*love .* robots?]`:
+
* will match `I love robots`, which was indexed as `i love robots`.
* will match `I love my Robot`, which was indexed as `i love my robot`.
* will **not** match `I love Mr. Roboto`, which was indexed as `i love mr. roboto`: `roboto` doesn't match `robots?`.

With the Lucene backend, regexps are never analyzed nor normalized::
For a field that is lowercased and tokenized on spaces:
+
* the regexp `pass:[Robots?]` will **not** be normalized and will never match anything,
because it requires an uppercase letter and indexed tokens don't contain any (since they are lowercased).
* the regexp `pass:[[Rr\]obots?]` will **not** be normalized but will match `I love Robots`: the indexed token `robots` matches.
* the regexp `pass:[love .* robots?]` will **not** be normalized and will match `I love my Robot` as well as `I love robots`, but not `Robots love me`.

With the Elasticsearch backend, regexps are not analyzed nor normalized on text (tokenized) fields, but **are normalized on keyword (non-tokenized) fields**::
For a field that is lowercased and tokenized on spaces (using an analyzer):
+
* the regexp `pass:[Robots?]` will **not** be normalized and will never match anything,
because it requires an uppercase letter and indexed tokens don't contain any (since they are lowercased).
* the regexp `pass:[[Rr\]obots?]` will **not** be normalized but will match `I love Robots`: the indexed token `robots` matches.
* the regexp `pass:[love .* robots?]` will **not** be normalized and will match `I love my Robot` as well as `I love robots`, but not `Robots love me`.
+
However, **behavior differs from Lucene for normalized fields**!
For a field that is lowercased, but not tokenized (using a normalizer):
+
* the regexp `pass:[Robots?+]` will be normalized to `pass:[robots?]` and will match `I love robots`: the indexed token `robots` matches.
* the regexp `pass:[[Rr\]obots?+]` will be normalized to `pass:[[rr\]obots?]` and will match `I love Robots`: the indexed token `robots` matches.
* the regexp `pass:[love .* robots?]` will match `I love my Robot` as well as `I love robots`, but not `Robots love me`.
+
[WARNING]
====
As a result of Elasticsearch normalizing regular expressions,
normalizers can interfere with regexp meta-characters and completely change the meaning of a regexp.

For example, for a field whose normalizer replaces the characters `*` and `?` with `+_+`,
the regexp `pass:[Robots?]` will be normalized to `pass:[Robots_]` and will probably never match anything.

This behavior is considered a bug and
https://github.com/elastic/elasticsearch/issues/80189[was reported to the Elasticsearch project].
====

[[search-dsl-predicate-regexp-flags]]
=== `flags`: enabling only specific syntax constructs

By default, Hibernate Search does not enable any optional operators.
To enable some of them, it is possible to specify the `flags` attribute.

.Matching a regular expression pattern with flags
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=regexp-flags]
----
====

The following flags/operators are available:

* `COMPLEMENT`: the `~` operator will negate the following pattern.
+
For example `+a~bc+` matches `aac` but not `abc`.
+
Don't forget to use parentheses if you need to negate a composite pattern, e.g. `+a~(bc)+`
* `INTERVAL`: the `<>` operator matches a non-negative integer range, both ends included.
+
For example `+a<1-10>+` matches `a1`, `a2`, ... `a9`, `a10`, but not `a11`.
+
Leading zeroes are meaningful, e.g. `+a<01-10>+` matches `a01` and `a02` but not `a1` nor `a2`.
* `INTERSECTION`: the `&` operator combines two regexps with an AND operator.
+
For example `+.*a.*&.*z.*+` matches `az`, `za`, `babzb`, `bzbab`, but not `a` nor `z`.
* `ANYSTRING`: the `@` operator matches any string; equivalent to `+.*+`.
+
This operator is mostly useful to negate a pattern, e.g. `+@&~(ab)+` matches anything except the string `ab`.

[[search-dsl-predicate-regexp-multiple-fields]]
=== Targeting multiple fields

Optionally, the predicate can target multiple fields.
In that case, the predicate will match documents for which _any_ of the given fields matches.

See <<search-dsl-predicate-common-multiple-fields>>.

[[search-dsl-predicate-regexp-other]]
=== Other options

* The score of a `regexp` predicate is constant and equal to 1 by default,
but can be <<search-dsl-predicate-common-boost,boosted>>,
either on a per-field basis with a call to `.boost(...)` just after `.field(...)`/`.fields(...)`
or for the whole predicate with a call to `.boost(...)` after `.matching(...)`.

[[search-dsl-predicate-terms]]
== `terms`: match a set of terms

The `terms` predicate matches documents for which a given field contains some terms, any or all of them.

With `matchingAny` we require that at least one of the provided terms matches.
Functionally, this is somewhat similar to a <<search-dsl-predicate-boolean-or,boolean `OR`>> with one <<search-dsl-predicate-match,`match`>> predicate per term, but the syntax for a single `terms` predicate is more concise.

NOTE: `matchingAny` expects to be passed *terms*, not just any string. The given terms will not be analyzed. See <<search-dsl-predicate-terms-analysis>>.

.Matching any of the provided terms
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=terms-any]
----
====

With `matchingAll` we require that all the provided terms match.
Functionally, this is somewhat similar to a <<search-dsl-predicate-boolean-and,boolean `AND`>> with one <<search-dsl-predicate-match,`match`>> predicate per term, but the syntax for a single `terms` predicate is more concise.

NOTE: `matchingAll` expects to be passed *terms*, not just any string. The given terms will not be analyzed. See <<search-dsl-predicate-terms-analysis>>.

[WARNING]
====
By default, `matchingAll` will not accept more than 1024 terms.

It is possible to raise this limit through backend-specific configuration:

* For the Lucene backend, run this code when starting up your application: `org.apache.lucene.search.BooleanQuery.maxClauseCount = <your limit>;`
* For the Elasticsearch backend, see link:{elasticsearchDocUrl}/search-settings.html[the global setting `indices.query.bool.max_clause_count` in the Elasticsearch documentation].

However, keep in mind the limit is there for a reason: attempts to match very large numbers of terms will perform poorly and could lead to crashes.
====

.Matching all the provided terms
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=terms-any]
----
====

[[search-dsl-predicate-terms-analysis]]
=== `terms` predicates and analysis

NOTE: For an introduction to analysis and how to configure it,
refer to the <<concepts-analysis>> section.

Differently from other predicates, the terms passed to `matchingAny()` or `matchingAll()`
are never analyzed nor **usually** normalized.
[IMPORTANT]
====
If an analyzer has been defined on the field, the terms will not be analyzed nor normalized.

If a normalizer has been defined on the field:

* when using the Elasticsearch backend, the terms **will** be normalized.
* when using the Lucene backend, the terms **will not** be normalized.

For example, the term `Cat` could match `cat`
when targeting a field having a normalizer that applies a lowercase filter when indexing,
but only when using the Elasticsearch backend.
When using the Lucene backend, only the term `cat` could match `cat`.
====

[[search-dsl-predicate-terms-argument-type]]
=== [[_expected_type_of_arguments]] Expected type of arguments

By default, the `terms` predicate expects arguments to the `matchingAny(...)` or `matchingAll(...)` methods
to have the same type as the entity property corresponding to the target field.

For example, if an entity property is of an enum type,
<<mapping-directfieldmapping-supported-types,the corresponding field may be of type `String`>>.
`.matchingAny(...)` will expect its argument to have the enum type regardless.

This should generally be what you want,
but if you ever need to bypass conversion and pass an unconverted argument
(of type `String` in the example above)
to `.matchingAny(...)` or `.matchingAll(...)`, see <<search-dsl-argument-type>>.

[[search-dsl-predicate-terms-multiple-fields]]
=== Targeting multiple fields

Optionally, the predicate can target multiple fields.
In that case, the predicate will match documents for which _any_ of the given fields matches.

See <<search-dsl-predicate-common-multiple-fields>>.

[[search-dsl-predicate-terms-other]]
=== Other options

* The score of a `terms` predicate is constant and equal to 1 by default,
but can be <<search-dsl-predicate-common-boost,boosted>>,
either on a per-field basis with a call to `.boost(...)` just after `.field(...)`/`.fields(...)`
or for the whole predicate with a call to `.boost(...)` after `.matchingAny(...)` or `.matchingAll(...)`.

[[search-dsl-predicate-and]]
== `and`: match all clauses

The `and` predicate matches documents that match **all** of its inner predicates, called "clauses".

Matching "and" clauses are taken into account during <<search-dsl-predicate-common-score,score>> computation.

.Matching a document that matches all the multiple given predicates (~`AND` operator)
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=and]
----
<1> The hits *must* have a `title` field matching the text `robot`,
independently of other clauses in the same boolean predicate.
<2> The hits *must* have a `description` field matching the text `crime`,
independently of other clauses in the same boolean predicate.
<3> All returned hits will match *all* the clauses above:
they will have a `title` field matching the text `robot`
*and* they will have a `description` field matching the text `crime`.
====

[[search-dsl-predicate-and-lambda]]
=== Adding clauses dynamically with the lambda syntax

It is possible to define the `and` predicate inside a lambda expression.
This is especially useful when clauses need to be added dynamically to the `and` predicate,
for example based on user input.

.Easily adding clauses dynamically using `.where(...)` and the lambda syntax
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=and-dynamicParameters-root]
----
<1> Get a custom object holding the search parameters provided by the user through a web form, for example.
<2> Call `.where(BiConsumer)`.
The consumer, implemented by a lambda expression, will receive a predicate factory as well as clause collector as an argument,
and will add clauses to that collector as necessary.
<3> By default, a boolean predicate will match nothing if there is no clause.
To match every document when there is no clause, add a `and` clause that matches everything.
<4> Inside the lambda, the code is free to use any Java language constructs, such as `if` or `for`,
to control the addition of clauses.
In this case, we only add clauses if the relevant parameter was filled in by the user.
====

Another syntax relying on the method `with(...)` can be useful when the `and` predicate is not the root predicate:

.Easily adding clauses dynamically using `with(...)` and the lambda syntax
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=and-dynamicParameters-with]
----
<1> Get a custom object holding the search parameters provided by the user through a web form, for example.
<2> Call `.where(Function)`.
The function, implemented by a lambda expression, will receive a predicate factory, use it to build an `and` predicate,
invoke the `with(Consumer)` method and return this predicate. The consumer, implemented by a lambda expression,
will receive a clause collector for the `and` predicate as an argument, and will add clauses to that collector as necessary.
<3> By default, a boolean predicate will match nothing if there is no clause.
To match every document when there is no clause, add an `and` clause that matches everything.
<4> Inside the lambda, the code is free to use any Java language constructs, such as `if` or `for`,
to control the addition of clauses.
In this case, we only add clauses if the relevant parameter was filled in by the user.
====

[[search-dsl-predicate-and-other]]
=== Options

* The score of an `and` predicate is variable by default,
but can be <<search-dsl-predicate-common-constantScore,made constant with `.constantScore()`>>.
* The score of an `and` predicate can be <<search-dsl-predicate-common-boost,boosted>>
with a call to `.boost(...)`.

[[search-dsl-predicate-or]]
== `or`: match any clause

The `or` predicate matches documents that match **any** of its inner predicates, called "clauses".

Matching `or` clauses are taken into account during <<search-dsl-predicate-common-score,score>> computation.

.Matching a document that matches any of multiple given predicates (~`OR` operator)
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=or]
----
<1> The hits *should* have a `title` field matching the text `robot`,
*or* they should match any other clause in the same boolean predicate.
<2> The hits *should* have a `description` field matching the text `investigation`,
*or* they should match any other clause in the same boolean predicate.
<3> All returned hits will match *at least one* of the clauses above:
they will have a `title` field matching the text `robot`
*or* they will have a `description` field matching the text `investigation`.
====

[[search-dsl-predicate-or-lambda]]
=== Adding clauses dynamically with the lambda syntax

It is possible to define the `or` predicate inside a lambda expression.
This is especially useful when clauses need to be added dynamically to the `or` predicate,
for example based on user input.

.Easily adding clauses dynamically using `with(...)` and the lambda syntax
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=or-dynamicParameters-root]
----
<1> Get a custom object holding the search parameters provided by the user through a web form, for example.0
<2> Call `.where(Function)`.
The function, implemented by a lambda expression, will receive a predicate factory, use it to build an `or` predicate,
invoke the `with(Consumer)` method and return this predicate. The consumer, implemented by a lambda expression,
will receive a clause collector for the `or` predicate as an argument, and will add clauses to that collector as necessary.
<3> Inside the lambda, the code is free to use any Java language constructs, such as `if` or `for`,
to control the addition of clauses.
In this case, we only add clauses if the relevant parameter was filled in by the user.
====


[[search-dsl-predicate-or-other]]
=== Options

* The score of an `or` predicate is variable by default,
but can be <<search-dsl-predicate-common-constantScore,made constant with `.constantScore()`>>.
* The score of an `or` predicate can be <<search-dsl-predicate-common-boost,boosted>>
with a call to `.boost(...)`.


[[search-dsl-predicate-not]]
== `not`: negating another predicate

The `not` predicate matches documents that are not matched by a given predicate.

.Negating a `match` predicate
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=not]
----
====

[[search-dsl-predicate-not-other]]
=== Other options

* The score of a `not` predicate is constant and equal to 0 by default,
but if <<search-dsl-predicate-common-boost,boosted with `.boost(...)`>> the default would be changed to 1
and corresponding boost will be applied.


[[search-dsl-predicate-boolean]]
== [[_combining_queries]] `bool`: advanced combinations of predicates (or/and/...)

The `bool` predicate allows combining inner predicates in a more complex fashion than with simpler
<<search-dsl-predicate-and,`and`>>/<<search-dsl-predicate-or,`or`>> predicates.

The `bool` predicate matches documents that match one or more inner predicates, called "clauses".
It can be used in particular to build `AND`/`OR` operators with additional settings.

Inner predicates are added as clauses of one of the following types:

[[search-dsl-predicate-boolean-clauses-must]]`must`::
`must` clauses are required to match: if they don't match, then the `bool` predicate will not match.
+
Matching "must" clauses are taken into account during <<search-dsl-predicate-common-score,score>> computation.
[[search-dsl-predicate-boolean-clauses-mustNot]]`mustNot`::
`mustNot` clauses are required to not match: if they match, then the `bool` predicate will not match.
+
"must not" clauses are ignored during <<search-dsl-predicate-common-score,score>> computation.
[[search-dsl-predicate-boolean-clauses-filter]]`filter`::
`filter` clauses are required to match: if they don't match, then the boolean predicate will not match.
+
`filter` clauses are ignored during <<search-dsl-predicate-common-score,score>> computation,
and so are any clauses of boolean predicates contained in the filter clause (even `must` or `should` clauses).
[[search-dsl-predicate-boolean-clauses-should]]`should`::
`should` clauses may optionally match, and are required to match depending on the context.
+
Matching `should` clauses are taken into account during <<search-dsl-predicate-common-score,score>> computation.
+
The exact behavior of `should` clauses is as follows:
+
* When there isn't any `must` clause nor any `filter` clause in the `bool` predicate
then at least one "should" clause is required to match.
Simply put, in this case, the "should" clauses
behave as if there was an `OR` operator between each of them.
* When there is at least one `must` clause or one `filter` clause in the `bool` predicate,
then the "should" clauses are not required to match,
and are simply used for scoring.
* This behavior can be changed by specifying
<<search-dsl-predicate-boolean-minimumshouldmatch,`minimumShouldMatch` constraints>>.

[[search-dsl-predicate-boolean-or]]
=== Emulating an `OR` operator

A `bool` predicate with only `should` clauses and no <<search-dsl-predicate-boolean-minimumshouldmatch,`minimumShouldMatch` specification>> will behave as an `OR` operator.
In such case, using the simpler <<search-dsl-predicate-or,`or`>> syntax is recommended.

[[search-dsl-predicate-boolean-and]]
=== Emulating an `AND` operator

A `bool` predicate with only `must` clauses will behave as an `AND` operator.
In such case, using the simpler <<search-dsl-predicate-and,`and`>> syntax is recommended.

[[search-dsl-predicate-boolean-mustNot]]
=== `mustNot`: excluding documents that match a given predicate

.Matching a document that does *not* match a given predicate
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=bool-mustNot]
----
<1> The hits *must* have a `title` field matching the text `robot`,
independently of other clauses in the same boolean predicate.
<2> The hits *must not* have a `description` field matching the text `investigation`,
independently of other clauses in the same boolean predicate.
<3> All returned hits will match *all* the clauses above:
they will have a `title` field matching the text `robot`
*and* they will not have a `description` field matching the text `investigation`.

[NOTE]
======
While it is possible to execute a boolean predicate with only "negative" clauses (`mustNot`),
performance may be disappointing because the full power of indexes cannot be leveraged in that case.
======
====

[[search-dsl-predicate-boolean-filter]]
=== `filter`: matching documents that match a given predicate without affecting the score

`filter` clauses are essentially `must` clauses with only one difference:
they are ignored when computing the total <<search-dsl-predicate-common-score,score>> of a document.

.Matching a document that matches a given predicate without affecting the score
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=bool-filter]
----
<1> Create a top-level boolean predicate, with two `should` clauses.
<2> In the first `should` clause, create a nested boolean predicate.
<3> Use a `filter` clause to require documents to have the `science-fiction` genre,
without taking this predicate into account when scoring.
<4> Use a `must` clause to require documents with the `science-fiction` genre
to have a `title` field matching `crime`,
and take this predicate into account when scoring.
<5> In the second `should` clause, create a nested boolean predicate.
<6> Use a `filter` clause to require documents to have the `crime fiction` genre,
without taking this predicate into account when scoring.
<7> Use a `must` clause to require documents with the `crime fiction` genre
to have a `description` field matching `robot`,
and take this predicate into account when scoring.
<8> The score of hits will ignore the `filter` clauses,
leading to fairer sorts if there are much more "crime fiction" documents than "science-fiction" documents.
====

[[search-dsl-predicate-boolean-should-scoring]]
=== `should` as a way to tune scoring

Apart from being <<search-dsl-predicate-boolean-or,used alone to emulate an `OR` operator>>,
`should` clauses can also be used in conjunction with `must` clauses.
When doing so, the `should` clauses become completely optional,
and their only purpose is to increase the score of documents that match these clauses.

.Using optional `should` clauses to boost the score of some documents
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=bool-mustAndShould]
----
<1> The hits *must* have a `title` field matching the text `robot`,
independently of other clauses in the same boolean predicate.
<2> The hits *should* have a `description` field matching the text `crime`,
but they might not, because matching the `must` clause above is enough.
However, matching this `should` clause will improve the score of the document.
<3> The hits *should* have a `description` field matching the text `investigation`,
but they might not, because matching the `must` clause above is enough.
However, matching this `should` clause will improve the score of the document.
<4> All returned hits will match the `must` clause, and optionally the `should` clauses:
they will have a `title` field matching the text `robot`,
and the ones whose description matches either `crime` or `investigation` will have a better score.
====

[[search-dsl-predicate-boolean-minimumshouldmatch]]
=== `minimumShouldMatch`: fine-tuning how many `should` clauses are required to match

It is possible to require that an arbitrary number of `should` clauses match
in order for the `bool` predicate to match.
This is the purpose of the `minimumShouldMatch*` methods,
as demonstrated below.

.Fine-tuning `should` clauses matching requirements with `minimumShouldMatch`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=bool-minimumShouldMatchNumber]
----
<1> At least two "should" clauses must match for this boolean predicate to match.
<2> The hits *should* have a `description` field matching the text `robot`.
<3> The hits *should* have a `description` field matching the text `investigate`.
<4> The hits *should* have a `description` field matching the text `crime`.
<5> All returned hits will match at least two of the `should` clauses:
their description will match either `robot` and `investigate`,
`robot` and `crime`, `investigate` and `crime`, or all three of these terms.
====

[[search-dsl-predicate-boolean-lambda]]
=== Adding clauses dynamically with the lambda syntax

It is possible to define the `bool` predicate inside a lambda expression.
This is especially useful when clauses need to be added dynamically to the `bool` predicate,
for example based on user input.

TIP: If you simply want to build a root predicate matching multiple, dynamically generated clauses,
consider using the <<search-dsl-predicate-and-lambda,`.where( (f, root) -> ... )` syntax>> instead.

.Easily adding clauses dynamically using `with(...)` and the lambda syntax
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=bool-dynamicParameters-with]
----
<1> Get a custom object holding the search parameters provided by the user through a web form, for example.
<2> Call `.where(BiConsumer)` to create the root predicate, which is not the one we're interested in here.
<3> Call `.bool().with(Consumer)` to create an inner, non-root predicate.
The consumer, implemented by a lambda expression, will receive a collector as an argument
and will add clauses to that collector as necessary.
<4> Inside the lambda, the code is free to use any Java language constructs, such as `if` or `for`,
to control the addition of clauses.
In this case, we add one clause per author filter.
====

[[search-dsl-predicate-boolean-deprecated-variants]]
=== Deprecated variants

include::components/deprecated-warning.asciidoc[]

Another syntax can be used to <<search-dsl-predicate-boolean-lambda,create a boolean predicate from a lambda expression>>,
but it is deprecated.

.Deprecated variant of `.bool`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=bool-dynamicParameters-deprecated]
----
<1> Get a custom object holding the search parameters provided by the user through a web form, for example.
<2> Call `.bool(Consumer)`.
The consumer, implemented by a lambda expression, will receive a collector as an argument
and will add clauses to that collector as necessary.
<3> By default, a boolean predicate will match nothing if there is no clause.
To match every document when there is no clause, add a `must` clause that matches everything.
<4> Inside the lambda, the code is free to use any Java language constructs, such as `if` or `for`,
to control the addition of clauses.
In this case, we only add clauses if the relevant parameter was filled in by the user.
====

[[search-dsl-predicate-boolean-other]]
=== Other options

* The score of a `bool` predicate is variable by default,
but can be <<search-dsl-predicate-common-constantScore,made constant with `.constantScore()`>>.
* The score of a `bool` predicate can be <<search-dsl-predicate-common-boost,boosted>>
with a call to `.boost(...)`.

[[search-dsl-predicate-simple-query-string]]
== [[_simple_query_string_queries]] `simpleQueryString`: match a user-provided query string

The `simpleQueryString` predicate matches documents according to a structured query given as a string.

Its syntax is quite simple, so it's especially helpful when end user expect to be able to submit text queries
with a few syntax elements such as boolean operators, quotes, etc.

[[search-dsl-predicate-simple-query-string-boolean-operators]]
=== Boolean operators

The syntax includes three boolean operators:

* AND using `+`
* OR using `|`
* NOT using `-`

.Matching a simple query string: AND/OR operators
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=simpleQueryString-boolean]
----
====

.Matching a simple query string: NOT operator
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=simpleQueryString-not]
----
====

[[search-dsl-predicate-simple-query-string-boolean-operators-default]]
=== Default boolean operator

By default, the query uses the OR operator if the operator is not explicitly defined.
If you prefer using the AND operator as default,
you can call `.defaultOperator(...)`.

.Matching a simple query string: AND as default operator
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=simpleQueryString-defaultOperator-and]
----
====

[[search-dsl-predicate-simple-query-string-prefix]]
=== Prefix

The syntax includes support for prefix predicates through the `*` wildcard.

.Matching a simple query string: prefix
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=simpleQueryString-prefix]
----
====

NOTE: The `*` wildcard will only be understood at the end of a word.
`rob*t` will be interpreted as a literal.
This really is a _prefix_ predicate, not a <<search-dsl-predicate-wildcard,_wildcard_ predicate>>.

[[search-dsl-predicate-simple-query-string-fuzzy]]
=== Fuzzy

The syntax includes support for the fuzzy operator `~`.
Its behavior is similar to that of <<search-dsl-predicate-match-fuzzy,fuzzy matching in the `match` predicate>>.

.Matching a simple query string: fuzzy
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=simpleQueryString-fuzzy]
----
====

[[search-dsl-predicate-simple-query-string-phrase]]
=== Phrase

The syntax includes support for <<search-dsl-predicate-phrase,`phrase` predicates>>
using quotes around the sequence of terms to match.

.Matching a simple query string: phrase
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=simpleQueryString-phrase]
----
====

A <<search-dsl-predicate-phrase-slop,slop>> can be assigned to a phrase predicate
using the NEAR operator `~`.

.Matching a simple query string: phrase with slop
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=simpleQueryString-phrase-slop]
----
====

[[search-dsl-predicate-simple-query-string-flags]]
=== `flags`: enabling only specific syntax constructs

By default, all syntax features are enabled.
You can pick the operators to enable explicitly through the `.flags(...)` method.

.Matching a simple query string: enabling only specific syntax constructs
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=simpleQueryString-flags]
----
====

If you wish, you can disable all syntax constructs:

.Matching a simple query string: disabling all syntax constructs
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=simpleQueryString-flags-none]
----
====

[[search-dsl-predicate-simpleQueryString-multiple-fields]]
=== Targeting multiple fields

Optionally, the predicate can target multiple fields.
In that case, the predicate will match documents for which _any_ of the given fields matches.

See <<search-dsl-predicate-common-multiple-fields>>.

IMPORTANT: If targeted fields have different analyzers, an exception will be thrown.
You can avoid this by <<search-dsl-predicate-common-overriding-analysis,picking an analyzer explicitly>>,
but make sure you know what you're doing.

[[search-dsl-predicate-simpleQueryString-other]]
=== Other options

* The score of a `simpleQueryString` predicate is variable by default,
but can be <<search-dsl-predicate-common-constantScore,made constant with `.constantScore()`>>.
* The score of a `simpleQueryString` predicate can be <<search-dsl-predicate-common-boost,boosted>>,
either on a per-field basis with a call to `.boost(...)` just after `.field(...)`/`.fields(...)`
or for the whole predicate with a call to `.boost(...)` after `.matching(...)`.
* The `simpleQueryString` predicate uses the <<mapping-directfieldmapping-search-analyzer,search analyzer>>
of targeted fields to analyze searched text by default,
but this can be <<search-dsl-predicate-common-overriding-analysis,overridden>>.

[[search-dsl-predicate-nested]]
== `nested`: match nested documents

The `nested` predicate can be used on object fields <<mapping-indexedembedded-structure,indexed as nested documents>>
to require two or more inner predicates to match _the same object_.
This is how you ensure that `authors.firstname:isaac AND authors.lastname:asimov`
will not match a book whose authors are "Jane Asimov" and "Isaac Deutscher".

.Matching multiple predicates against a single nested object
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=nested]
----
<1> Create a nested predicate on the `authors` object field.
<2> The author must have a first name matching `isaac`.
<3> The author must have a last name matching `asimov`.
<4> All returned hits will be books for which at least one author
has a first name matching `isaac` and a last name matching `asimov`.
Books that happen to have multiple authors,
one of which has a first name matching `isaac`
and *another* of which has a last name matching `asimov`,
will *not* match.
====

[[search-dsl-predicate-nested-implicit]]
=== [[_implicit_nesting]] Implicit nesting

Hibernate Search automatically wraps a nested predicate around other predicates when necessary.
However, this is done for each single predicate,
so implicit nesting will not give the same behavior as explicit nesting grouping multiple inner predicates.
See below for an example.

[[search-dsl-predicate-nested-implicit-example]]
.Using implicit nesting
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=nested-implicit-form]
----
<1> The nested predicate is created implicitly, since target fields here belong to a nested object.
<2> The author must have a first name matching `isaac`.
<3> The author must have a last name matching `asimov`.
<4> All returned hits will be books for which at least one author
has a first name matching `isaac` and a last name matching `asimov`.
Books that happen to have multiple authors,
one of which has a first name matching `isaac`
and *another* of which has a last name matching `asimov`,
will match, because we apply the nested predicate *separately* to *each match* predicate.
====

[[search-dsl-predicate-nested-deprecated-variants]]
=== Deprecated variants

include::components/deprecated-warning.asciidoc[]

Another syntax can be used to create a nested predicate,
but it is more verbose and deprecated.

.Deprecated variant of `.nested`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=nested-deprecated]
----
<1> Create a nested predicate on the `authors` object field.
<2> The author must have a first name matching `isaac`.
<3> The author must have a last name matching `asimov`.
<4> All returned hits will be books for which at least one author
has a first name matching `isaac` and a last name matching `asimov`.
Books that happen to have multiple authors,
one of which has a first name matching `isaac`
and *another* of which has a last name matching `asimov`,
will *not* match.
====

[[search-dsl-predicate-spatial-within]]
== [[spatial-queries]] `within`: match points within a circle, box, polygon

The `within` predicate matches documents for which a given field is a geo-point
contained within a given circle, bounding-box or polygon.

NOTE: This predicate is only available on <<mapping-geopoint,geo-point fields>>.

[[search-dsl-predicate-spatial-within-circle]]
=== Matching points within a circle (within a distance to a point)

With `.circle(...)`, the matched points must be within a given distance from a given point (center).

.Matching points within a circle
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=within-circle]
----
====

NOTE: Other distance units are available, in particular `METERS`, `YARDS` and `MILES`.
When the distance unit is omitted, it defaults to `METERS`.

You can also pass the coordinates of the center as two doubles (latitude, then longitude).

.Matching points within a circle: passing center coordinates as doubles
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=within-circle-doubles]
----
====

[[search-dsl-predicate-spatial-within-bounding-box]]
=== Matching points within a bounding box

With `.boundingBox(...)`, the matched points must be within a given bounding box
defined by its top-left and bottom-right corners.

.Matching points within a box
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=within-box]
----
====

You can also pass the coordinates of the top-left and bottom-right corners as four doubles:
top-left latitude, top-left longitude, bottom-right latitude, bottom-right longitude.

.Matching points within a box: passing corner coordinates as doubles
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=within-box-doubles]
----
====

[[search-dsl-predicate-spatial-within-polygon]]
=== Matching points within a polygon

With `.polygon(...)`, the matched points must be within a given polygon.

.Matching points within a polygon
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=within-polygon]
----
====

[[search-dsl-predicate-spatial-within-multiple-fields]]
=== Targeting multiple fields

Optionally, the predicate can target multiple fields.
In that case, the predicate will match documents for which _any_ of the given fields matches.

See <<search-dsl-predicate-common-multiple-fields>>.

[[search-dsl-predicate-spatial-within-other]]
=== Other options

* The score of a `within` predicate is constant and equal to 1 by default,
but can be <<search-dsl-predicate-common-boost,boosted>>,
either on a per-field basis with a call to `.boost(...)` just after `.field(...)`/`.fields(...)`
or for the whole predicate with a call to `.boost(...)`
after `.circle(...)`/`.boundingBox(...)`/`.polygon(...)`.


[[search-dsl-predicate-named]]
== [[query-filter-fulltext]] `named`: call a predicate defined in the mapping

A `named` predicate, i.e. a predicate defined in the mapping,
can be called and included in a query.

Below is an example that calls the named predicate
from the example of section <<bridge-named-predicate>>.

.Calling a named predicate
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/mapper/orm/bridge/namedpredicate/NamedPredicateIT.java[tags=named-predicate]
----
<1> The named predicate is referred to by its name,
prefixed with the path of the object where the predicate was defined and a dot.
+
Here, the predicate is named `skuIdMatch` and was defined on an object field named `skuId`.
For named predicates defined at the root of the index,
you can pass the predicate name directly, without any prefix.
<2> Named predicates can accept parameters,
which will be handled as explained in <<bridge-named-predicate>>.
====

[[search-dsl-predicate-extensions]]
== Backend-specific extensions

By calling `.extension(...)` while building a query,
it is possible to access backend-specific predicates.

[NOTE]
====
As their name suggests, backend-specific predicates are not portable from one backend technology to the other.
====

[[search-dsl-predicate-extensions-lucene-from-lucene-query]]
=== Lucene: `fromLuceneQuery`

`.fromLuceneQuery(...)` turns a native Lucene `Query` into a Hibernate Search predicate.

include::components/lucene-api-warning.asciidoc[]

.Matching a native `org.apache.lucene.search.Query`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/LucenePredicateDslIT.java[tags=lucene-fromLuceneQuery]
----
<1> Build the query as usual,
but using the Lucene extension so that Lucene-specific options are available.
<2> Add a predicate defined by a given Lucene `Query` object.
====

[[search-dsl-predicate-extensions-elasticsearch-from-json]]
=== Elasticsearch: `fromJson`

`.fromJson(...)` turns JSON representing an Elasticsearch query into a Hibernate Search predicate.

include::components/elasticsearch-json-warning.asciidoc[]

.Matching a native Elasticsearch JSON query provided as a `JsonObject`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/ElasticsearchPredicateDslIT.java[tags=elasticsearch-fromJson-jsonObject]
----
<1> Build a JSON object using link:{gsonUrl}[Gson].
<2> Build the query as usual,
but using the Lucene extension so that Lucene-specific options are available.
<3> Add a predicate defined by a given `JsonObject`.
====

.Matching a native Elasticsearch JSON query provided as a JSON-formatted string
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/ElasticsearchPredicateDslIT.java[tags=elasticsearch-fromJson-string]
----
<1> Build the query as usual,
but using the Lucene extension so that Lucene-specific options are available.
<2> Add a predicate defined by a given JSON-formatted string.
====

[[search-dsl-predicate-common]]
== [[_query_options]] Options common to multiple predicate types

[[search-dsl-predicate-common-multiple-fields]]
=== Targeting multiple fields in one predicate

Some predicates offer the ability to target multiple fields in the same predicate.

In that case, the predicate will match documents for which _any_ of the given fields matches.

Below is an example with the <<search-dsl-predicate-match,`match` predicate>>.

.Matching a value in any of multiple fields
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=multipleFields-fieldOrField]
----
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=multipleFields-fields]
----
====

It is possible to boost the score of each field separately;
see <<search-dsl-predicate-common-boost>>.

[[search-dsl-predicate-common-score]]
=== Tuning the score

Each predicate yields a score if it matched the document.
The more relevant a document for a given predicate, the higher the score.

That score can be used when <<search-dsl-sort-score,sorting by score>> (which is the default)
to get more relevant hits at the top of the result list.

Below are a few ways to tune the score, and thus to get the most of the relevance sort.

[[search-dsl-predicate-common-boost]]
==== Boosting the score of a predicate

The score of each predicate may be assigned a multiplier, called a _boost_:

* if a given predicate is more relevant to your search query than other predicates,
assigning it a <<search-dsl-predicate-common-boost,boost>> (multiplier) higher than 1
will increase its impact on the total document score.
* if a given predicate is less relevant to your search query than other predicates,
assigning it a <<search-dsl-predicate-common-boost,boost>> (multiplier) lower than 1
will decrease its impact on the total document score.

NOTE: The boost should always be higher than 0.

Below is an example with the <<search-dsl-predicate-match,`match` predicate>>.

.Boosting on a per-predicate basis
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=score-boost]
----
====

For predicates targeting multiple fields,
it is also possible to assign more importance to matches on a given field (or set of fields)
by calling `.boost(...)` after the call to `.field(...)`/`.fields(...)`.

Below is an example with the <<search-dsl-predicate-match,`match` predicate>>.

.Boosting on a per-field basis
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=score-boost-multipleFields]
----
====

[[search-dsl-predicate-common-constantScore]]
==== Variable and constant score

Some predicates already have a constant score by default, because a variable score doesn't make sense for them.
For example, the <<search-dsl-predicate-id,`id` predicate>> has a constant score by default.

Predicates with a constant score have an "all-or-nothing" impact on the total document score:
either a document matches and it will benefit from the score of this predicate
(`1.0f` by default, but it can be <<search-dsl-predicate-common-boost,boosted>>),
or it doesn't match and it won't benefit from the score of this predicate.

Predicates with a variable score have a more subtle impact on the score.
For example the <<search-dsl-predicate-match,`match` predicate>>, on a text field,
will yield a higher score for documents that contain the term to match multiple times.

When this "variable score" behavior is not desired,
you can suppress it by calling `.constantScore()`.
This may be useful if only the fact that the predicate matched is relevant,
but not the content of the document.

Below is an example with the <<search-dsl-predicate-match,`match` predicate>>.

.Making the score of a predicate constant
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=score-constantScore]
----
====

TIP: Alternatively, you can take advantage of
the <<search-dsl-predicate-boolean-filter,filter>> clause in boolean predicates,
which is equivalent to a `must` clause but completely suppresses the impact of the clause on the score.

[[search-dsl-predicate-common-overriding-analysis]]
=== Overriding analysis

In some cases it might be necessary to use a different analyzer to analyze searched text
than the one used to analyze indexed text.

This can be achieved by calling `.analyzer(...)` and passing the name of the analyzer to use.

Below is an example with the <<search-dsl-predicate-match,`match` predicate>>.

TIP: If you always apply the same analyzer when searching,
you might want to configure a <<mapping-directfieldmapping-search-analyzer,search analyzer>>
on your field instead. Then you won't need to use `.analyzer(...)` when searching.

.Matching a value, analyzing it with a different analyzer
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=overrideAnalysis-analyzer]
----
====

If you need to disable analysis of searched text completely,
call `.skipAnalysis()`.

.Matching a value without analyzing it
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedir}/org/hibernate/search/documentation/search/predicate/PredicateDslIT.java[tags=overrideAnalysis-skipAnalysis]
----
====
