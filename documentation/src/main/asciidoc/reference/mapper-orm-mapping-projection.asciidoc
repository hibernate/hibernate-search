[[mapper-orm-mapping-projection]]
= Mapping index content to custom types (projection constructors)

[[mapper-orm-mapping-projection-basics]]
== Basics

<<search-dsl-projection,Projections>> allow retrieving data directly from matched documents
as the result of a search query.
As the structure of documents and projections becomes more complex,
so do <<search-dsl-projection-concepts,programmatic calls to the Projection DSL>>,
which can lead to overwhelming projection definitions.

To address this, Hibernate Search offers the ability to define projections through the mapping of custom types
(typically records), by applying the `@ProjectionConstructor` annotation to those types or their constructor.
Executing such a projection then becomes as easy as <<search-dsl-projection-mapped,referencing the custom type>>.

Such projections are <<search-dsl-projection-composite,composite>>,
their inner projections (components) being
<<mapper-orm-mapping-projection-inner-inference,inferred from the name and type of the projection constructors' parameters>>.

include::components/custom-projection-type-important.asciidoc[]

.Using a custom record type to project data from the index
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedirJava17}/org/hibernate/search/documentation/mapper/orm/projection/MyBookProjection.java[tags=include]
----
<1> Annotate the record type with `@ProjectionConstructor`,
either at the type level (if there's only one constructor)
or at the constructor level (if there are multiple constructors).
<2> To project on a value field, add a constructor parameter named after that field and with the same type as that field.
See <<mapper-orm-mapping-projection-inner-inference>> for more information on how constructor parameters should be defined.
<3> To project on an object field, add a constructor parameter named after that field and with its own custom projection type.
Multivalued projections <<mapper-orm-mapping-projection-inner-inference-type,must be modeled as a `List<...>`>> or supertype.
<4> Annotate any custom projection type used for object fields with `@ProjectionConstructor` as well.

[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedirJava17}/org/hibernate/search/documentation/mapper/orm/projection/ProjectionConstructorMappingJava17IT.java[tags=projection-mapped]
----
<1> Pass the custom projection type to `.select(...)`.
<2> Each hit will be an instance of the custom projection type,
populated with data retrieved from the index.
====

include::components/custom-projection-type-nonrecord-tip.asciidoc[]

The example above executes a projection equivalent to the following code:

.Programmatic projection definition equivalent to the previous example
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedirJava17}/org/hibernate/search/documentation/mapper/orm/projection/ProjectionConstructorMappingJava17IT.java[tags=projection-programmatic]
----
====

[[mapper-orm-mapping-projection-type-detection]]
== Detection of mapped projection types

Hibernate Search must know of projection types on startup,
which it generally does as soon as they are annotated with `@ProjectionConstructor`,
thanks to classpath scanning.

For more information about classpath scanning and how to tune it
(for example to scan dependencies instead of just the application JAR),
see <<mapper-orm-mapping-configuration-scanning>>.

[[mapper-orm-mapping-projection-inner-inference]]
== Inner projection inference

[[mapper-orm-mapping-projection-inner-inference-basics]]
=== Basics

In order to interpret constructor parameters as (inner) projections,
Hibernate Search applies some basic inference rules based on the name and type of those parameters.

The following sections explain how to define the name and type of constructor parameters
to get the desired projection.

[[mapper-orm-mapping-projection-inner-inference-type]]
=== Inner projection and type

Hibernate Search infers the type of the inner projection from the type of the corresponding constructor parameter.

You should set the type of a constructor parameter according to the following rules:

* For a single-valued projection:
  * For a <<search-dsl-projection-field,projection on a value field>>
    (generally mapped using <<mapper-orm-directfieldmapping-annotations-fulltextfield,`@FullTextField`>>/<<mapper-orm-geopoint-genericfield,`@GenericField`>>/etc.),
    set the parameter type to the <<search-dsl-projected-value-type,type of projected values>>
    for the target field, which in general is the type of the property annotated with `@FullTextField`/`@GenericField`/etc.
  * For a <<search-dsl-projection-object,projection on an object field>>
    (generally mapped using <<mapper-orm-indexedembedded,`@IndexedEmbedded`>>),
    set the parameter type to another custom type annotated with `@ProjectionConstructor`,
    whose constructor will define which fields to extract from that object field.
* For a multivalued projection, follow the rules above then wrap the type with `Iterable`, `Collection` or `List`,
  e.g. `Iterable<SometType>`, `Collection<SomeType>` or `List<SomeType>`.

[IMPORTANT]
====
Constructor parameters meant to represent a multivalued projection
can **only** have the type `Iterable<...>`, `Collection<...>` or `List<...>`.

Other container types such as `Map` or `Optional` are not supported
https://hibernate.atlassian.net/browse/HSEARCH-4577[at the moment].
====

[[mapper-orm-mapping-projection-inner-inference-fieldpath]]
=== Inner projection and field path

Hibernate Search infers the path of the field to project on from the name of the corresponding constructor parameter.

You should set the name of a constructor parameter (in the Java code) to the name of the field to project on,
and make sure to compile your code with the `-parameters` compiler flag.

[WARNING]
====
Projection types compiled without the `-parameters` compiler flag
will lead to exceptions on startup https://hibernate.atlassian.net/browse/HSEARCH-4574[at the moment].
====

[[mapper-orm-mapping-projection-multiple-constructors]]
== Mapping types with multiple constructors

If the projection type (record or class) has multiple constructors,
the `@ProjectionConstructor` annotation cannot be applied at the type level
and must be applied to the constructor you wish to use for projections.

.Annotating a specific constructor with `@ProjectionConstructor`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedirJava17}/org/hibernate/search/documentation/mapper/orm/projection/MyAuthorProjectionClassMultiConstructor.java[tags=include]
----
<1> Annotate the constructor to use for projections with `@ProjectionConstructor`.
<2> Other constructors can be used for other purposes than projections,
but they **must not** be annotated with `@ProjectionConstructor` (only one such constructor is allowed).
====

In the case of records, the (implicit) canonical constructor can also be annotated,
but it requires representing that constructor in the code with a specific syntax:

.Annotating the canonical constructor with `@ProjectionConstructor`
====
[source, JAVA, indent=0, subs="+callouts"]
----
include::{sourcedirJava17}/org/hibernate/search/documentation/mapper/orm/projection/MyAuthorProjectionRecordMultiConstructor.java[tags=include]
----
<1> Annotate the constructor to use for projections with `@ProjectionConstructor`.
<2> The (implicit) canonical constructor uses a specific syntax, without parentheses or parameters.
<3> Other constructors can be used for other purposes than projections,
but they **must not** be annotated with `@ProjectionConstructor` (only one such constructor is allowed).
====

[[mapper-orm-mapping-projection-programmatic]]
== Programmatic mapping

You can map projection constructors through the <<mapper-orm-programmatic-mapping,programmatic mapping>> too.
Behavior and options are identical to annotation-based mapping.

.Mapping the main projection constructor with `.projectionConstructor()`
====
[source, JAVA, indent=0]
----
include::{sourcedirJava17}/org/hibernate/search/documentation/mapper/orm/projection/ProjectionConstructorMappingJava17IT.java[tags=programmatic-mainConstructor]
----
====

If the projection type (record or class) has multiple constructors,
you will need to use `.constructor(...)` instead of `.mainConstructor()`,
passing the (raw) type of the constructor parameters as arguments.

.Mapping a specific projection constructor with `.projectionConstructor()`
====
[source, JAVA, indent=0]
----
include::{sourcedirJava17}/org/hibernate/search/documentation/mapper/orm/projection/ProjectionConstructorMappingJava17IT.java[tags=programmatic-constructor]
----
====
