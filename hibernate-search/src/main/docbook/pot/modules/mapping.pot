# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2011-09-17 19:35+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: mapping.xml:31
#, no-c-format
msgid "Mapping entities to the index structure"
msgstr ""

#. Tag: title
#: mapping.xml:34
#, no-c-format
msgid "Mapping an entity"
msgstr ""

#. Tag: para
#: mapping.xml:36
#, no-c-format
msgid "In <xref linkend=\"getting-started\"/> you have already learned that all the metadata information needed to index entities is described through annotations. There is no need for xml mapping files. You can still use Hibernate mapping files for the basic Hibernate configuration, but the Hibernate Search specific configuration has to be expressed via annotations."
msgstr ""

#. Tag: para
#: mapping.xml:44
#, no-c-format
msgid "There is no XML configuration available for Hibernate Search but we provide a powerful programmatic mapping API that elegantly replaces this kind of deployment form (see <xref linkend=\"hsearch-mapping-programmaticapi\"/> for more information)."
msgstr ""

#. Tag: para
#: mapping.xml:50
#, no-c-format
msgid "If you want to contribute the XML mapping implementation, see <ulink url=\"https://hibernate.onjira.com/browse/HSEARCH-210\">HSEARCH-210</ulink>."
msgstr ""

#. Tag: title
#: mapping.xml:56
#, no-c-format
msgid "Basic mapping"
msgstr ""

#. Tag: para
#: mapping.xml:58
#, no-c-format
msgid "Lets start with the most commonly used annotations for mapping an entity."
msgstr ""

#. Tag: title
#: mapping.xml:62
#, no-c-format
msgid "@Indexed"
msgstr ""

#. Tag: para
#: mapping.xml:64
#, no-c-format
msgid "Foremost we must declare a persistent class as indexable. This is done by annotating the class with <literal>@Indexed</literal> (all entities not annotated with <literal>@Indexed</literal> will be ignored by the indexing process):"
msgstr ""

#. Tag: title
#: mapping.xml:70
#, no-c-format
msgid "Making a class indexable with <classname>@Indexed</classname>"
msgstr ""

#. Tag: programlisting
#: mapping.xml:73
#, no-c-format
msgid ""
      "@Entity\n"
      "<emphasis role=\"bold\">@Indexed</emphasis>\n"
      "public class Essay {\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: para
#: mapping.xml:76
#, no-c-format
msgid "You can optionially specify the <literal>index</literal> attribute of the @Indexed annotation to change the default name of the index. For more information see <xref linkend=\"search-configuration-directory\"/>."
msgstr ""

#. Tag: title
#: mapping.xml:83
#, no-c-format
msgid "@Field"
msgstr ""

#. Tag: para
#: mapping.xml:85
#, no-c-format
msgid "For each property (or attribute) of your entity, you have the ability to describe how it will be indexed. The default (no annotation present) means that the property is ignored by the indexing process. <literal>@Field</literal> does declare a property as indexed and allows to configure several aspects of the indexing process by setting one or more of the following attributes:"
msgstr ""

#. Tag: para
#: mapping.xml:94
#, no-c-format
msgid "<literal>name</literal> : describe under which name, the property should be stored in the Lucene Document. The default value is the property name (following the JavaBeans convention)"
msgstr ""

#. Tag: para
#: mapping.xml:101
#, no-c-format
msgid "<literal>store</literal> : describe whether or not the property is stored in the Lucene index. You can store the value <literal>Store.YES</literal> (consuming more space in the index but allowing projection, see <xref linkend=\"projections\"/>), store it in a compressed way <literal>Store.COMPRESS</literal> (this does consume more CPU), or avoid any storage <literal>Store.NO</literal> (this is the default value). When a property is stored, you can retrieve its original value from the Lucene Document. This is not related to whether the element is indexed or not."
msgstr ""

#. Tag: para
#: mapping.xml:114
#, no-c-format
msgid "index: describe whether the property is indexed or not. The different values are <literal>Index.NO</literal> (no indexing, ie cannot be found by a query), <literal>Index.YES</literal> (the element gets indexed and is searchable). The default value is <literal>Index.YES</literal>. <literal>Index.NO</literal> can be useful for cases where a property does is not required to be searchable, but should be available for projection."
msgstr ""

#. Tag: para
#: mapping.xml:123
#, no-c-format
msgid "<literal>Index.NO</literal> in combination with <literal>Analyze.YES</literal> or <literal>Norms.YES</literal> is not useful, since <literal>analyze</literal> and <literal>norms</literal> require the property to be indexed"
msgstr ""

#. Tag: para
#: mapping.xml:132
#, no-c-format
msgid "analyze: determines whether the property is analyzed (<literal>Analyze.YES</literal>) or not (<literal>Analyze.NO</literal>). The default value is <literal>Analyze.YES</literal>."
msgstr ""

#. Tag: para
#: mapping.xml:136
#, no-c-format
msgid "Whether or not you want to analyze a property depends on whether you wish to search the element as is, or by the words it contains. It make sense to analyze a text field, but probably not a date field."
msgstr ""

#. Tag: para
#: mapping.xml:141
#, no-c-format
msgid "Fields used for sorting <emphasis>must not</emphasis> be analyzed."
msgstr ""

#. Tag: para
#: mapping.xml:147
#, no-c-format
msgid "norms: describes whether index time boosting information should be stored (<literal>Norms.YES</literal>) or not (<literal>Norms.NO</literal>). Not storing it can save a considerable amount of memory, but there won't be any index time boosting information available. The default value is <literal>Norms.YES</literal>."
msgstr ""

#. Tag: para
#: mapping.xml:156
#, no-c-format
msgid "termVector: describes collections of term-frequency pairs. This attribute enables the storing of the term vectors within the documents during indexing. The default value is <literal>TermVector.NO</literal>."
msgstr ""

#. Tag: para
#: mapping.xml:161
#, no-c-format
msgid "The different values of this attribute are:"
msgstr ""

#. Tag: entry
#: mapping.xml:167 mapping.xml:271
#, no-c-format
msgid "Value"
msgstr ""

#. Tag: entry
#: mapping.xml:169 mapping.xml:273
#, no-c-format
msgid "Definition"
msgstr ""

#. Tag: entry
#: mapping.xml:175
#, no-c-format
msgid "TermVector.YES"
msgstr ""

#. Tag: entry
#: mapping.xml:177
#, no-c-format
msgid "Store the term vectors of each document. This produces two synchronized arrays, one contains document terms and the other contains the term's frequency."
msgstr ""

#. Tag: entry
#: mapping.xml:183
#, no-c-format
msgid "TermVector.NO"
msgstr ""

#. Tag: entry
#: mapping.xml:185
#, no-c-format
msgid "Do not store term vectors."
msgstr ""

#. Tag: entry
#: mapping.xml:189
#, no-c-format
msgid "TermVector.WITH_OFFSETS"
msgstr ""

#. Tag: entry
#: mapping.xml:191
#, no-c-format
msgid "Store the term vector and token offset information. This is the same as TermVector.YES plus it contains the starting and ending offset position information for the terms."
msgstr ""

#. Tag: entry
#: mapping.xml:198
#, no-c-format
msgid "TermVector.WITH_POSITIONS"
msgstr ""

#. Tag: entry
#: mapping.xml:200
#, no-c-format
msgid "Store the term vector and token position information. This is the same as TermVector.YES plus it contains the ordinal positions of each occurrence of a term in a document."
msgstr ""

#. Tag: entry
#: mapping.xml:208
#, no-c-format
msgid "TermVector.WITH_POSITION_OFFSETS"
msgstr ""

#. Tag: entry
#: mapping.xml:210
#, no-c-format
msgid "Store the term vector, token position and offset information. This is a combination of the YES, WITH_OFFSETS and WITH_POSITIONS."
msgstr ""

#. Tag: para
#: mapping.xml:220
#, no-c-format
msgid "<literal>indexNullAs</literal> : Per default null values are ignored and not indexed. However, using <parameter>indexNullAs</parameter> you can specify a string which will be inserted as token for the <constant>null</constant> value. Per default this value is set to <constant>Field.DO_NOT_INDEX_NULL</constant> indicating that <constant>null</constant> values should not be indexed. You can set this value to <constant>Field.DEFAULT_NULL_TOKEN </constant>to indicate that a default <constant>null</constant> token should be used. This default <constant>null</constant> token can be specified in the configuration using <literal>hibernate.search.default_null_token</literal>. If this property is not set and you specify <constant>Field.DEFAULT_NULL_TOKEN</constant> the string \"_null_\" will be used as default."
msgstr ""

#. Tag: para
#: mapping.xml:235
#, no-c-format
msgid "When the <parameter>indexNullAs</parameter> parameter is used it is important to use the same token in the search query (see <xref linkend=\"search-query\"/>) to search for <constant>null</constant> values. It is also advisable to use this feature only with un-analyzed fields (<literal><literal>analyze=</literal>Analyze.NO</literal>)."
msgstr ""

#. Tag: para
#: mapping.xml:242
#, no-c-format
msgid "When implementing a custom <classname>FieldBridge</classname> or <classname>TwoWayFieldBridge</classname> it is up to the developer to handle the indexing of null values (see JavaDocs of <methodname>LuceneOptions.indexNullAs()</methodname>)."
msgstr ""

#. Tag: title
#: mapping.xml:254
#, no-c-format
msgid "@NumericField"
msgstr ""

#. Tag: para
#: mapping.xml:256
#, no-c-format
msgid "There is a companion annotation to <classname>@Field</classname> called <classname>@NumericField</classname> that can be specified in the same scope as <classname>@Field</classname> or <classname>@DocumentId</classname>. It can be specified for Integer, Long, Float and Double properties. At index time the value will be indexed using a <ulink url=\"http://en.wikipedia.org/wiki/Trie\">Trie structure</ulink>. When a property is indexed as numeric field, it enables efficient range query and sorting, orders of magnitude faster than doing the same query on standard <classname>@Field </classname>properties. The <classname>@NumericField</classname> annotation accept the following parameters:"
msgstr ""

#. Tag: entry
#: mapping.xml:279
#, no-c-format
msgid "forField"
msgstr ""

#. Tag: entry
#: mapping.xml:281
#, no-c-format
msgid "(Optional) Specify the name of of the related @Field that will be indexed as numeric. It's only mandatory when the property contains more than a @Field declaration"
msgstr ""

#. Tag: entry
#: mapping.xml:287
#, no-c-format
msgid "precisionStep"
msgstr ""

#. Tag: entry
#: mapping.xml:289
#, no-c-format
msgid "(Optional) Change the way that the Trie structure is stored in the index. Smaller precisionSteps lead to more disk space usage and faster range and sort queries. Larger values lead to less space used and range query performance more close to the range query in normal @Fields. Default value is 4."
msgstr ""

#. Tag: para
#: mapping.xml:301
#, no-c-format
msgid "Lucene marks the numeric field API still as experimental and warns for incompatible changes in coming releases. Using Hibernate Search will hopefully shield you from any underlying API changes, but that is not guaranteed."
msgstr ""

#. Tag: title
#: mapping.xml:309
#, no-c-format
msgid "<title>@Id</title>"
msgstr ""

#. Tag: para
#: mapping.xml:311
#, no-c-format
msgid "Finally, the id property of an entity is a special property used by Hibernate Search to ensure index unicity of a given entity. By design, an id has to be stored and must not be tokenized. To mark a property as index id, use the <literal>@DocumentId</literal> annotation. If you are using JPA and you have specified <classname>@Id</classname> you can omit <classname>@DocumentId</classname>. The chosen entity id will also be used as document id."
msgstr ""

#. Tag: title
#: mapping.xml:321
#, no-c-format
msgid "Specifying indexed properties"
msgstr ""

#. Tag: programlisting
#: mapping.xml:323
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed\n"
      "public class Essay {\n"
      "    ...\n"
      "\n"
      "    @Id\n"
      "    <emphasis role=\"bold\">@DocumentId</emphasis>\n"
      "    public Long getId() { return id; }\n"
      "\n"
      "    <emphasis role=\"bold\">@Field(name=\"Abstract\", store=Store.YES)</emphasis>\n"
      "    public String getSummary() { return summary; }\n"
      "\n"
      "    @Lob\n"
      "    <emphasis role=\"bold\">@Field</emphasis>\n"
      "    public String getText() { return text; }\n"
      "\n"
      "    <emphasis role=\"bold\">@Field \n"
      "    @NumericField( precisionStep = 6)</emphasis>\n"
      "    public float getGrade() { return grade; }\n"
      "}"
msgstr ""

#. Tag: para
#: mapping.xml:326
#, no-c-format
msgid "defines an index with four fields: <literal>id</literal> , <literal>Abstract</literal>, <literal>text</literal> and <literal>grade</literal> . Note that by default the field name is decapitalized, following the JavaBean specification. The <literal>grade</literal> field is annotated as Numeric with a slightly larger precisionStep than the default."
msgstr ""

#. Tag: title
#: mapping.xml:336
#, no-c-format
msgid "Mapping properties multiple times"
msgstr ""

#. Tag: para
#: mapping.xml:338
#, no-c-format
msgid "Sometimes one has to map a property multiple times per index, with slightly different indexing strategies. For example, sorting a query by field requires the field to be un-analyzed. If one wants to search by words in this property and still sort it, one need to index it twice - once analyzed and once un-analyzed. @Fields allows to achieve this goal."
msgstr ""

#. Tag: title
#: mapping.xml:346
#, no-c-format
msgid "Using @Fields to map a property multiple times"
msgstr ""

#. Tag: programlisting
#: mapping.xml:348
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed(index = \"Book\" )\n"
      "public class Book {\n"
      "    <emphasis role=\"bold\">@Fields( {</emphasis>\n"
      "            @Field,\n"
      "            @Field(name = \"summary_forSort\", analyze = Analyze.NO, store = Store.YES)\n"
      "            <emphasis role=\"bold\">} )</emphasis>\n"
      "    public String getSummary() {\n"
      "        return summary;\n"
      "    }\n"
      "\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: para
#: mapping.xml:351
#, no-c-format
msgid "In <xref linkend=\"example-fields-annotation\"/> the field <literal>summary</literal> is indexed twice, once as <literal>summary</literal> in a tokenized way, and once as <literal>summary_forSort</literal> in an untokenized way. @Field supports 2 attributes useful when @Fields is used:"
msgstr ""

#. Tag: para
#: mapping.xml:359
#, no-c-format
msgid "analyzer: defines a @Analyzer annotation per field rather than per property"
msgstr ""

#. Tag: para
#: mapping.xml:364
#, no-c-format
msgid "bridge: defines a @FieldBridge annotation per field rather than per property"
msgstr ""

#. Tag: para
#: mapping.xml:369
#, no-c-format
msgid "See below for more information about analyzers and field bridges."
msgstr ""

#. Tag: title
#: mapping.xml:374
#, no-c-format
msgid "Embedded and associated objects"
msgstr ""

#. Tag: para
#: mapping.xml:376
#, no-c-format
msgid "Associated objects as well as embedded objects can be indexed as part of the root entity index. This is useful if you expect to search a given entity based on properties of associated objects. In <xref linkend=\"example-indexing-associations\"/>t the aim is to return places where the associated city is Atlanta (In the Lucene query parser language, it would translate into <code>address.city:Atlanta</code>). The place fields will be indexed in the <literal>Place</literal> index. The <literal>Place</literal> index documents will also contain the fields <literal>address.id</literal>, <literal>address.street</literal>, and <literal>address.city</literal> which you will be able to query."
msgstr ""

#. Tag: title
#: mapping.xml:389
#, no-c-format
msgid "Indexing associations"
msgstr ""

#. Tag: programlisting
#: mapping.xml:391
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed\n"
      "public class Place {\n"
      "    @Id\n"
      "    @GeneratedValue\n"
      "    @DocumentId\n"
      "    private Long id;\n"
      "\n"
      "    @Field\n"
      "    private String name;\n"
      "\n"
      "    @OneToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )\n"
      "    <emphasis role=\"bold\">@IndexedEmbedded</emphasis>\n"
      "    private Address address;\n"
      "    ....\n"
      "}\n"
      "\n"
      "@Entity\n"
      "public class Address {\n"
      "    @Id\n"
      "    @GeneratedValue\n"
      "    private Long id;\n"
      "\n"
      "    @Field\n"
      "    private String street;\n"
      "\n"
      "    @Field\n"
      "    private String city;\n"
      "\n"
      "    <emphasis role=\"bold\">@ContainedIn</emphasis>\n"
      "    @OneToMany(mappedBy=\"address\")\n"
      "    private Set&lt;Place&gt; places;\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: para
#: mapping.xml:394
#, no-c-format
msgid "Be careful. Because the data is denormalized in the Lucene index when using the <classname>@IndexedEmbedded</classname> technique, Hibernate Search needs to be aware of any change in the <classname>Place</classname> object and any change in the <classname>Address</classname> object to keep the index up to date. To make sure the <literal><classname>Place</classname></literal> Lucene document is updated when it's <classname>Address</classname> changes, you need to mark the other side of the bidirectional relationship with <classname>@ContainedIn</classname>."
msgstr ""

#. Tag: para
#: mapping.xml:405
#, no-c-format
msgid "<literal>@ContainedIn</literal> is useful on both associations pointing to entities and on embedded (collection of) objects."
msgstr ""

#. Tag: para
#: mapping.xml:409
#, no-c-format
msgid "Let's make <xref linkend=\"example-indexing-associations\"/> a bit more complex by nesting @IndexEmbedded as seen in <xref linkend=\"example-nested-index-embedded\"/>."
msgstr ""

#. Tag: title
#: mapping.xml:414
#, no-c-format
msgid "Nested usage of <classname>@IndexedEmbedded</classname> and <classname>@ContainedIn</classname>"
msgstr ""

#. Tag: programlisting
#: mapping.xml:417
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed\n"
      "public class Place {\n"
      "    @Id\n"
      "    @GeneratedValue\n"
      "    @DocumentId\n"
      "    private Long id;\n"
      "\n"
      "    @Field\n"
      "    private String name;\n"
      "\n"
      "    @OneToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )\n"
      "    <emphasis role=\"bold\">@IndexedEmbedded</emphasis>\n"
      "    private Address address;\n"
      "    ....\n"
      "}\n"
      "\n"
      "@Entity\n"
      "public class Address {\n"
      "    @Id\n"
      "    @GeneratedValue\n"
      "    private Long id;\n"
      "\n"
      "    @Field\n"
      "    private String street;\n"
      "\n"
      "    @Field\n"
      "    private String city;\n"
      "\n"
      "    <emphasis role=\"bold\">@IndexedEmbedded(depth = 1, prefix = \"ownedBy_\")</emphasis>\n"
      "    private Owner ownedBy;\n"
      "\n"
      "    <emphasis role=\"bold\">@ContainedIn</emphasis>\n"
      "    @OneToMany(mappedBy=\"address\")\n"
      "    private Set&lt;Place&gt; places;\n"
      "    ...\n"
      "}\n"
      "\n"
      "@Embeddable\n"
      "public class Owner {\n"
      "    @Field\n"
      "    private String name;\n"
      "   ...\n"
      "}"
msgstr ""

#. Tag: para
#: mapping.xml:420
#, no-c-format
msgid "As you can see, any <literal>@*ToMany, @*ToOne</literal> and <literal>@Embedded</literal> attribute can be annotated with <literal>@IndexedEmbedded</literal>. The attributes of the associated class will then be added to the main entity index. In <xref linkend=\"example-nested-index-embedded\"/> the index will contain the following fields"
msgstr ""

#. Tag: para
#: mapping.xml:429
#, no-c-format
msgid "<para>id</para>"
msgstr ""

#. Tag: para
#: mapping.xml:433
#, no-c-format
msgid "name"
msgstr ""

#. Tag: para
#: mapping.xml:437
#, no-c-format
msgid "address.street"
msgstr ""

#. Tag: para
#: mapping.xml:441
#, no-c-format
msgid "address.city"
msgstr ""

#. Tag: para
#: mapping.xml:445
#, no-c-format
msgid "address.ownedBy_name"
msgstr ""

#. Tag: para
#: mapping.xml:449
#, no-c-format
msgid "The default prefix is <literal>propertyName.</literal>, following the traditional object navigation convention. You can override it using the <literal>prefix</literal> attribute as it is shown on the <literal>ownedBy</literal> property."
msgstr ""

#. Tag: para
#: mapping.xml:455
#, no-c-format
msgid "The prefix cannot be set to the empty string."
msgstr ""

#. Tag: para
#: mapping.xml:458
#, no-c-format
msgid "The<literal> depth</literal> property is necessary when the object graph contains a cyclic dependency of classes (not instances). For example, if <classname>Owner</classname> points to <classname>Place</classname>. Hibernate Search will stop including Indexed embedded attributes after reaching the expected depth (or the object graph boundaries are reached). A class having a self reference is an example of cyclic dependency. In our example, because <literal>depth</literal> is set to 1, any <literal>@IndexedEmbedded</literal> attribute in Owner (if any) will be ignored."
msgstr ""

#. Tag: para
#: mapping.xml:469
#, no-c-format
msgid "Using <literal>@IndexedEmbedded</literal> for object associations allows you to express queries (using Lucene's query syntax) such as:"
msgstr ""

#. Tag: para
#: mapping.xml:475
#, no-c-format
msgid "Return places where name contains JBoss and where address city is Atlanta. In Lucene query this would be"
msgstr ""

#. Tag: programlisting
#: mapping.xml:478
#, no-c-format
msgid "+name:jboss +address.city:atlanta"
msgstr ""

#. Tag: para
#: mapping.xml:482
#, no-c-format
msgid "Return places where name contains JBoss and where owner's name contain Joe. In Lucene query this would be"
msgstr ""

#. Tag: programlisting
#: mapping.xml:485
#, no-c-format
msgid "+name:jboss +address.orderBy_name:joe"
msgstr ""

#. Tag: para
#: mapping.xml:489
#, no-c-format
msgid "In a way it mimics the relational join operation in a more efficient way (at the cost of data duplication). Remember that, out of the box, Lucene indexes have no notion of association, the join operation is simply non-existent. It might help to keep the relational model normalized while benefiting from the full text index speed and feature richness."
msgstr ""

#. Tag: para
#: mapping.xml:497
#, no-c-format
msgid "An associated object can itself (but does not have to) be <literal>@Indexed</literal>"
msgstr ""

#. Tag: para
#: mapping.xml:501
#, no-c-format
msgid "When @IndexedEmbedded points to an entity, the association has to be directional and the other side has to be annotated <literal>@ContainedIn</literal> (as seen in the previous example). If not, Hibernate Search has no way to update the root index when the associated entity is updated (in our example, a <literal>Place</literal> index document has to be updated when the associated <classname>Address</classname> instance is updated)."
msgstr ""

#. Tag: para
#: mapping.xml:509
#, no-c-format
msgid "Sometimes, the object type annotated by <classname>@IndexedEmbedded</classname> is not the object type targeted by Hibernate and Hibernate Search. This is especially the case when interfaces are used in lieu of their implementation. For this reason you can override the object type targeted by Hibernate Search using the <methodname>targetElement</methodname> parameter."
msgstr ""

#. Tag: title
#: mapping.xml:517
#, no-c-format
msgid "Using the <literal>targetElement</literal> property of <classname>@IndexedEmbedded</classname>"
msgstr ""

#. Tag: programlisting
#: mapping.xml:520
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed\n"
      "public class Address {\n"
      "    @Id\n"
      "    @GeneratedValue\n"
      "    @DocumentId\n"
      "    private Long id;\n"
      "\n"
      "    @Field\n"
      "    private String street;\n"
      "\n"
      "    @IndexedEmbedded(depth = 1, prefix = \"ownedBy_\", <emphasis role=\"bold\">targetElement = Owner.class</emphasis>)\n"
      "    @Target(Owner.class)\n"
      "    private Person ownedBy;\n"
      "\n"
      "\n"
      "    ...\n"
      "}\n"
      "\n"
      "@Embeddable\n"
      "public class Owner implements Person { ... }"
msgstr ""

#. Tag: title
#: mapping.xml:526
#, no-c-format
msgid "Boosting"
msgstr ""

#. Tag: para
#: mapping.xml:528
#, no-c-format
msgid "Lucene has the notion of <emphasis>boosting</emphasis> which allows you to give certain documents or fields more or less importance than others. Lucene differentiates between index and search time boosting. The following sections show you how you can achieve index time boosting using Hibernate Search."
msgstr ""

#. Tag: title
#: mapping.xml:535
#, no-c-format
msgid "Static index time boosting"
msgstr ""

#. Tag: para
#: mapping.xml:537
#, no-c-format
msgid "To define a static boost value for an indexed class or property you can use the <classname>@Boost</classname> annotation. You can use this annotation within @Field or specify it directly on method or class level."
msgstr ""

#. Tag: title
#: mapping.xml:543
#, no-c-format
msgid "Different ways of using @Boost"
msgstr ""

#. Tag: programlisting
#: mapping.xml:545
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed\n"
      "<emphasis role=\"bold\">@Boost(1.7f)</emphasis>\n"
      "public class Essay {\n"
      "    ...\n"
      "\n"
      "    @Id\n"
      "    @DocumentId\n"
      "    public Long getId() { return id; }\n"
      "\n"
      "    @Field(name=\"Abstract\", store=Store.YES, boost=<emphasis role=\"bold\">@Boost(2f)</emphasis>)\n"
      "    <emphasis role=\"bold\">@Boost(1.5f)</emphasis>\n"
      "    public String getSummary() { return summary; }\n"
      "\n"
      "    @Lob\n"
      "    @Field(boost=<emphasis role=\"bold\">@Boost(1.2f)</emphasis>)\n"
      "    public String getText() { return text; }\n"
      "\n"
      "    @Field\n"
      "    public String getISBN() { return isbn; }\n"
      "\n"
      "}"
msgstr ""

#. Tag: para
#: mapping.xml:548
#, no-c-format
msgid "In <xref linkend=\"example-boost\"/>, <classname>Essay</classname>'s probability to reach the top of the search list will be multiplied by 1.7. The <methodname>summary</methodname> field will be 3.0 (2 * 1.5, because <methodname>@Field.boost</methodname> and <classname>@Boost</classname> on a property are cumulative) more important than the <methodname>isbn</methodname> field. The <methodname>text</methodname> field will be 1.2 times more important than the <methodname>isbn</methodname> field. Note that this explanation is wrong in strictest terms, but it is simple and close enough to reality for all practical purposes. Please check the Lucene documentation or the excellent <citetitle>Lucene In Action </citetitle> from Otis Gospodnetic and Erik Hatcher."
msgstr ""

#. Tag: title
#: mapping.xml:564
#, no-c-format
msgid "Dynamic index time boosting"
msgstr ""

#. Tag: para
#: mapping.xml:566
#, no-c-format
msgid "The <literal>@Boost </literal>annotation used in <xref linkend=\"section-boost-annotation\"/> defines a static boost factor which is independent of the state of of the indexed entity at runtime. However, there are usecases in which the boost factor may depends on the actual state of the entity. In this case you can use the <literal>@DynamicBoost </literal>annotation together with an accompanying custom <classname>BoostStrategy</classname>."
msgstr ""

#. Tag: title
#: mapping.xml:575
#, no-c-format
msgid "Dynamic boost examle"
msgstr ""

#. Tag: programlisting
#: mapping.xml:577
#, no-c-format
msgid ""
      "public enum PersonType {\n"
      "    NORMAL,\n"
      "    VIP\n"
      "}\n"
      "\n"
      "@Entity\n"
      "@Indexed\n"
      "<emphasis role=\"bold\">@DynamicBoost(impl = VIPBoostStrategy.class)</emphasis>\n"
      "public class Person {\n"
      "    private PersonType type;   \n"
      "    \n"
      "    // ....\n"
      "}\n"
      "\n"
      "public class VIPBoostStrategy implements BoostStrategy {\n"
      "    <emphasis role=\"bold\">public float defineBoost(Object value)</emphasis> {\n"
      "        Person person = ( Person ) value;\n"
      "        if ( person.getType().equals( PersonType.VIP ) ) {\n"
      "            return 2.0f;\n"
      "        }\n"
      "        else {\n"
      "            return 1.0f;\n"
      "        }\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: mapping.xml:580
#, no-c-format
msgid "In <xref linkend=\"example-dynamic-boosting\"/> a dynamic boost is defined on class level specifying <classname>VIPBoostStrategy</classname> as implementation of the <classname>BoostStrategy</classname> interface to be used at indexing time. You can place the <literal>@DynamicBoost</literal> either at class or field level. Depending on the placement of the annotation either the whole entity is passed to the <methodname>defineBoost</methodname> method or just the annotated field/property value. It's up to you to cast the passed object to the correct type. In the example all indexed values of a VIP person would be double as important as the values of a normal person.<note> <para>The specified <classname>BoostStrategy</classname> implementation must define a public no-arg constructor.</para> </note>Of course you can mix and match <literal>@Boost</literal> and <literal>@DynamicBoost</literal> annotations in your entity. All defined boost factors are cummulative."
msgstr ""

#. Tag: title
#: mapping.xml:600
#, no-c-format
msgid "Analysis"
msgstr ""

#. Tag: para
#: mapping.xml:602
#, no-c-format
msgid "<literal>Analysis</literal> is the process of converting text into single terms (words) and can be considered as one of the key features of a fulltext search engine. Lucene uses the concept of <classname>Analyzer</classname>s to control this process. In the following section we cover the multiple ways Hibernate Search offers to configure the analyzers."
msgstr ""

#. Tag: title
#: mapping.xml:610
#, no-c-format
msgid "Default analyzer and analyzer by class"
msgstr ""

#. Tag: para
#: mapping.xml:612
#, no-c-format
msgid "The default analyzer class used to index tokenized fields is configurable through the <literal>hibernate.search.analyzer</literal> property. The default value for this property is <classname>org.apache.lucene.analysis.standard.StandardAnalyzer</classname>."
msgstr ""

#. Tag: para
#: mapping.xml:617
#, no-c-format
msgid "You can also define the analyzer class per entity, property and even per @Field (useful when multiple fields are indexed from a single property)."
msgstr ""

#. Tag: title
#: mapping.xml:622
#, no-c-format
msgid "Different ways of using @Analyzer"
msgstr ""

#. Tag: programlisting
#: mapping.xml:624
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed\n"
      "<emphasis role=\"bold\">@Analyzer(impl = EntityAnalyzer.class)</emphasis>\n"
      "public class MyEntity {\n"
      "    @Id\n"
      "    @GeneratedValue\n"
      "    @DocumentId\n"
      "    private Integer id;\n"
      "\n"
      "    @Field\n"
      "    private String name;\n"
      "\n"
      "    @Field\n"
      "    <emphasis role=\"bold\">@Analyzer(impl = PropertyAnalyzer.class)</emphasis>\n"
      "    private String summary;\n"
      "\n"
      "    @Field(<emphasis><emphasis role=\"bold\">analyzer = @Analyzer(impl = FieldAnalyzer.class</emphasis></emphasis>)\n"
      "    private String body;\n"
      "\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: para
#: mapping.xml:627
#, no-c-format
msgid "In this example, <classname>EntityAnalyzer</classname> is used to index all tokenized properties (eg. <literal>name</literal>), except <literal>summary</literal> and <literal>body</literal> which are indexed with <classname>PropertyAnalyzer</classname> and <classname>FieldAnalyzer</classname> respectively."
msgstr ""

#. Tag: para
#: mapping.xml:634
#, no-c-format
msgid "Mixing different analyzers in the same entity is most of the time a bad practice. It makes query building more complex and results less predictable (for the novice), especially if you are using a QueryParser (which uses the same analyzer for the whole query). As a rule of thumb, for any given field the same analyzer should be used for indexing and querying."
msgstr ""

#. Tag: title
#: mapping.xml:644
#, no-c-format
msgid "Named analyzers"
msgstr ""

#. Tag: para
#: mapping.xml:646
#, no-c-format
msgid "Analyzers can become quite complex to deal with. For this reason introduces Hibernate Search the notion of analyzer definitions. An analyzer definition can be reused by many <classname>@Analyzer</classname> declarations and is composed of:"
msgstr ""

#. Tag: para
#: mapping.xml:653
#, no-c-format
msgid "a name: the unique string used to refer to the definition"
msgstr ""

#. Tag: para
#: mapping.xml:658
#, no-c-format
msgid "a list of char filters: each char filter is responsible to pre-process input characters before the tokenization. Char filters can add, change or remove characters; one common usage is for characters normalization"
msgstr ""

#. Tag: para
#: mapping.xml:665
#, no-c-format
msgid "a tokenizer: responsible for tokenizing the input stream into individual words"
msgstr ""

#. Tag: para
#: mapping.xml:670
#, no-c-format
msgid "a list of filters: each filter is responsible to remove, modify or sometimes even add words into the stream provided by the tokenizer"
msgstr ""

#. Tag: para
#: mapping.xml:676
#, no-c-format
msgid "This separation of tasks - a list of char filters, and a tokenizer followed by a list of filters - allows for easy reuse of each individual component and let you build your customized analyzer in a very flexible way (just like Lego). Generally speaking the char filters do some pre-processing in the character input, then the <classname>Tokenizer</classname> starts the tokenizing process by turning the character input into tokens which are then further processed by the <classname>TokenFilter</classname>s. Hibernate Search supports this infrastructure by utilizing the Solr analyzer framework."
msgstr ""

#. Tag: para
#: mapping.xml:687
#, no-c-format
msgid "Some of the analyzers and filters will require additional dependencies. For example to use the snowball stemmer you have to also include the <literal>lucene-snowball</literal> jar and for the <classname>PhoneticFilterFactory</classname> you need the <ulink url=\"http://commons.apache.org/codec\">commons-codec</ulink> jar. Your distribution of Hibernate Search provides these dependencies in its <filename>lib/optional</filename> directory. Have a look at <xref linkend=\"table-available-tokenizers\"/> and <xref linkend=\"table-available-filters\"/> to see which anaylzers and filters have additional dependencies"
msgstr ""

#. Tag: para
#: mapping.xml:698
#, no-c-format
msgid "Prior to Search version 3.3.0.Beta2 it was required to add the Solr dependency <emphasis>org.apache.solr:solr-core</emphasis> when you wanted to use the analyzer definition framework. In case you are using Maven this is no longer needed: all required Solr dependencies are now defined as dependencies of the artifact <emphasis>org.hibernate:hibernate-search-analyzers</emphasis>; just add the following dependency :"
msgstr ""

#. Tag: programlisting
#: mapping.xml:704
#, no-c-format
msgid ""
      "&lt;dependency&gt;\n"
      "   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;\n"
      "   &lt;artifactId&gt;hibernate-search-analyzers&lt;/artifactId&gt;\n"
      "   &lt;version&gt;&version;&lt;/version&gt;\n"
      "&lt;dependency&gt;"
msgstr ""

#. Tag: para
#: mapping.xml:707
#, no-c-format
msgid "Let's have a look at a concrete example now - <xref linkend=\"example-analyzer-def\"/>. First a char filter is defined by its factory. In our example, a mapping char filter is used, and will replace characters in the input based on the rules specified in the mapping file. Next a tokenizer is defined. This example uses the standard tokenizer. Last but not least, a list of filters is defined by their factories. In our example, the <classname>StopFilter</classname> filter is built reading the dedicated words property file. The filter is also expected to ignore case."
msgstr ""

#. Tag: title
#: mapping.xml:718
#, no-c-format
msgid "<classname>@AnalyzerDef</classname> and the Solr framework"
msgstr ""

#. Tag: programlisting
#: mapping.xml:721
#, no-c-format
msgid ""
      "@AnalyzerDef(name=\"customanalyzer\",\n"
      "  charFilters = {\n"
      "    @CharFilterDef(factory = MappingCharFilterFactory.class, params = {\n"
      "      @Parameter(name = \"mapping\",\n"
      "        value = \"org/hibernate/search/test/analyzer/solr/mapping-chars.properties\")\n"
      "    })\n"
      "  },\n"
      "  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),\n"
      "  filters = {\n"
      "    @TokenFilterDef(factory = ISOLatin1AccentFilterFactory.class),\n"
      "    @TokenFilterDef(factory = LowerCaseFilterFactory.class),\n"
      "    @TokenFilterDef(factory = StopFilterFactory.class, params = {\n"
      "      @Parameter(name=\"words\",\n"
      "        value= \"org/hibernate/search/test/analyzer/solr/stoplist.properties\" ),\n"
      "      @Parameter(name=\"ignoreCase\", value=\"true\")\n"
      "    })\n"
      "})\n"
      "public class Team {\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: para
#: mapping.xml:725
#, no-c-format
msgid "Filters and char filters are applied in the order they are defined in the <classname>@AnalyzerDef</classname> annotation. Order matters!"
msgstr ""

#. Tag: para
#: mapping.xml:730
#, no-c-format
msgid "Some tokenizers, token filters or char filters load resources like a configuration or metadata file. This is the case for the stop filter and the synonym filter. If the resource charset is not using the VM default, you can explicitly specify it by adding a <literal>resource_charset</literal> parameter."
msgstr ""

#. Tag: title
#: mapping.xml:737
#, no-c-format
msgid "Use a specific charset to load the property file"
msgstr ""

#. Tag: programlisting
#: mapping.xml:739
#, no-c-format
msgid ""
      "@AnalyzerDef(name=\"customanalyzer\",\n"
      "  charFilters = {\n"
      "    @CharFilterDef(factory = MappingCharFilterFactory.class, params = {\n"
      "      @Parameter(name = \"mapping\",\n"
      "        value = \"org/hibernate/search/test/analyzer/solr/mapping-chars.properties\")\n"
      "    })\n"
      "  },\n"
      "  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),\n"
      "  filters = {\n"
      "    @TokenFilterDef(factory = ISOLatin1AccentFilterFactory.class),\n"
      "    @TokenFilterDef(factory = LowerCaseFilterFactory.class),\n"
      "    @TokenFilterDef(factory = StopFilterFactory.class, params = {\n"
      "      @Parameter(name=\"words\",\n"
      "        value= \"org/hibernate/search/test/analyzer/solr/stoplist.properties\" ),\n"
      "      @Parameter(name=\"resource_charset\", value = \"UTF-16BE\"),\n"
      "      @Parameter(name=\"ignoreCase\", value=\"true\")\n"
      "  })\n"
      "})\n"
      "public class Team {\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: para
#: mapping.xml:742
#, no-c-format
msgid "Once defined, an analyzer definition can be reused by an <classname>@Analyzer</classname> declaration as seen in <xref linkend=\"example-referencing-analyzer-def\"/>."
msgstr ""

#. Tag: title
#: mapping.xml:747
#, no-c-format
msgid "Referencing an analyzer by name"
msgstr ""

#. Tag: programlisting
#: mapping.xml:750
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed\n"
      "@AnalyzerDef(name=\"customanalyzer\", ... )\n"
      "public class Team {\n"
      "    @Id\n"
      "    @DocumentId\n"
      "    @GeneratedValue\n"
      "    private Integer id;\n"
      "\n"
      "    @Field\n"
      "    private String name;\n"
      "\n"
      "    @Field\n"
      "    private String location;\n"
      "\n"
      "    @Field \n"
      "    <emphasis role=\"bold\">@Analyzer(definition = \"customanalyzer\")</emphasis>\n"
      "    private String description;\n"
      "}"
msgstr ""

#. Tag: para
#: mapping.xml:753
#, no-c-format
msgid "Analyzer instances declared by <classname>@AnalyzerDef</classname> are also available by their name in the <classname>SearchFactory</classname> which is quite useful wen building queries."
msgstr ""

#. Tag: programlisting
#: mapping.xml:758
#, no-c-format
msgid "Analyzer analyzer = fullTextSession.getSearchFactory().getAnalyzer(\"customanalyzer\");"
msgstr ""

#. Tag: para
#: mapping.xml:760
#, no-c-format
msgid "Fields in queries should be analyzed with the same analyzer used to index the field so that they speak a common \"language\": the same tokens are reused between the query and the indexing process. This rule has some exceptions but is true most of the time. Respect it unless you know what you are doing."
msgstr ""

#. Tag: title
#: mapping.xml:767
#, no-c-format
msgid "Available analyzers"
msgstr ""

#. Tag: para
#: mapping.xml:769
#, no-c-format
msgid "Solr and Lucene come with a lot of useful default char filters, tokenizers and filters. You can find a complete list of char filter factories, tokenizer factories and filter factories at <ulink url=\"http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters\">http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters</ulink>. Let's check a few of them."
msgstr ""

#. Tag: title
#: mapping.xml:776
#, no-c-format
msgid "Example of available char filters"
msgstr ""

#. Tag: entry
#: mapping.xml:781 mapping.xml:824 mapping.xml:878
#, no-c-format
msgid "Factory"
msgstr ""

#. Tag: entry
#: mapping.xml:783 mapping.xml:826 mapping.xml:880
#, no-c-format
msgid "Description"
msgstr ""

#. Tag: entry
#: mapping.xml:785 mapping.xml:828 mapping.xml:882
#, no-c-format
msgid "Parameters"
msgstr ""

#. Tag: entry
#: mapping.xml:787 mapping.xml:830 mapping.xml:884
#, no-c-format
msgid "Additional dependencies"
msgstr ""

#. Tag: classname
#: mapping.xml:793
#, no-c-format
msgid "MappingCharFilterFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:795
#, no-c-format
msgid "Replaces one or more characters with one or more characters, based on mappings specified in the resource file"
msgstr ""

#. Tag: para
#: mapping.xml:799
#, no-c-format
msgid "<literal>mapping</literal>: points to a resource file containing the mappings using the format:"
msgstr ""

#. Tag: literallayout
#: mapping.xml:800
#, no-c-format
msgid ""
      "\"á\" =&gt; \"a\"\n"
      "                    \"ñ\" =&gt; \"n\"\n"
      "                    \"ø\" =&gt; \"o\""
msgstr ""

#. Tag: entry
#: mapping.xml:802 mapping.xml:810 mapping.xml:812 mapping.xml:840 mapping.xml:842 mapping.xml:851 mapping.xml:894 mapping.xml:904 mapping.xml:942
#, no-c-format
msgid "none"
msgstr ""

#. Tag: classname
#: mapping.xml:806 mapping.xml:846
#, no-c-format
msgid "HTMLStripCharFilterFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:808
#, no-c-format
msgid "Remove HTML standard tags, keeping the text"
msgstr ""

#. Tag: title
#: mapping.xml:819
#, no-c-format
msgid "Example of available tokenizers"
msgstr ""

#. Tag: classname
#: mapping.xml:836
#, no-c-format
msgid "StandardTokenizerFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:838
#, no-c-format
msgid "Use the Lucene StandardTokenizer"
msgstr ""

#. Tag: entry
#: mapping.xml:848
#, no-c-format
msgid "Remove HTML tags, keep the text and pass it to a StandardTokenizer."
msgstr ""

#. Tag: literal
#: mapping.xml:853 mapping.xml:866 mapping.xml:896 mapping.xml:906 mapping.xml:920 mapping.xml:934 mapping.xml:944
#, no-c-format
msgid "solr-core"
msgstr ""

#. Tag: classname
#: mapping.xml:857
#, no-c-format
msgid "PatternTokenizerFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:859
#, no-c-format
msgid "Breaks text at the specified regular expression pattern."
msgstr ""

#. Tag: para
#: mapping.xml:862
#, no-c-format
msgid "<literal>pattern</literal>: the regular expression to use for tokenizing"
msgstr ""

#. Tag: para
#: mapping.xml:863
#, no-c-format
msgid "group: says which pattern group to extract into tokens"
msgstr ""

#. Tag: title
#: mapping.xml:873
#, no-c-format
msgid "Examples of available filters"
msgstr ""

#. Tag: classname
#: mapping.xml:890
#, no-c-format
msgid "StandardFilterFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:892
#, no-c-format
msgid "Remove dots from acronyms and 's from words"
msgstr ""

#. Tag: classname
#: mapping.xml:900
#, no-c-format
msgid "LowerCaseFilterFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:902
#, no-c-format
msgid "Lowercases all words"
msgstr ""

#. Tag: classname
#: mapping.xml:910
#, no-c-format
msgid "StopFilterFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:912
#, no-c-format
msgid "Remove words (tokens) matching a list of stop words"
msgstr ""

#. Tag: para
#: mapping.xml:915
#, no-c-format
msgid "<literal>words</literal>: points to a resource file containing the stop words"
msgstr ""

#. Tag: para
#: mapping.xml:916
#, no-c-format
msgid "ignoreCase: true if <literal>case</literal> should be ignore when comparing stop words, <literal>false</literal> otherwise"
msgstr ""

#. Tag: classname
#: mapping.xml:924
#, no-c-format
msgid "SnowballPorterFilterFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:926
#, no-c-format
msgid "Reduces a word to it's root in a given language. (eg. protect, protects, protection share the same root). Using such a filter allows searches matching related words."
msgstr ""

#. Tag: entry
#: mapping.xml:930
#, no-c-format
msgid "<literal>language</literal>: Danish, Dutch, English, Finnish, French, German, Italian, Norwegian, Portuguese, Russian, Spanish, Swedish and a few more"
msgstr ""

#. Tag: classname
#: mapping.xml:938
#, no-c-format
msgid "ISOLatin1AccentFilterFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:940
#, no-c-format
msgid "Remove accents for languages like French"
msgstr ""

#. Tag: classname
#: mapping.xml:948
#, no-c-format
msgid "PhoneticFilterFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:950
#, no-c-format
msgid "Inserts phonetically similar tokens into the token stream"
msgstr ""

#. Tag: para
#: mapping.xml:953
#, no-c-format
msgid "<literal>encoder</literal>: One of DoubleMetaphone, Metaphone, Soundex or RefinedSoundex"
msgstr ""

#. Tag: para
#: mapping.xml:955
#, no-c-format
msgid "inject: <constant>true</constant> will add tokens to the stream, <constant>false</constant> will replace the existing token"
msgstr ""

#. Tag: para
#: mapping.xml:958
#, no-c-format
msgid "<literal>maxCodeLength</literal>: sets the maximum length of the code to be generated. Supported only for Metaphone and DoubleMetaphone encodings"
msgstr ""

#. Tag: entry
#: mapping.xml:962
#, no-c-format
msgid "<literal>solr-core</literal> and <literal>commons-codec</literal>"
msgstr ""

#. Tag: classname
#: mapping.xml:967
#, no-c-format
msgid "CollationKeyFilterFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:969
#, no-c-format
msgid "Converts each token into its <classname>java.text.CollationKey</classname>, and then encodes the <classname>CollationKey</classname> with <classname>IndexableBinaryStringTools</classname>, to allow it to be stored as an index term."
msgstr ""

#. Tag: entry
#: mapping.xml:975
#, no-c-format
msgid "<literal>custom</literal>, <literal>language</literal>, <literal>country</literal>, <literal>variant</literal>, <literal>strength</literal>, <literal>decomposition </literal>see Lucene's <classname>CollationKeyFilter</classname> javadocs for more info"
msgstr ""

#. Tag: entry
#: mapping.xml:982
#, no-c-format
msgid "<literal>solr-core</literal> and <literal>commons-io</literal>"
msgstr ""

#. Tag: para
#: mapping.xml:989
#, no-c-format
msgid "We recommend to check all the implementations of <classname>org.apache.solr.analysis.TokenizerFactory</classname> and <classname>org.apache.solr.analysis.TokenFilterFactory</classname> in your IDE to see the implementations available."
msgstr ""

#. Tag: title
#: mapping.xml:997
#, no-c-format
msgid "Dynamic analyzer selection (experimental)"
msgstr ""

#. Tag: para
#: mapping.xml:999
#, no-c-format
msgid "So far all the introduced ways to specify an analyzer were static. However, there are use cases where it is useful to select an analyzer depending on the current state of the entity to be indexed, for example in a multilingual applications. For an <classname>BlogEntry</classname> class for example the analyzer could depend on the language property of the entry. Depending on this property the correct language specific stemmer should be chosen to index the actual text."
msgstr ""

#. Tag: para
#: mapping.xml:1007
#, no-c-format
msgid "To enable this dynamic analyzer selection Hibernate Search introduces the <classname>AnalyzerDiscriminator</classname> annotation. <xref linkend=\"example-analyzer-discriminator\"/> demonstrates the usage of this annotation."
msgstr ""

#. Tag: title
#: mapping.xml:1013
#, no-c-format
msgid "Usage of @AnalyzerDiscriminator"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1015
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed\n"
      "@AnalyzerDefs({\n"
      "  @AnalyzerDef(name = \"en\",\n"
      "    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),\n"
      "    filters = {\n"
      "      @TokenFilterDef(factory = LowerCaseFilterFactory.class),\n"
      "      @TokenFilterDef(factory = EnglishPorterFilterFactory.class\n"
      "      )\n"
      "    }),\n"
      "  @AnalyzerDef(name = \"de\",\n"
      "    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),\n"
      "    filters = {\n"
      "      @TokenFilterDef(factory = LowerCaseFilterFactory.class),\n"
      "      @TokenFilterDef(factory = GermanStemFilterFactory.class)\n"
      "    })\n"
      "})\n"
      "public class BlogEntry {\n"
      "\n"
      "    @Id\n"
      "    @GeneratedValue\n"
      "    @DocumentId\n"
      "    private Integer id;\n"
      "\n"
      "    @Field\n"
      "    @AnalyzerDiscriminator(impl = LanguageDiscriminator.class)\n"
      "    private String language;\n"
      "    \n"
      "    @Field\n"
      "    private String text;\n"
      "    \n"
      "    private Set&lt;BlogEntry&gt; references;\n"
      "\n"
      "    // standard getter/setter\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1017
#, no-c-format
msgid ""
      "public class LanguageDiscriminator implements Discriminator {\n"
      "\n"
      "    public String getAnalyzerDefinitionName(Object value, Object entity, String field) {\n"
      "        if ( value == null || !( entity instanceof Article ) ) {\n"
      "            return null;\n"
      "        }\n"
      "        return (String) value;\n"
      "\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: mapping.xml:1020
#, no-c-format
msgid "The prerequisite for using <classname>@AnalyzerDiscriminator</classname> is that all analyzers which are going to be used are predefined via <classname>@AnalyzerDef</classname> definitions. If this is the case one can place the <classname>@AnalyzerDiscriminator</classname> annotation either on the class or on a specific property of the entity for which to dynamically select an analyzer. Via the <literal>impl</literal> parameter of the <classname>AnalyzerDiscriminator</classname> you specify a concrete implementation of the <classname>Discriminator</classname> interface. It is up to you to provide an implementation for this interface. The only method you have to implement is <classname>getAnalyzerDefinitionName()</classname> which gets called for each field added to the Lucene document. The entity which is getting indexed is also passed to the interface method. The <literal>value</literal> parameter is only set if the <classname>AnalyzerDiscriminator</classname> is placed on property level instead of class level. In this case the value represents the current value of this property."
msgstr ""

#. Tag: para
#: mapping.xml:1039
#, no-c-format
msgid "An implemention of the <classname>Discriminator</classname> interface has to return the name of an existing analyzer definition if the analyzer should be set dynamically or <classname>null</classname> if the default analyzer should not be overridden. The given example assumes that the language parameter is either 'de' or 'en' which matches the specified names in the <classname>@AnalyzerDef</classname>s."
msgstr ""

#. Tag: para
#: mapping.xml:1047
#, no-c-format
msgid "The <classname>@AnalyzerDiscriminator</classname> is currently still experimental and the API might still change. We are hoping for some feedback from the community about the usefulness and usability of this feature."
msgstr ""

#. Tag: title
#: mapping.xml:1055
#, no-c-format
msgid "Retrieving an analyzer"
msgstr ""

#. Tag: para
#: mapping.xml:1057
#, no-c-format
msgid "In some situations retrieving analyzers can be handy. For example, if your domain model makes use of multiple analyzers (maybe to benefit from stemming, use phonetic approximation and so on), you need to make sure to use the same analyzers when you build your query."
msgstr ""

#. Tag: para
#: mapping.xml:1063
#, no-c-format
msgid "This rule can be broken but you need a good reason for it. If you are unsure, use the same analyzers. If you use the Hibernate Search query DSL (see <xref linkend=\"search-query-querydsl\"/>), you don't have to think about it. The query DSL does use the right analyzer transparently for you."
msgstr ""

#. Tag: para
#: mapping.xml:1070
#, no-c-format
msgid "Whether you are using the Lucene programmatic API or the Lucene query parser, you can retrieve the scoped analyzer for a given entity. A scoped analyzer is an analyzer which applies the right analyzers depending on the field indexed. Remember, multiple analyzers can be defined on a given entity each one working on an individual field. A scoped analyzer unifies all these analyzers into a context-aware analyzer. While the theory seems a bit complex, using the right analyzer in a query is very easy."
msgstr ""

#. Tag: title
#: mapping.xml:1080
#, no-c-format
msgid "Using the scoped analyzer when building a full-text query"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1083
#, no-c-format
msgid ""
      "org.apache.lucene.queryParser.QueryParser parser = new QueryParser(\n"
      "    \"title\", \n"
      "    fullTextSession.getSearchFactory().getAnalyzer( Song.class )\n"
      ");\n"
      "\n"
      "org.apache.lucene.search.Query luceneQuery = \n"
      "    parser.parse( \"title:sky Or title_stemmed:diamond\" );\n"
      "\n"
      "org.hibernate.Query fullTextQuery = \n"
      "    fullTextSession.createFullTextQuery( luceneQuery, Song.class );\n"
      "\n"
      "List result = fullTextQuery.list(); //return a list of managed objects"
msgstr ""

#. Tag: para
#: mapping.xml:1086
#, no-c-format
msgid "In the example above, the song title is indexed in two fields: the standard analyzer is used in the field <literal>title</literal> and a stemming analyzer is used in the field <literal>title_stemmed</literal>. By using the analyzer provided by the search factory, the query uses the appropriate analyzer depending on the field targeted."
msgstr ""

#. Tag: para
#: mapping.xml:1093
#, no-c-format
msgid "You can also retrieve analyzers defined via <classname>@AnalyzerDef</classname> by their definition name using <code>searchFactory.getAnalyzer(String)</code>."
msgstr ""

#. Tag: title
#: mapping.xml:1101
#, no-c-format
msgid "Bridges"
msgstr ""

#. Tag: para
#: mapping.xml:1103
#, no-c-format
msgid "When discussing the basic mapping for an entity one important fact was so far disregarded. In Lucene all index fields have to be represented as strings. All entity properties annotated with <literal>@Field</literal> have to be converted to strings to be indexed. The reason we have not mentioned it so far is, that for most of your properties Hibernate Search does the translation job for you thanks to set of built-in bridges. However, in some cases you need a more fine grained control over the translation process."
msgstr ""

#. Tag: title
#: mapping.xml:1113
#, no-c-format
msgid "Built-in bridges"
msgstr ""

#. Tag: para
#: mapping.xml:1115
#, no-c-format
msgid "Hibernate Search comes bundled with a set of built-in bridges between a Java property type and its full text representation."
msgstr ""

#. Tag: term
#: mapping.xml:1120
#, no-c-format
msgid "null"
msgstr ""

#. Tag: para
#: mapping.xml:1123
#, no-c-format
msgid "Per default <constant>null</constant> elements are not indexed. Lucene does not support null elements. However, in some situation it can be useful to insert a custom token representing the <constant>null</constant> value. See <xref lang=\"\" linkend=\"field-annotation\"/> for more information."
msgstr ""

#. Tag: term
#: mapping.xml:1132
#, no-c-format
msgid "java.lang.String"
msgstr ""

#. Tag: para
#: mapping.xml:1135
#, no-c-format
msgid "Strings are indexed as are"
msgstr ""

#. Tag: term
#: mapping.xml:1140
#, no-c-format
msgid "short, Short, integer, Integer, long, Long, float, Float, double, Double, BigInteger, BigDecimal"
msgstr ""

#. Tag: para
#: mapping.xml:1144
#, no-c-format
msgid "Numbers are converted into their string representation. Note that numbers cannot be compared by Lucene (ie used in ranged queries) out of the box: they have to be padded"
msgstr ""

#. Tag: para
#: mapping.xml:1147
#, no-c-format
msgid "Using a Range query is debatable and has drawbacks, an alternative approach is to use a Filter query which will filter the result query to the appropriate range."
msgstr ""

#. Tag: para
#: mapping.xml:1151
#, no-c-format
msgid "Hibernate Search will support a padding mechanism"
msgstr ""

#. Tag: term
#: mapping.xml:1157
#, no-c-format
msgid "java.util.Date"
msgstr ""

#. Tag: para
#: mapping.xml:1160
#, no-c-format
msgid "Dates are stored as yyyyMMddHHmmssSSS in GMT time (200611072203012 for Nov 7th of 2006 4:03PM and 12ms EST). You shouldn't really bother with the internal format. What is important is that when using a DateRange Query, you should know that the dates have to be expressed in GMT time."
msgstr ""

#. Tag: para
#: mapping.xml:1166
#, no-c-format
msgid "Usually, storing the date up to the millisecond is not necessary. <literal>@DateBridge</literal> defines the appropriate resolution you are willing to store in the index ( <literal> <literal>@DateBridge(resolution=Resolution.DAY)</literal> </literal> ). The date pattern will then be truncated accordingly."
msgstr ""

#. Tag: programlisting
#: mapping.xml:1173
#, no-c-format
msgid ""
      "@Entity \n"
      "@Indexed\n"
      "public class Meeting {\n"
      "    @Field(analyze=Analyze.NO)\n"
      "    <emphasis role=\"bold\">@DateBridge(resolution=Resolution.MINUTE)</emphasis>\n"
      "    private Date date;\n"
      "    ..."
msgstr ""

#. Tag: para
#: mapping.xml:1176
#, no-c-format
msgid "A Date whose resolution is lower than <literal>MILLISECOND</literal> cannot be a <literal>@DocumentId</literal>"
msgstr ""

#. Tag: term
#: mapping.xml:1184
#, no-c-format
msgid "java.net.URI, java.net.URL"
msgstr ""

#. Tag: para
#: mapping.xml:1187
#, no-c-format
msgid "URI and URL are converted to their string representation"
msgstr ""

#. Tag: term
#: mapping.xml:1193
#, no-c-format
msgid "java.lang.Class"
msgstr ""

#. Tag: para
#: mapping.xml:1196
#, no-c-format
msgid "Class are converted to their fully qualified class name. The thread context classloader is used when the class is rehydrated"
msgstr ""

#. Tag: title
#: mapping.xml:1205
#, no-c-format
msgid "Custom bridges"
msgstr ""

#. Tag: para
#: mapping.xml:1207
#, no-c-format
msgid "Sometimes, the built-in bridges of Hibernate Search do not cover some of your property types, or the String representation used by the bridge does not meet your requirements. The following paragraphs describe several solutions to this problem."
msgstr ""

#. Tag: title
#: mapping.xml:1213
#, no-c-format
msgid "StringBridge"
msgstr ""

#. Tag: para
#: mapping.xml:1215
#, no-c-format
msgid "The simplest custom solution is to give Hibernate Search an implementation of your expected <classname>Object</classname> to <classname>String</classname> bridge. To do so you need to implement the <literal>org.hibernate.search.bridge.StringBridge</literal> interface. All implementations have to be thread-safe as they are used concurrently."
msgstr ""

#. Tag: title
#: mapping.xml:1223
#, no-c-format
msgid "Custom <classname>StringBridge</classname> implementation"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1226
#, no-c-format
msgid ""
      "/**\n"
      " * Padding Integer bridge.\n"
      " * All numbers will be padded with 0 to match 5 digits\n"
      " *\n"
      " * @author Emmanuel Bernard\n"
      " */\n"
      "public class PaddedIntegerBridge implements <emphasis role=\"bold\">StringBridge</emphasis> {\n"
      "\n"
      "    private int PADDING = 5;\n"
      "\n"
      "    <emphasis role=\"bold\">public String objectToString(Object object)</emphasis> {\n"
      "        String rawInteger = ( (Integer) object ).toString();\n"
      "        if (rawInteger.length() &gt; PADDING) \n"
      "            throw new IllegalArgumentException( \"Try to pad on a number too big\" );\n"
      "        StringBuilder paddedInteger = new StringBuilder( );\n"
      "        for ( int padIndex = rawInteger.length() ; padIndex &lt; PADDING ; padIndex++ ) {\n"
      "            paddedInteger.append('0');\n"
      "        }\n"
      "        return paddedInteger.append( rawInteger ).toString();\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: mapping.xml:1229
#, no-c-format
msgid "Given the string bridge defined in <xref linkend=\"example-custom-string-bridge\"/>, any property or field can use this bridge thanks to the <literal>@FieldBridge</literal> annotation:"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1234
#, no-c-format
msgid ""
      "<emphasis role=\"bold\">@FieldBridge(impl = PaddedIntegerBridge.class)</emphasis>\n"
      "private Integer length;"
msgstr ""

#. Tag: title
#: mapping.xml:1237
#, no-c-format
msgid "Parameterized bridge"
msgstr ""

#. Tag: para
#: mapping.xml:1239
#, no-c-format
msgid "Parameters can also be passed to the bridge implementation making it more flexible. <xref linkend=\"example-passing-bridge-paremters\"/> implements a <classname>ParameterizedBridge</classname> interface and parameters are passed through the <literal>@FieldBridge</literal> annotation."
msgstr ""

#. Tag: title
#: mapping.xml:1247
#, no-c-format
msgid "Passing parameters to your bridge implementation"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1249
#, no-c-format
msgid ""
      "public class PaddedIntegerBridge implements StringBridge, <emphasis\n"
      "                role=\"bold\">ParameterizedBridge</emphasis> {\n"
      "\n"
      "    public static String PADDING_PROPERTY = \"padding\";\n"
      "    private int padding = 5; //default\n"
      "\n"
      "    <emphasis role=\"bold\">public void setParameterValues(Map parameters)</emphasis> {\n"
      "        Object padding = parameters.get( PADDING_PROPERTY );\n"
      "        if (padding != null) this.padding = (Integer) padding;\n"
      "    }\n"
      "\n"
      "    public String objectToString(Object object) {\n"
      "        String rawInteger = ( (Integer) object ).toString();\n"
      "        if (rawInteger.length() &gt; padding) \n"
      "            throw new IllegalArgumentException( \"Try to pad on a number too big\" );\n"
      "        StringBuilder paddedInteger = new StringBuilder( );\n"
      "        for ( int padIndex = rawInteger.length() ; padIndex &lt; padding ; padIndex++ ) {\n"
      "            paddedInteger.append('0');\n"
      "        }\n"
      "        return paddedInteger.append( rawInteger ).toString();\n"
      "    }\n"
      "}\n"
      "\n"
      "\n"
      "//property\n"
      "@FieldBridge(impl = PaddedIntegerBridge.class,\n"
      "             <emphasis role=\"bold\">params = @Parameter(name=\"padding\", value=\"10\")</emphasis>\n"
      "            )\n"
      "private Integer length;"
msgstr ""

#. Tag: para
#: mapping.xml:1252
#, no-c-format
msgid "The <classname>ParameterizedBridge</classname> interface can be implemented by <classname>StringBridge</classname>, <classname>TwoWayStringBridge</classname>, <classname>FieldBridge</classname> implementations."
msgstr ""

#. Tag: para
#: mapping.xml:1257
#, no-c-format
msgid "All implementations have to be thread-safe, but the parameters are set during initialization and no special care is required at this stage."
msgstr ""

#. Tag: title
#: mapping.xml:1263
#, no-c-format
msgid "Type aware bridge"
msgstr ""

#. Tag: para
#: mapping.xml:1265
#, no-c-format
msgid "It is sometimes useful to get the type the bridge is applied on:"
msgstr ""

#. Tag: para
#: mapping.xml:1270
#, no-c-format
msgid "the return type of the property for field/getter-level bridges"
msgstr ""

#. Tag: para
#: mapping.xml:1275
#, no-c-format
msgid "the class type for class-level bridges"
msgstr ""

#. Tag: para
#: mapping.xml:1279
#, no-c-format
msgid "An example is a bridge that deals with enums in a custom fashion but needs to access the actual enum type. Any bridge implementing <classname>AppliedOnTypeAwareBridge</classname> will get the type the bridge is applied on injected. Like parameters, the type injected needs no particular care with regard to thread-safety."
msgstr ""

#. Tag: title
#: mapping.xml:1288
#, no-c-format
msgid "Two-way bridge"
msgstr ""

#. Tag: para
#: mapping.xml:1290
#, no-c-format
msgid "If you expect to use your bridge implementation on an id property (ie annotated with <literal>@DocumentId</literal> ), you need to use a slightly extended version of <literal>StringBridge</literal> named <classname>TwoWayStringBridge</classname>. Hibernate Search needs to read the string representation of the identifier and generate the object out of it. There is no difference in the way the <literal>@FieldBridge</literal> annotation is used."
msgstr ""

#. Tag: title
#: mapping.xml:1300
#, no-c-format
msgid "Implementing a TwoWayStringBridge usable for id properties"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1303
#, no-c-format
msgid ""
      "public class PaddedIntegerBridge implements TwoWayStringBridge, ParameterizedBridge {\n"
      "\n"
      "    public static String PADDING_PROPERTY = \"padding\";\n"
      "    private int padding = 5; //default\n"
      "\n"
      "    public void setParameterValues(Map parameters) {\n"
      "        Object padding = parameters.get( PADDING_PROPERTY );\n"
      "        if (padding != null) this.padding = (Integer) padding;\n"
      "    }\n"
      "\n"
      "    public String objectToString(Object object) {\n"
      "        String rawInteger = ( (Integer) object ).toString();\n"
      "        if (rawInteger.length() &gt; padding) \n"
      "            throw new IllegalArgumentException( \"Try to pad on a number too big\" );\n"
      "        StringBuilder paddedInteger = new StringBuilder( );\n"
      "        for ( int padIndex = rawInteger.length() ; padIndex &lt; padding ; padIndex++ ) {\n"
      "            paddedInteger.append('0');\n"
      "        }\n"
      "        return paddedInteger.append( rawInteger ).toString();\n"
      "    }\n"
      "\n"
      "    <emphasis role=\"bold\">public Object stringToObject(String stringValue)</emphasis> {\n"
      "        return new Integer(stringValue);\n"
      "    }\n"
      "}\n"
      "\n"
      "\n"
      "//id property\n"
      "@DocumentId\n"
      "@FieldBridge(impl = PaddedIntegerBridge.class,\n"
      "             params = @Parameter(name=\"padding\", value=\"10\") \n"
      "private Integer id;"
msgstr ""

#. Tag: para
#: mapping.xml:1307
#, no-c-format
msgid "It is important for the two-way process to be idempotent (ie object = stringToObject( objectToString( object ) ) )."
msgstr ""

#. Tag: title
#: mapping.xml:1314
#, no-c-format
msgid "FieldBridge"
msgstr ""

#. Tag: para
#: mapping.xml:1316
#, no-c-format
msgid "Some use cases require more than a simple object to string translation when mapping a property to a Lucene index. To give you the greatest possible flexibility you can also implement a bridge as a <classname>FieldBridge</classname>. This interface gives you a property value and let you map it the way you want in your Lucene <classname>Document</classname>. You can for example store a property in two different document fields. The interface is very similar in its concept to the Hibernate <classname>UserType</classname>s."
msgstr ""

#. Tag: title
#: mapping.xml:1326
#, no-c-format
msgid "Implementing the FieldBridge interface"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1328
#, no-c-format
msgid ""
      "/**\n"
      " * Store the date in 3 different fields - year, month, day - to ease Range Query per\n"
      " * year, month or day (eg get all the elements of December for the last 5 years).\n"
      " * @author Emmanuel Bernard\n"
      " */\n"
      "public class DateSplitBridge implements FieldBridge {\n"
      "    private final static TimeZone GMT = TimeZone.getTimeZone(\"GMT\");\n"
      "\n"
      "    <emphasis role=\"bold\">public void set(String name, Object value, Document document, \n"
      "                    LuceneOptions luceneOptions)</emphasis> {\n"
      "        Date date = (Date) value;\n"
      "        Calendar cal = GregorianCalendar.getInstance(GMT);\n"
      "        cal.setTime(date);\n"
      "        int year = cal.get(Calendar.YEAR);\n"
      "        int month = cal.get(Calendar.MONTH) + 1;\n"
      "        int day = cal.get(Calendar.DAY_OF_MONTH);\n"
      "  \n"
      "        // set year\n"
      "        luceneOptions.addFieldToDocument(\n"
      "            name + \".year\",\n"
      "            String.valueOf( year ),\n"
      "            document );\n"
      "  \n"
      "        // set month and pad it if needed\n"
      "        luceneOptions.addFieldToDocument(\n"
      "            name + \".month\",\n"
      "            month &lt; 10 ? \"0\" : \"\" + String.valueOf( month ),\n"
      "            document );\n"
      "  \n"
      "        // set day and pad it if needed\n"
      "        luceneOptions.addFieldToDocument(\n"
      "            name + \".day\",\n"
      "            day &lt; 10 ? \"0\" : \"\" + String.valueOf( day ),\n"
      "            document );\n"
      "    }\n"
      "}\n"
      "\n"
      "//property\n"
      "<emphasis role=\"bold\">@FieldBridge(impl = DateSplitBridge.class)</emphasis>\n"
      "private Date date;"
msgstr ""

#. Tag: para
#: mapping.xml:1331
#, no-c-format
msgid "In <xref linkend=\"example-field-bridge\"/> the fields are not added directly to Document. Instead the addition is delegated to the <classname>LuceneOptions</classname> helper; this helper will apply the options you have selected on <literal>@Field</literal>, like <literal>Store</literal> or <literal>TermVector</literal>, or apply the choosen <classname>@Boost</classname> value. It is especially useful to encapsulate the complexity of <literal>COMPRESS</literal> implementations. Even though it is recommended to delegate to <classname>LuceneOptions</classname> to add fields to the <classname>Document</classname>, nothing stops you from editing the <classname>Document</classname> directly and ignore the <classname>LuceneOptions</classname> in case you need to."
msgstr ""

#. Tag: para
#: mapping.xml:1345
#, no-c-format
msgid "Classes like <classname>LuceneOptions</classname> are created to shield your application from changes in Lucene API and simplify your code. Use them if you can, but if you need more flexibility you're not required to."
msgstr ""

#. Tag: title
#: mapping.xml:1353
#, no-c-format
msgid "ClassBridge"
msgstr ""

#. Tag: para
#: mapping.xml:1355
#, no-c-format
msgid "It is sometimes useful to combine more than one property of a given entity and index this combination in a specific way into the Lucene index. The <classname>@ClassBridge</classname> respectively <classname>@ClassBridges</classname> annotations can be defined at class level (as opposed to the property level). In this case the custom field bridge implementation receives the entity instance as the value parameter instead of a particular property. Though not shown in <xref linkend=\"example-class-bridge\"/>, <classname>@ClassBridge</classname> supports the <methodname>termVector</methodname> attribute discussed in section <xref linkend=\"basic-mapping\"/>."
msgstr ""

#. Tag: title
#: mapping.xml:1368
#, no-c-format
msgid "Implementing a class bridge"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1370
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed\n"
      "<emphasis role=\"bold\">@ClassBridge</emphasis>(name=\"branchnetwork\",\n"
      "             store=Store.YES,\n"
      "             impl = <emphasis role=\"bold\">CatFieldsClassBridge.class</emphasis>,\n"
      "             params = @Parameter( name=\"sepChar\", value=\" \" ) )\n"
      "public class Department {\n"
      "    private int id;\n"
      "    private String network;\n"
      "    private String branchHead;\n"
      "    private String branch;\n"
      "    private Integer maxEmployees\n"
      "    ...\n"
      "}\n"
      "\n"
      "public class CatFieldsClassBridge implements FieldBridge, ParameterizedBridge {\n"
      "    private String sepChar;\n"
      "\n"
      "    public void setParameterValues(Map parameters) {\n"
      "        this.sepChar = (String) parameters.get( \"sepChar\" );\n"
      "    }\n"
      "\n"
      "    <emphasis role=\"bold\">public void set(\n"
      "        String name, Object value, Document document, LuceneOptions luceneOptions)</emphasis> {\n"
      "        // In this particular class the name of the new field was passed\n"
      "        // from the name field of the ClassBridge Annotation. This is not\n"
      "        // a requirement. It just works that way in this instance. The\n"
      "        // actual name could be supplied by hard coding it below.\n"
      "        Department dep = (Department) value;\n"
      "        String fieldValue1 = dep.getBranch();\n"
      "        if ( fieldValue1 == null ) {\n"
      "            fieldValue1 = \"\";\n"
      "        }\n"
      "        String fieldValue2 = dep.getNetwork();\n"
      "        if ( fieldValue2 == null ) {\n"
      "            fieldValue2 = \"\";\n"
      "        }\n"
      "        String fieldValue = fieldValue1 + sepChar + fieldValue2;\n"
      "        Field field = new Field( name, fieldValue, luceneOptions.getStore(),\n"
      "            luceneOptions.getIndex(), luceneOptions.getTermVector() );\n"
      "        field.setBoost( luceneOptions.getBoost() );\n"
      "        document.add( field );\n"
      "   }\n"
      "}"
msgstr ""

#. Tag: para
#: mapping.xml:1373
#, no-c-format
msgid "In this example, the particular <classname>CatFieldsClassBridge</classname> is applied to the <literal>department</literal> instance, the field bridge then concatenate both branch and network and index the concatenation."
msgstr ""

#. Tag: title
#: mapping.xml:1383 mapping.xml:1409
#, no-c-format
msgid "Providing your own id"
msgstr ""

#. Tag: para
#: mapping.xml:1386
#, no-c-format
msgid "This part of the documentation is a work in progress."
msgstr ""

#. Tag: para
#: mapping.xml:1389
#, no-c-format
msgid "You can provide your own id for Hibernate Search if you are extending the internals. You will have to generate a unique value so it can be given to Lucene to be indexed. This will have to be given to Hibernate Search when you create an org.hibernate.search.Work object - the document id is required in the constructor."
msgstr ""

#. Tag: title
#: mapping.xml:1396
#, no-c-format
msgid "The ProvidedId annotation"
msgstr ""

#. Tag: para
#: mapping.xml:1398
#, no-c-format
msgid "Unlike <classname>@DocumentId</classname>which is applied on field level, <classname>@ProvidedId</classname> is used on the class level. Optionally you can specify your own bridge implementation using the <constant>bridge</constant> property. Also, if you annotate a class with <classname>@ProvidedId</classname>, your subclasses will also get the annotation - but it is not done by using the java.lang.annotations.@Inherited. Be sure however, to <emphasis>not</emphasis> use this annotation with @DocumentId as your system will break."
msgstr ""

#. Tag: programlisting
#: mapping.xml:1411
#, no-c-format
msgid ""
      "@ProvidedId (bridge = org.my.own.package.MyCustomBridge)\n"
      "@Indexed\n"
      "public class MyClass{\n"
      "    @Field\n"
      "    String MyString;\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: title
#: mapping.xml:1417
#, no-c-format
msgid "Programmatic API"
msgstr ""

#. Tag: para
#: mapping.xml:1420
#, no-c-format
msgid "This feature is considered experimental. While stable code-wise, the API is subject to change in the future."
msgstr ""

#. Tag: para
#: mapping.xml:1421
#, no-c-format
msgid "Although the recommended approach for mapping indexed entities is to use annotations, it is sometimes more convenient to use a different approach:"
msgstr ""

#. Tag: para
#: mapping.xml:1428
#, no-c-format
msgid "the same entity is mapped differently depending on deployment needs (customization for clients)"
msgstr ""

#. Tag: para
#: mapping.xml:1433
#, no-c-format
msgid "some automatization process requires the dynamic mapping of many entities sharing common traits"
msgstr ""

#. Tag: para
#: mapping.xml:1438
#, no-c-format
msgid "While it has been a popular demand in the past, the Hibernate team never found the idea of an XML alternative to annotations appealing due to it's heavy duplication, lack of code refactoring safety, because it did not cover all the use case spectrum and because we are in the 21st century :)"
msgstr ""

#. Tag: para
#: mapping.xml:1444
#, no-c-format
msgid "The idea of a programmatic API was much more appealing and has now become a reality. You can programmatically define your mapping using a programmatic API: you define entities and fields as indexable by using mapping classes which effectively mirror the annotation concepts in Hibernate Search. Note that fan(s) of XML approach can design their own schema and use the programmatic API to create the mapping while parsing the XML stream."
msgstr ""

#. Tag: para
#: mapping.xml:1452
#, no-c-format
msgid "In order to use the programmatic model you must first construct a <classname>SearchMapping</classname> object which you can do in two ways:"
msgstr ""

#. Tag: para
#: mapping.xml:1458
#, no-c-format
msgid "directly"
msgstr ""

#. Tag: para
#: mapping.xml:1462
#, no-c-format
msgid "via a factory"
msgstr ""

#. Tag: para
#: mapping.xml:1466
#, no-c-format
msgid "You can pass the <classname>SearchMapping</classname> object directly via the property key <literal>hibernate.search.model_mapping</literal> or its type-safe representation <classname>Environment.MODEL_MAPPING</classname>. Use the <classname>Configuration</classname> API or the Map passed to the JPA <classname>Persistence</classname> bootstrap methods."
msgstr ""

#. Tag: programlisting
#: mapping.xml:1473
#, no-c-format
msgid ""
      "SearchMapping mapping = new SearchMapping();\n"
      "[...]\n"
      "configuration.setProperty( Environment.MODEL_MAPPING, mapping );\n"
      "\n"
      "//or in JPA\n"
      "SearchMapping mapping = new SearchMapping();\n"
      "[...]\n"
      "Map&lt;String,String&gt; properties = new HashMap&lt;String,String)(1);\n"
      "properties.put( Environment.MODEL_MAPPING, mapping );\n"
      "EntityManagerFactory emf = Persistence.createEntityManagerFactory( \"userPU\", properties );"
msgstr ""

#. Tag: para
#: mapping.xml:1475
#, no-c-format
msgid "Alternatively, you can create a factory class (ie. hosting a method annotated with <classname>@Factory</classname>) whose factory method returns the <classname>SearchMapping</classname> object. The factory class must have a no-arg constructor and its fully qualified class name is passed to the property key <literal>hibernate.search.model_mapping</literal> or its type-safe representation <classname>Environment.MODEL_MAPPING</classname>. This approach is useful when you do not necessarily control the bootstrap process like in a Java EE, CDI or Spring Framework container."
msgstr ""

#. Tag: title
#: mapping.xml:1486
#, no-c-format
msgid "Use a mapping factory"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1488
#, no-c-format
msgid ""
      "public class MyAppSearchMappingFactory {\n"
      "    @Factory\n"
      "    public SearchMapping getSearchMapping() {\n"
      "        SearchMapping mapping = new SearchMapping();\n"
      "        mapping\n"
      "                .analyzerDef( \"ngram\", StandardTokenizerFactory.class )\n"
      "                    .filter( LowerCaseFilterFactory.class )\n"
      "                    .filter( NGramFilterFactory.class )\n"
      "                        .param( \"minGramSize\", \"3\" )\n"
      "                        .param( \"maxGramSize\", \"3\" );\n"
      "        return mapping;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1490
#, no-c-format
msgid ""
      "&lt;persistence ...&gt;\n"
      "    &lt;persistence-unit name=\"users\"&gt;\n"
      "        ...\n"
      "        &lt;properties&gt;\n"
      "            &lt;property name=\"hibernate.search.model_mapping\"\n"
      "                      value=\"com.acme.MyAppSearchMappingFactory\"/&gt;\n"
      "        &lt;/properties&gt;\n"
      "    &lt;/persistence-unit&gt;\n"
      "&lt;/persistence&gt;"
msgstr ""

#. Tag: para
#: mapping.xml:1493
#, no-c-format
msgid "The <classname>SearchMapping</classname> is the root object which contains all the necessary indexable entities and fields. From there, the <classname>SearchMapping</classname> object exposes a fluent (and thus intuitive) API to express your mappings: it contextually exposes the relevant mapping options in a type-safe way. Just let your IDE autocompletion feature guide you through."
msgstr ""

#. Tag: para
#: mapping.xml:1500
#, no-c-format
msgid "Today, the programmatic API cannot be used on a class annotated with Hibernate Search annotations, chose one approach or the other. Also note that the same default values apply in annotations and the programmatic API. For example, the <methodname>@Field.name</methodname> is defaulted to the property name and does not have to be set."
msgstr ""

#. Tag: para
#: mapping.xml:1506
#, no-c-format
msgid "Each core concept of the programmatic API has a corresponding example to depict how the same definition would look using annotation. Therefore seeing an annotation example of the programmatic approach should give you a clear picture of what Hibernate Search will build with the marked entities and associated properties."
msgstr ""

#. Tag: title
#: mapping.xml:1513
#, no-c-format
msgid "Mapping an entity as indexable"
msgstr ""

#. Tag: para
#: mapping.xml:1515
#, no-c-format
msgid "The first concept of the programmatic API is to define an entity as indexable. Using the annotation approach a user would mark the entity as <classname>@Indexed</classname>, the following example demonstrates how to programmatically achieve this."
msgstr ""

#. Tag: title
#: mapping.xml:1521
#, no-c-format
msgid "Marking an entity indexable"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1523
#, no-c-format
msgid ""
      "SearchMapping mapping = new SearchMapping();\n"
      "\n"
      "mapping.entity(Address.class)\n"
      "           .indexed()\n"
      "               .indexName(\"Address_Index\"); //optional\n"
      "\n"
      "cfg.getProperties().put( \"hibernate.search.model_mapping\", mapping );"
msgstr ""

#. Tag: para
#: mapping.xml:1526
#, no-c-format
msgid "As you can see you must first create a <classname>SearchMapping</classname> object which is the root object that is then passed to the <classname>Configuration</classname> object as property. You must declare an entity and if you wish to make that entity as indexable then you must call the <methodname>indexed()</methodname> method. The <methodname>indexed() </methodname>method has an optional <methodname>indexName(String indexName)</methodname> which can be used to change the default index name that is created by Hibernate Search. Using the annotation model the above can be achieved as:"
msgstr ""

#. Tag: title
#: mapping.xml:1538
#, no-c-format
msgid "Annotation example of indexing entity"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1540
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed(index=\"Address_Index\")\n"
      "public class Address {\n"
      "....\n"
      "}"
msgstr ""

#. Tag: title
#: mapping.xml:1545
#, no-c-format
msgid "Adding DocumentId to indexed entity"
msgstr ""

#. Tag: para
#: mapping.xml:1547
#, no-c-format
msgid "To set a property as a document id:"
msgstr ""

#. Tag: title
#: mapping.xml:1550
#, no-c-format
msgid "Enabling document id with programmatic model"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1552
#, no-c-format
msgid ""
      "SearchMapping mapping = new SearchMapping();\n"
      "\n"
      "mapping.entity(Address.class).indexed()\n"
      "           .property(\"addressId\", ElementType.FIELD) //field access\n"
      "               .documentId()\n"
      "                   .name(\"id\");\n"
      "\n"
      "cfg.getProperties().put( \"hibernate.search.model_mapping\", mapping);"
msgstr ""

#. Tag: para
#: mapping.xml:1555
#, no-c-format
msgid "The above is equivalent to annotating a property in the entity as <classname>@DocumentId</classname> as seen in the following example:"
msgstr ""

#. Tag: title
#: mapping.xml:1560
#, no-c-format
msgid "DocumentId annotation definition"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1562
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed\n"
      "public class Address {\n"
      " @Id\n"
      " @GeneratedValue\n"
      " @DocumentId(name=\"id\")\n"
      " private Long addressId;\n"
      "\n"
      " ....\n"
      "}"
msgstr ""

#. Tag: para
#: mapping.xml:1564
#, no-c-format
msgid "The next section demonstrates how to programmatically define analyzers."
msgstr ""

#. Tag: title
#: mapping.xml:1570
#, no-c-format
msgid "Defining analyzers"
msgstr ""

#. Tag: para
#: mapping.xml:1572
#, no-c-format
msgid "Analyzers can be programmatically defined using the <methodname>analyzerDef(String analyzerDef, Class&lt;? extends TokenizerFactory&gt; tokenizerFactory) </methodname>method. This method also enables you to define filters for the analyzer definition. Each filter that you define can optionally take in parameters as seen in the following example :"
msgstr ""

#. Tag: title
#: mapping.xml:1580
#, no-c-format
msgid "Defining analyzers using programmatic model"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1582
#, no-c-format
msgid ""
      "SearchMapping mapping = new SearchMapping();\n"
      "\n"
      "mapping\n"
      "    <emphasis role=\"bold\">.analyzerDef( \"ngram\", StandardTokenizerFactory.class )\n"
      "        .filter( LowerCaseFilterFactory.class )\n"
      "        .filter( NGramFilterFactory.class )\n"
      "            .param( \"minGramSize\", \"3\" )\n"
      "            .param( \"maxGramSize\", \"3\" )\n"
      "    .analyzerDef( \"en\", StandardTokenizerFactory.class )\n"
      "        .filter( LowerCaseFilterFactory.class )\n"
      "        .filter( EnglishPorterFilterFactory.class )\n"
      "    .analyzerDef( \"de\", StandardTokenizerFactory.class )\n"
      "        .filter( LowerCaseFilterFactory.class )\n"
      "        .filter( GermanStemFilterFactory.class )</emphasis>\n"
      "    .entity(Address.class).indexed()\n"
      "        .property(\"addressId\", ElementType.METHOD) //getter access\n"
      "            .documentId()\n"
      "                .name(\"id\");\n"
      "\n"
      "cfg.getProperties().put( \"hibernate.search.model_mapping\", mapping );"
msgstr ""

#. Tag: para
#: mapping.xml:1585
#, no-c-format
msgid "The analyzer mapping defined above is equivalent to the annotation model using <classname>@AnalyzerDef</classname> in conjunction with <classname>@AnalyzerDefs</classname>:"
msgstr ""

#. Tag: title
#: mapping.xml:1590
#, no-c-format
msgid "Analyzer definition using annotation"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1592
#, no-c-format
msgid ""
      "@Indexed\n"
      "@Entity\n"
      "@AnalyzerDefs({\n"
      "  @AnalyzerDef(name = \"ngram\",\n"
      "    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),\n"
      "    filters = {\n"
      "      @TokenFilterDef(factory = LowerCaseFilterFactory.class),\n"
      "      @TokenFilterDef(factory = NGramFilterFactory.class, \n"
      "        params = {\n"
      "          @Parameter(name = \"minGramSize\",value = \"3\"),\n"
      "          @Parameter(name = \"maxGramSize\",value = \"3\") \n"
      "       })\n"
      "   }),\n"
      "  @AnalyzerDef(name = \"en\",\n"
      "    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),\n"
      "    filters = {\n"
      "      @TokenFilterDef(factory = LowerCaseFilterFactory.class),\n"
      "      @TokenFilterDef(factory = EnglishPorterFilterFactory.class)\n"
      "   }),\n"
      "\n"
      "  @AnalyzerDef(name = \"de\",\n"
      "    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),\n"
      "    filters = {\n"
      "      @TokenFilterDef(factory = LowerCaseFilterFactory.class),\n"
      "      @TokenFilterDef(factory = GermanStemFilterFactory.class)\n"
      "  })\n"
      "\n"
      "})\n"
      "public class Address {\n"
      "...\n"
      "}"
msgstr ""

#. Tag: title
#: mapping.xml:1597
#, no-c-format
msgid "Defining full text filter definitions"
msgstr ""

#. Tag: para
#: mapping.xml:1599
#, no-c-format
msgid "The programmatic API provides easy mechanism for defining full text filter definitions which is available via <classname>@FullTextFilterDef</classname> and <classname>@FullTextFilterDefs</classname> (see <xref linkend=\"query-filter\"/>). The next example depicts the creation of full text filter definition using the <methodname>fullTextFilterDef </methodname>method."
msgstr ""

#. Tag: title
#: mapping.xml:1608
#, no-c-format
msgid "Defining full text definition programmatically"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1610
#, no-c-format
msgid ""
      "SearchMapping mapping = new SearchMapping();\n"
      "\n"
      "mapping\n"
      "    .analyzerDef( \"en\", StandardTokenizerFactory.class )\n"
      "        .filter( LowerCaseFilterFactory.class )\n"
      "        .filter( EnglishPorterFilterFactory.class )\n"
      "    <emphasis role=\"bold\">.fullTextFilterDef(\"security\", SecurityFilterFactory.class)\n"
      "            .cache(FilterCacheModeType.INSTANCE_ONLY)</emphasis>\n"
      "    .entity(Address.class)\n"
      "        .indexed()\n"
      "        .property(\"addressId\", ElementType.METHOD)\n"
      "            .documentId()\n"
      "                .name(\"id\")\n"
      "        .property(\"street1\", ElementType.METHOD)\n"
      "            .field()\n"
      "                .analyzer(\"en\")\n"
      "                .store(Store.YES)\n"
      "            .field()\n"
      "                .name(\"address_data\")\n"
      "                .analyzer(\"en\")\n"
      "                .store(Store.NO);\n"
      "\n"
      "cfg.getProperties().put( \"hibernate.search.model_mapping\", mapping );"
msgstr ""

#. Tag: para
#: mapping.xml:1613
#, no-c-format
msgid "The previous example can effectively been seen as annotating your entity with <classname>@FullTextFilterDef</classname> like below:"
msgstr ""

#. Tag: title
#: mapping.xml:1617
#, no-c-format
msgid "Using annotation to define full text filter definition"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1619
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed\n"
      "@AnalyzerDefs({\n"
      "  @AnalyzerDef(name = \"en\",\n"
      "    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),\n"
      "    filters = {\n"
      "      @TokenFilterDef(factory = LowerCaseFilterFactory.class),\n"
      "      @TokenFilterDef(factory = EnglishPorterFilterFactory.class)\n"
      "   })\n"
      "})\n"
      "@FullTextFilterDefs({\n"
      " @FullTextFilterDef(name = \"security\", impl = SecurityFilterFactory.class, cache = FilterCacheModeType.INSTANCE_ONLY)\n"
      "})\n"
      "public class Address {\n"
      " \n"
      " @Id\n"
      " @GeneratedValue\n"
      " @DocumentId(name=\"id\")\n"
      " pubblic Long getAddressId() {...};\n"
      "\n"
      " @Fields({\n"
      "      @Field(store=Store.YES, analyzer=@Analyzer(definition=\"en\")),\n"
      "      @Field(name=\"address_data\", analyzer=@Analyzer(definition=\"en\"))\n"
      " })\n"
      " public String getAddress1() {...};\n"
      "\n"
      " ......\n"
      " \n"
      "}"
msgstr ""

#. Tag: title
#: mapping.xml:1624
#, no-c-format
msgid "Defining fields for indexing"
msgstr ""

#. Tag: para
#: mapping.xml:1626
#, no-c-format
msgid "When defining fields for indexing using the programmatic API, call <methodname>field()</methodname> on the <methodname>property(String propertyName, ElementType elementType)</methodname> method. From <methodname>field()</methodname> you can specify the <methodname>name, index</methodname>, <methodname>store</methodname>, <methodname>bridge</methodname> and <methodname>analyzer</methodname> definitions."
msgstr ""

#. Tag: title
#: mapping.xml:1635
#, no-c-format
msgid "Indexing fields using programmatic API"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1637
#, no-c-format
msgid ""
      "SearchMapping mapping = new SearchMapping();\n"
      "\n"
      "mapping\n"
      "    .analyzerDef( \"en\", StandardTokenizerFactory.class )\n"
      "        .filter( LowerCaseFilterFactory.class )\n"
      "        .filter( EnglishPorterFilterFactory.class )\n"
      "    .entity(Address.class).indexed()\n"
      "        .property(\"addressId\", ElementType.METHOD)\n"
      "            .documentId()\n"
      "                .name(\"id\")\n"
      "        .property(\"street1\", ElementType.METHOD)\n"
      "            <emphasis role=\"bold\">.field()\n"
      "                .analyzer(\"en\")\n"
      "                .store(Store.YES)\n"
      "            .field()\n"
      "                .name(\"address_data\")\n"
      "                .analyzer(\"en\");</emphasis>\n"
      "\n"
      "cfg.getProperties().put( \"hibernate.search.model_mapping\", mapping );"
msgstr ""

#. Tag: para
#: mapping.xml:1640
#, no-c-format
msgid "The above example of marking fields as indexable is equivalent to defining fields using <classname>@Field</classname> as seen below:"
msgstr ""

#. Tag: title
#: mapping.xml:1645
#, no-c-format
msgid "Indexing fields using annotation"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1647
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed\n"
      "@AnalyzerDefs({\n"
      "  @AnalyzerDef(name = \"en\",\n"
      "    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),\n"
      "    filters = {\n"
      "      @TokenFilterDef(factory = LowerCaseFilterFactory.class),\n"
      "      @TokenFilterDef(factory = EnglishPorterFilterFactory.class)\n"
      "   })\n"
      "})\n"
      "public class Address {\n"
      " \n"
      " @Id\n"
      " @GeneratedValue\n"
      " @DocumentId(name=\"id\")\n"
      " private Long getAddressId() {...};\n"
      "\n"
      " @Fields({\n"
      "      @Field(store=Store.YES, analyzer=@Analyzer(definition=\"en\")),\n"
      "      @Field(name=\"address_data\", analyzer=@Analyzer(definition=\"en\"))\n"
      " })\n"
      " public String getAddress1() {...}\n"
      "\n"
      " ......\n"
      "}"
msgstr ""

#. Tag: title
#: mapping.xml:1652
#, no-c-format
msgid "Programmatically defining embedded entities"
msgstr ""

#. Tag: para
#: mapping.xml:1654
#, no-c-format
msgid "In this section you will see how to programmatically define entities to be embedded into the indexed entity similar to using the <classname>@IndexEmbedded</classname> model. In order to define this you must mark the property as <methodname>indexEmbedded.</methodname>There is the option to add a prefix to the embedded entity definition which can be done by calling <methodname>prefix</methodname> as seen in the example below:"
msgstr ""

#. Tag: title
#: mapping.xml:1663
#, no-c-format
msgid "Programmatically defining embedded entites"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1665
#, no-c-format
msgid ""
      "SearchMapping mapping = new SearchMapping();\n"
      "\n"
      "mappping\n"
      "    .entity(ProductCatalog.class)\n"
      "        .indexed()\n"
      "        .property(\"catalogId\", ElementType.METHOD)\n"
      "            .documentId()\n"
      "                .name(\"id\")\n"
      "        .property(\"title\", ElementType.METHOD)\n"
      "            .field()\n"
      "                .index(Index.YES)\n"
      "                .store(Store.NO)\n"
      "        .property(\"description\", ElementType.METHOD)\n"
      "             .field()\n"
      "                 .index(Index.YES)\n"
      "                 .store(Store.NO)\n"
      "        .property(\"items\", ElementType.METHOD)\n"
      "            <emphasis role=\"bold\">.indexEmbedded()\n"
      "                .prefix(\"catalog.items\"); //optional</emphasis>\n"
      "\n"
      "cfg.getProperties().put( \"hibernate.search.model_mapping\", mapping );"
msgstr ""

#. Tag: para
#: mapping.xml:1668
#, no-c-format
msgid "The next example shows the same definition using annotation (<classname>@IndexEmbedded</classname>):"
msgstr ""

#. Tag: title
#: mapping.xml:1672
#, no-c-format
msgid "Using @IndexEmbedded"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1674
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed\n"
      "public class ProductCatalog {\n"
      " @Id\n"
      " @GeneratedValue\n"
      " @DocumentId(name=\"id\")\n"
      " public Long getCatalogId() {...}\n"
      " \n"
      " @Field\n"
      " public String getTitle() {...}\n"
      "\n"
      " @Field\n"
      " public String getDescription();\n"
      " \n"
      " @OneToMany(fetch = FetchType.LAZY)\n"
      " @IndexColumn(name = \"list_position\")\n"
      " @Cascade(org.hibernate.annotations.CascadeType.ALL)\n"
      " @IndexEmbedded(prefix=\"catalog.items\")\n"
      " public List&lt;Item&gt; getItems() {...}\n"
      "\n"
      " ...\n"
      "\n"
      "}"
msgstr ""

#. Tag: title
#: mapping.xml:1679
#, no-c-format
msgid "Contained In definition"
msgstr ""

#. Tag: para
#: mapping.xml:1681
#, no-c-format
msgid "<classname>@ContainedIn</classname> can be define as seen in the example below:"
msgstr ""

#. Tag: title
#: mapping.xml:1685
#, no-c-format
msgid "Programmatically defining ContainedIn"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1687
#, no-c-format
msgid ""
      "SearchMapping mapping = new SearchMapping();\n"
      "\n"
      "mappping\n"
      "    .entity(ProductCatalog.class)\n"
      "        .indexed()\n"
      "        .property(\"catalogId\", ElementType.METHOD)\n"
      "            .documentId()\n"
      "        .property(\"title\", ElementType.METHOD)\n"
      "            .field()\n"
      "        .property(\"description\", ElementType.METHOD)\n"
      "            .field()\n"
      "        .property(\"items\", ElementType.METHOD)\n"
      "            .indexEmbedded()\n"
      "\n"
      "    .entity(Item.class)\n"
      "        .property(\"description\", ElementType.METHOD)\n"
      "            .field()\n"
      "        .property(\"productCatalog\", ElementType.METHOD)\n"
      "            <emphasis role=\"bold\">.containedIn()</emphasis>;\n"
      "\n"
      "cfg.getProperties().put( \"hibernate.search.model_mapping\", mapping );"
msgstr ""

#. Tag: para
#: mapping.xml:1690
#, no-c-format
msgid "This is equivalent to defining <classname>@ContainedIn</classname> in your entity:"
msgstr ""

#. Tag: title
#: mapping.xml:1694
#, no-c-format
msgid "Annotation approach for ContainedIn"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1696
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed\n"
      "public class ProductCatalog {\n"
      " \n"
      " @Id\n"
      " @GeneratedValue\n"
      " @DocumentId\n"
      " public Long getCatalogId() {...}\n"
      " \n"
      " @Field\n"
      " public String getTitle() {...}\n"
      "\n"
      " @Field\n"
      " public String getDescription() {...}\n"
      " \n"
      " @OneToMany(fetch = FetchType.LAZY)\n"
      " @IndexColumn(name = \"list_position\")\n"
      " @Cascade(org.hibernate.annotations.CascadeType.ALL)\n"
      " @IndexEmbedded\n"
      " private List&lt;Item&gt; getItems() {...}\n"
      "\n"
      " ...\n"
      "}\n"
      "\n"
      "@Entity\n"
      "public class Item {\n"
      " \n"
      " @Id\n"
      " @GeneratedValue\n"
      " private Long itemId;\n"
      "\n"
      " @Field\n"
      " public String getDescription() {...}\n"
      " \n"
      " @ManyToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )\n"
      " @ContainedIn\n"
      " public ProductCatalog getProductCatalog() {...}\n"
      "\n"
      " ...\n"
      "}"
msgstr ""

#. Tag: title
#: mapping.xml:1701
#, no-c-format
msgid "Date/Calendar Bridge"
msgstr ""

#. Tag: para
#: mapping.xml:1703
#, no-c-format
msgid "In order to define a calendar or date bridge mapping, call the <methodname>dateBridge(Resolution resolution) </methodname>or <methodname>calendarBridge(Resolution resolution)</methodname> methods after you have defined a <methodname>field()</methodname> in the <classname>SearchMapping </classname>hierarchy."
msgstr ""

#. Tag: title
#: mapping.xml:1710
#, no-c-format
msgid "Programmatic model for defining calendar/date bridge"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1712
#, no-c-format
msgid ""
      "SearchMapping mapping = new SearchMapping();\n"
      "\n"
      "mapping\n"
      "    .entity(Address.class)\n"
      "        .indexed()\n"
      "        .property(\"addressId\", ElementType.FIELD)\n"
      "            .documentId()\n"
      "    .property(\"street1\", ElementType.FIELD()\n"
      "        .field()\n"
      "    .property(\"createdOn\", ElementType.FIELD)\n"
      "        .field()\n"
      "        <emphasis role=\"bold\">.dateBridge(Resolution.DAY)</emphasis>\n"
      "    .property(\"lastUpdated\", ElementType.FIELD)\n"
      "        <emphasis role=\"bold\">.calendarBridge(Resolution.DAY)</emphasis>;\n"
      "\n"
      "cfg.getProperties().put( \"hibernate.search.model_mapping\", mapping );"
msgstr ""

#. Tag: para
#: mapping.xml:1715
#, no-c-format
msgid "See below for defining the above using <classname>@CalendarBridge</classname> and <classname>@DateBridge</classname>:"
msgstr ""

#. Tag: title
#: mapping.xml:1720
#, no-c-format
msgid "@CalendarBridge and @DateBridge definition"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1722
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed\n"
      "public class Address {\n"
      " \n"
      " @Id\n"
      " @GeneratedValue\n"
      " @DocumentId\n"
      " private Long addressId;\n"
      "\n"
      " @Field\n"
      " private String address1;\n"
      "\n"
      " @Field\n"
      " @DateBridge(resolution=Resolution.DAY)\n"
      " private Date createdOn;\n"
      "\n"
      " @CalendarBridge(resolution=Resolution.DAY)\n"
      " private Calendar lastUpdated;\n"
      "\n"
      " ...\n"
      "}"
msgstr ""

#. Tag: title
#: mapping.xml:1727
#, no-c-format
msgid "Defining bridges"
msgstr ""

#. Tag: para
#: mapping.xml:1729
#, no-c-format
msgid "It is possible to associate bridges to programmatically defined fields. When you define a <methodname>field()</methodname> programmatically you can use the <methodname>bridge(Class&lt;?&gt; impl)</methodname> to associate a <classname>FieldBridge </classname>implementation class. The bridge method also provides optional methods to include any parameters required for the bridge class. The below shows an example of programmatically defining a bridge:"
msgstr ""

#. Tag: title
#: mapping.xml:1739
#, no-c-format
msgid "Defining field bridges programmatically"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1741
#, no-c-format
msgid ""
      "SearchMapping mapping = new SearchMapping();\n"
      "\n"
      "mapping\n"
      "    .entity(Address.class)\n"
      "        .indexed()\n"
      "        .property(\"addressId\", ElementType.FIELD)\n"
      "            .documentId()\n"
      "        .property(\"street1\", ElementType.FIELD)\n"
      "            .field()\n"
      "            .field()\n"
      "                .name(\"street1_abridged\")\n"
      "                <emphasis role=\"bold\">.bridge( ConcatStringBridge.class )\n"
      "                    .param( \"size\", \"4\" )</emphasis>;\n"
      " \n"
      "cfg.getProperties().put( \"hibernate.search.model_mapping\", mapping );"
msgstr ""

#. Tag: para
#: mapping.xml:1744
#, no-c-format
msgid "The above can equally be defined using annotations, as seen in the next example."
msgstr ""

#. Tag: title
#: mapping.xml:1748
#, no-c-format
msgid "Defining field bridges using annotation"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1750
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed\n"
      "public class Address {\n"
      " \n"
      " @Id\n"
      " @GeneratedValue\n"
      " @DocumentId(name=\"id\")\n"
      " private Long addressId;\n"
      "\n"
      " @Fields({\n"
      "      @Field,\n"
      "      @Field(name=\"street1_abridged\", \n"
      "             bridge = @FieldBridge( impl = ConcatStringBridge.class, \n"
      "             params = @Parameter( name=\"size\", value=\"4\" ))\n"
      " })\n"
      " private String address1;\n"
      "\n"
      " ...\n"
      "}"
msgstr ""

#. Tag: title
#: mapping.xml:1755
#, no-c-format
msgid "Mapping class bridge"
msgstr ""

#. Tag: para
#: mapping.xml:1757
#, no-c-format
msgid "You can define class bridges on entities programmatically. This is shown in the next example:"
msgstr ""

#. Tag: title
#: mapping.xml:1761
#, no-c-format
msgid "Defining class briges using API"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1763
#, no-c-format
msgid ""
      "SearchMapping mapping = new SearchMapping();\n"
      "\n"
      "mapping\n"
      "    .entity(Departments.class)\n"
      "<emphasis>       .classBridge(CatDeptsFieldsClassBridge.class)\n"
      "         .name(\"branchnetwork\")\n"
      "         .index(Index.YES)\n"
      "         .store(Store.YES)\n"
      "         .param(\"sepChar\", \" \")\n"
      "      .classBridge(EquipmentType.class)\n"
      "         .name(\"equiptype\")\n"
      "         .index(Index.YES)\n"
      "         .store(Store.YES)\n"
      "         .param(\"C\", \"Cisco\")\n"
      "         .param(\"D\", \"D-Link\")\n"
      "         .param(\"K\", \"Kingston\")\n"
      "         .param(\"3\", \"3Com\")</emphasis>\n"
      "      .indexed();\n"
      "\n"
      "cfg.getProperties().put( \"hibernate.search.model_mapping\", mapping );"
msgstr ""

#. Tag: para
#: mapping.xml:1766
#, no-c-format
msgid "The above is similar to using <classname>@ClassBridge </classname>as seen in the next example:"
msgstr ""

#. Tag: title
#: mapping.xml:1770
#, no-c-format
msgid "Using @ClassBridge"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1772
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed\n"
      "@ClassBridges ( {\n"
      "  @ClassBridge(name=\"branchnetwork\",\n"
      "     store= Store.YES,\n"
      "     impl = CatDeptsFieldsClassBridge.class,\n"
      "     params = @Parameter( name=\"sepChar\", value=\" \" ) ),\n"
      "  @ClassBridge(name=\"equiptype\",\n"
      "     store= Store.YES,\n"
      "     impl = EquipmentType.class,\n"
      "     params = {@Parameter( name=\"C\", value=\"Cisco\" ),\n"
      "        @Parameter( name=\"D\", value=\"D-Link\" ),\n"
      "        @Parameter( name=\"K\", value=\"Kingston\" ),\n"
      "        @Parameter( name=\"3\", value=\"3Com\" )\n"
      "   })\n"
      "})\n"
      "public class Departments {\n"
      "\n"
      "....\n"
      "}"
msgstr ""

#. Tag: title
#: mapping.xml:1777
#, no-c-format
msgid "Mapping dynamic boost"
msgstr ""

#. Tag: para
#: mapping.xml:1779
#, no-c-format
msgid "You can apply a dynamic boost factor on either a field or a whole entity:"
msgstr ""

#. Tag: title
#: mapping.xml:1783
#, no-c-format
msgid "DynamicBoost mapping using programmatic model"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1785
#, no-c-format
msgid ""
      "SearchMapping mapping = new SearchMapping();\n"
      "\n"
      "mapping\n"
      "  .entity(DynamicBoostedDescLibrary.class)\n"
      "   .indexed()\n"
      "   <emphasis>.dynamicBoost(CustomBoostStrategy.class)</emphasis>\n"
      "  .property(\"libraryId\", ElementType.FIELD)\n"
      "    .documentId().name(\"id\")\n"
      "  .property(\"name\", ElementType.FIELD)\n"
      "    <emphasis>.dynamicBoost(CustomFieldBoostStrategy.class)</emphasis>;\n"
      "    .field()\n"
      "      .store(Store.YES)\n"
      "\n"
      "cfg.getProperties().put( \"hibernate.search.model_mapping\", mapping );"
msgstr ""

#. Tag: para
#: mapping.xml:1788
#, no-c-format
msgid "The next example shows the equivalent mapping using the <classname>@DynamicBoost</classname> annotation:"
msgstr ""

#. Tag: title
#: mapping.xml:1792
#, no-c-format
msgid "Using the @DynamicBoost"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1794
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed\n"
      "@DynamicBoost(impl = CustomBoostStrategy.class)\n"
      "public class DynamicBoostedDescriptionLibrary {\n"
      "\n"
      " @Id\n"
      " @GeneratedValue\n"
      " @DocumentId\n"
      " private int id;\n"
      "\n"
      " private float dynScore;\n"
      " \n"
      " @Field(store = Store.YES)\n"
      " @DynamicBoost(impl = CustomFieldBoostStrategy.class)\n"
      " private String name;\n"
      "\n"
      " public DynamicBoostedDescriptionLibrary() {\n"
      "  dynScore = 1.0f;\n"
      " }\n"
      "  \n"
      " .......\n"
      "}"
msgstr ""

