# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2011-09-17 19:35+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: query.xml:31
#, no-c-format
msgid "Querying"
msgstr ""

#. Tag: para
#: query.xml:33
#, no-c-format
msgid "The second most important capability of Hibernate Search is the ability to execute Lucene queries and retrieve entities managed by a Hibernate session. The search provides the power of Lucene without leaving the Hibernate paradigm, giving another dimension to the Hibernate classic search mechanisms (HQL, Criteria query, native SQL query)."
msgstr ""

#. Tag: para
#: query.xml:39
#, no-c-format
msgid "Preparing and executing a query consists of four simple steps:"
msgstr ""

#. Tag: para
#: query.xml:43
#, no-c-format
msgid "Creating a <classname>FullTextSession</classname>"
msgstr ""

#. Tag: para
#: query.xml:47
#, no-c-format
msgid "Creating a Lucene query either via the Hibernate Search query DSL (recommended) or by utilizing the Lucene query API"
msgstr ""

#. Tag: para
#: query.xml:52
#, no-c-format
msgid "Wrapping the Lucene query using an <classname>org.hibernate.Query</classname>"
msgstr ""

#. Tag: para
#: query.xml:57
#, no-c-format
msgid "Executing the search by calling for example <methodname>list()</methodname> or <methodname>scroll()</methodname>"
msgstr ""

#. Tag: para
#: query.xml:63
#, no-c-format
msgid "To access the querying facilities, you have to use a <classname>FullTextSession</classname>. This Search specific session wraps a regular <classname>org.hibernate.Session</classname> in order to provide query and indexing capabilities."
msgstr ""

#. Tag: title
#: query.xml:69
#, no-c-format
msgid "Creating a FullTextSession"
msgstr ""

#. Tag: programlisting
#: query.xml:71
#, no-c-format
msgid ""
      "Session session = sessionFactory.openSession();\n"
      "...\n"
      "FullTextSession fullTextSession = Search.getFullTextSession(session);"
msgstr ""

#. Tag: para
#: query.xml:74
#, no-c-format
msgid "Once you have a <classname>FullTextSession</classname> you have two options to build the full-text query: the Hibernate Search query DSL or the native Lucene query."
msgstr ""

#. Tag: para
#: query.xml:78
#, no-c-format
msgid "If you use the Hibernate Search query DSL, it will look like this:"
msgstr ""

#. Tag: programlisting
#: query.xml:81
#, no-c-format
msgid ""
      "<emphasis role=\"bold\">final QueryBuilder b = fullTextSession.getSearchFactory()\n"
      "    .buildQueryBuilder().forEntity( Myth.class ).get();\n"
      "\n"
      "org.apache.lucene.search.Query luceneQuery =\n"
      "    b.keyword()\n"
      "        .onField(\"history\").boostedTo(3)\n"
      "        .matching(\"storm\")\n"
      "        .createQuery();</emphasis>\n"
      "\n"
      "org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery );\n"
      "List result = fullTextQuery.list(); //return a list of managed objects"
msgstr ""

#. Tag: para
#: query.xml:83
#, no-c-format
msgid "You can alternatively write your Lucene query either using the Lucene query parser or Lucene programmatic API."
msgstr ""

#. Tag: title
#: query.xml:87
#, no-c-format
msgid "Creating a Lucene query via the <classname>QueryParser</classname>"
msgstr ""

#. Tag: programlisting
#: query.xml:90
#, no-c-format
msgid ""
      "<emphasis role=\"bold\">SearchFactory searchFactory = fullTextSession.getSearchFactory();\n"
      "org.apache.lucene.queryParser.QueryParser parser = \n"
      "    new QueryParser(\"title\", searchFactory.getAnalyzer(Myth.class) );\n"
      "try {\n"
      "    org.apache.lucene.search.Query luceneQuery = parser.parse( \"history:storm^3\" );\n"
      "}\n"
      "catch (ParseException e) {\n"
      "    //handle parsing failure\n"
      "}</emphasis>\n"
      "\n"
      "org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery(luceneQuery);\n"
      "List result = fullTextQuery.list(); //return a list of managed objects"
msgstr ""

#. Tag: para
#: query.xml:94
#, no-c-format
msgid "The Hibernate query built on top of the Lucene query is a regular <literal>org.hibernate.Query</literal>, which means you are in the same paradigm as the other Hibernate query facilities (HQL, Native or Criteria). The regular <literal>list()</literal> , <literal>uniqueResult()</literal>, <literal>iterate()</literal> and <literal>scroll()</literal> methods can be used."
msgstr ""

#. Tag: para
#: query.xml:102
#, no-c-format
msgid "In case you are using the Java Persistence APIs of Hibernate, the same extensions exist:"
msgstr ""

#. Tag: title
#: query.xml:106
#, no-c-format
msgid "Creating a Search query using the JPA API"
msgstr ""

#. Tag: programlisting
#: query.xml:108
#, no-c-format
msgid ""
      "EntityManager em = entityManagerFactory.createEntityManager();\n"
      "\n"
      "FullTextEntityManager fullTextEntityManager = \n"
      "    org.hibernate.search.jpa.Search.getFullTextEntityManager(em);\n"
      "\n"
      "...\n"
      "final QueryBuilder b = fullTextEntityManager.getSearchFactory()\n"
      "    .buildQueryBuilder().forEntity( Myth.class ).get();\n"
      "\n"
      "org.apache.lucene.search.Query luceneQuery =\n"
      "    b.keyword()\n"
      "        .onField(\"history\").boostedTo(3)\n"
      "        .matching(\"storm\")\n"
      "        .createQuery();\n"
      "<emphasis role=\"bold\">javax.persistence.Query fullTextQuery = \n"
      "    fullTextEntityManager.createFullTextQuery( luceneQuery );</emphasis>\n"
      "\n"
      "List result = fullTextQuery.getResultList(); //return a list of managed objects"
msgstr ""

#. Tag: para
#: query.xml:112
#, no-c-format
msgid "The following examples we will use the Hibernate APIs but the same example can be easily rewritten with the Java Persistence API by just adjusting the way the <classname>FullTextQuery</classname> is retrieved."
msgstr ""

#. Tag: title
#: query.xml:119
#, no-c-format
msgid "Building queries"
msgstr ""

#. Tag: para
#: query.xml:121
#, no-c-format
msgid "Hibernate Search queries are built on top of Lucene queries which gives you total freedom on the type of Lucene query you want to execute. However, once built, Hibernate Search wraps further query processing using <classname>org.hibernate.Query</classname> as your primary query manipulation API."
msgstr ""

#. Tag: title
#: query.xml:128
#, no-c-format
msgid "Building a Lucene query using the Lucene API"
msgstr ""

#. Tag: para
#: query.xml:130
#, no-c-format
msgid "Using the Lucene API, you have several options. You can use the query parser (fine for simple queries) or the Lucene programmatic API (for more complex use cases). It is out of the scope of this documentation on how to exactly build a Lucene query. Please refer to the online Lucene documentation or get hold of a copy of Lucene In Action or Hibernate Search in Action."
msgstr ""

#. Tag: title
#: query.xml:139
#, no-c-format
msgid "Building a Lucene query with the Hibernate Search query DSL"
msgstr ""

#. Tag: para
#: query.xml:142
#, no-c-format
msgid "Writing full-text queries with the Lucene programmatic API is quite complex. It's even more complex to understand the code once written. Besides the inherent API complexity, you have to remember to convert your parameters to their string equivalent as well as make sure to apply the correct analyzer to the right field (a ngram analyzer will for example use several ngrams as the tokens for a given word and should be searched as such)."
msgstr ""

#. Tag: para
#: query.xml:150
#, no-c-format
msgid "The Hibernate Search query DSL makes use of a style of API called a fluent API. This API has a few key characteristics:"
msgstr ""

#. Tag: para
#: query.xml:155
#, no-c-format
msgid "it has meaningful method names making a succession of operations reads almost like English"
msgstr ""

#. Tag: para
#: query.xml:160
#, no-c-format
msgid "it limits the options offered to what makes sense in a given context (thanks to strong typing and IDE autocompletion)."
msgstr ""

#. Tag: para
#: query.xml:165
#, no-c-format
msgid "It often uses the chaining method pattern"
msgstr ""

#. Tag: para
#: query.xml:169
#, no-c-format
msgid "it's easy to use and even easier to read"
msgstr ""

#. Tag: para
#: query.xml:173
#, no-c-format
msgid "Let's see how to use the API. You first need to create a query builder that is attached to a given indexed entity type. This <classname>QueryBuilder</classname> will know what analyzer to use and what field bridge to apply. You can create several <classname>QueryBuilder</classname>s (one for each entity type involved in the root of your query). You get the <classname>QueryBuilder</classname> from the <classname>SearchFactory</classname>."
msgstr ""

#. Tag: programlisting
#: query.xml:182
#, no-c-format
msgid "QueryBuilder mythQB = searchFactory.buildQueryBuilder().forEntity( Myth.class ).get();"
msgstr ""

#. Tag: para
#: query.xml:184
#, no-c-format
msgid "You can also override the analyzer used for a given field or fields. This is rarely needed and should be avoided unless you know what you are doing."
msgstr ""

#. Tag: programlisting
#: query.xml:188
#, no-c-format
msgid ""
      "QueryBuilder mythQB = searchFactory.buildQueryBuilder()\n"
      "    .forEntity( Myth.class )\n"
      "        .overridesForField(\"history\",\"stem_analyzer_definition\")\n"
      "    .get();"
msgstr ""

#. Tag: para
#: query.xml:190
#, no-c-format
msgid "Using the query builder, you can then build queries. It is important to realize that the end result of a <classname>QueryBuilder</classname> is a Lucene query. For this reason you can easily mix and match queries generated via Lucene's query parser or <classname>Query</classname> objects you have assembled with the Lucene programmatic API and use them with the Hibernate Search DSL. Just in case the DSL is missing some features."
msgstr ""

#. Tag: title
#: query.xml:199
#, no-c-format
msgid "Keyword queries"
msgstr ""

#. Tag: para
#: query.xml:201
#, no-c-format
msgid "Let's start with the most basic use case - searching for a specific word:"
msgstr ""

#. Tag: programlisting
#: query.xml:204
#, no-c-format
msgid "Query luceneQuery = mythQB.keyword().onField(\"history\").matching(\"storm\").createQuery();"
msgstr ""

#. Tag: para
#: query.xml:206
#, no-c-format
msgid "<methodname>keyword()</methodname> means that you are trying to find a specific word. <methodname>onField()</methodname> specifies in which Lucene field to look. <methodname>matching()</methodname> tells what to look for. And finally <methodname>createQuery()</methodname> creates the Lucene query object. A lot is going on with this line of code."
msgstr ""

#. Tag: para
#: query.xml:215
#, no-c-format
msgid "The value storm is passed through the <literal>history</literal> <classname>FieldBridge</classname>: it does not matter here but you will see that it's quite handy when dealing with numbers or dates."
msgstr ""

#. Tag: para
#: query.xml:222
#, no-c-format
msgid "The field bridge value is then passed to the analyzer used to index the field <literal>history</literal>. This ensures that the query uses the same term transformation than the indexing (lower case, n-gram, stemming and so on). If the analyzing process generates several terms for a given word, a boolean query is used with the <literal>SHOULD</literal> logic (roughly an <literal>OR</literal> logic)."
msgstr ""

#. Tag: para
#: query.xml:232
#, no-c-format
msgid "Let's see how you can search a property that is not of type string."
msgstr ""

#. Tag: programlisting
#: query.xml:235
#, no-c-format
msgid ""
      "@Entity \n"
      "@Indexed \n"
      "public class Myth {\n"
      "  @Field(analyze = Analyze.NO) \n"
      "  @DateBridge(resolution = Resolution.YEAR)\n"
      "  public Date getCreationDate() { return creationDate; }\n"
      "  public Date setCreationDate(Date creationDate) { this.creationDate = creationDate; }\n"
      "  private Date creationDate;\n"
      "  \n"
      "  ...\n"
      "}\n"
      "\n"
      "Date birthdate = ...;\n"
      "Query luceneQuery = mythQb.keyword().onField(\"creationDate\").matching(birthdate).createQuery();"
msgstr ""

#. Tag: para
#: query.xml:238
#, no-c-format
msgid "In plain Lucene, you would have had to convert the <classname>Date</classname> object to its string representation (in this case the year)."
msgstr ""

#. Tag: para
#: query.xml:243
#, no-c-format
msgid "This conversion works for any object, not just <classname>Date</classname>, provided that the <classname>FieldBridge</classname> has an <methodname>objectToString</methodname> method (and all built-in <classname>FieldBridge</classname> implementations do)."
msgstr ""

#. Tag: para
#: query.xml:249
#, no-c-format
msgid "We make the example a little more advanced now and have a look at how to search a field that uses ngram analyzers. ngram analyzers index succession of ngrams of your words which helps to recover from user typos. For example the 3-grams of the word hibernate are hib, ibe, ber, rna, nat, ate."
msgstr ""

#. Tag: programlisting
#: query.xml:255
#, no-c-format
msgid ""
      "@AnalyzerDef(name = \"ngram\",\n"
      "  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class ),\n"
      "  filters = {\n"
      "    @TokenFilterDef(factory = StandardFilterFactory.class),\n"
      "    @TokenFilterDef(factory = LowerCaseFilterFactory.class),\n"
      "    @TokenFilterDef(factory = StopFilterFactory.class),\n"
      "    @TokenFilterDef(factory = NGramFilterFactory.class,\n"
      "      params = { \n"
      "        @Parameter(name = \"minGramSize\", value = \"3\"),\n"
      "        @Parameter(name = \"maxGramSize\", value = \"3\") } )\n"
      "  }\n"
      ")\n"
      "@Entity \n"
      "@Indexed \n"
      "public class Myth {\n"
      "  @Field(analyzer=@Analyzer(definition=\"ngram\") \n"
      "  @DateBridge(resolution = Resolution.YEAR)\n"
      "  public String getName() { return name; }\n"
      "  public String setName(Date name) { this.name = name; }\n"
      "  private String name;\n"
      "  \n"
      "  ...\n"
      "}\n"
      "\n"
      "Date birthdate = ...;\n"
      "Query luceneQuery = mythQb.keyword().onField(\"name\").matching(\"Sisiphus\")\n"
      "   .createQuery();"
msgstr ""

#. Tag: para
#: query.xml:257
#, no-c-format
msgid "The matching word \"Sisiphus\" will be lower-cased and then split into 3-grams: sis, isi, sip, phu, hus. Each of these n-gram will be part of the query. We will then be able to find the Sysiphus myth (with a <literal>y</literal>). All that is transparently done for you."
msgstr ""

#. Tag: para
#: query.xml:264
#, no-c-format
msgid "If for some reason you do not want a specific field to use the field bridge or the analyzer you can call the <methodname>ignoreAnalyzer()</methodname> or <methodname>ignoreFieldBridge()</methodname> functions"
msgstr ""

#. Tag: para
#: query.xml:270
#, no-c-format
msgid "To search for multiple possible words in the same field, simply add them all in the matching clause."
msgstr ""

#. Tag: programlisting
#: query.xml:273
#, no-c-format
msgid ""
      "//search document with storm or lightning in their history\n"
      "Query luceneQuery = \n"
      "    mythQB.keyword().onField(\"history\").matching(\"storm lightning\").createQuery();"
msgstr ""

#. Tag: para
#: query.xml:275
#, no-c-format
msgid "To search the same word on multiple fields, use the <methodname>onFields</methodname> method."
msgstr ""

#. Tag: programlisting
#: query.xml:278
#, no-c-format
msgid ""
      "Query luceneQuery = mythQB\n"
      "    .keyword()\n"
      "    .onFields(\"history\",\"description\",\"name\")\n"
      "    .matching(\"storm\")\n"
      "    .createQuery();"
msgstr ""

#. Tag: para
#: query.xml:280
#, no-c-format
msgid "Sometimes, one field should be treated differently from another field even if searching the same term, you can use the <methodname>andField()</methodname> method for that."
msgstr ""

#. Tag: programlisting
#: query.xml:284
#, no-c-format
msgid ""
      "Query luceneQuery = mythQB.keyword()\n"
      "    .onField(\"history\")\n"
      "    .andField(\"name\")\n"
      "      .boostedTo(5)\n"
      "    .andField(\"description\")\n"
      "    .matching(\"storm\")\n"
      "    .createQuery();"
msgstr ""

#. Tag: para
#: query.xml:286
#, no-c-format
msgid "In the previous example, only field name is boosted to 5."
msgstr ""

#. Tag: title
#: query.xml:290
#, no-c-format
msgid "Fuzzy queries"
msgstr ""

#. Tag: para
#: query.xml:292
#, no-c-format
msgid "To execute a fuzzy query (based on the Levenshtein distance algorithm), start like a <literal>keyword</literal> query and add the fuzzy flag."
msgstr ""

#. Tag: programlisting
#: query.xml:296
#, no-c-format
msgid ""
      "Query luceneQuery = mythQB\n"
      "    .keyword()\n"
      "      .fuzzy()\n"
      "        .withThreshold( .8f )\n"
      "        .withPrefixLength( 1 )\n"
      "    .onField(\"history\")\n"
      "    .matching(\"starm\")\n"
      "    .createQuery();"
msgstr ""

#. Tag: para
#: query.xml:298
#, no-c-format
msgid "<literal>threshold</literal> is the limit above which two terms are considering matching. It's a decimal between 0 and 1 and defaults to 0.5. <literal>prefixLength</literal> is the length of the prefix ignored by the \"fuzzyness\": while it defaults to 0, a non zero value is recommended for indexes containing a huge amount of distinct terms."
msgstr ""

#. Tag: title
#: query.xml:307
#, no-c-format
msgid "Wildcard queries"
msgstr ""

#. Tag: para
#: query.xml:309
#, no-c-format
msgid "You can also execute wildcard queries (queries where some of parts of the word are unknown). <literal>?</literal> represents a single character and <literal>*</literal> represents any character sequence. Note that for performance purposes, it is recommended that the query does not start with either <literal>?</literal> or <literal>*</literal>."
msgstr ""

#. Tag: programlisting
#: query.xml:316
#, no-c-format
msgid ""
      "Query luceneQuery = mythQB\n"
      "    .keyword()\n"
      "      .wildcard()\n"
      "    .onField(\"history\")\n"
      "    .matching(\"sto*\")\n"
      "    .createQuery();"
msgstr ""

#. Tag: para
#: query.xml:319
#, no-c-format
msgid "Wildcard queries do not apply the analyzer on the matching terms. Otherwise the risk of <literal>*</literal> or <literal>?</literal> being mangled is too high."
msgstr ""

#. Tag: title
#: query.xml:326
#, no-c-format
msgid "Phrase queries"
msgstr ""

#. Tag: para
#: query.xml:328
#, no-c-format
msgid "So far we have been looking for words or sets of words, you can also search exact or approximate sentences. Use <methodname>phrase()</methodname> to do so."
msgstr ""

#. Tag: programlisting
#: query.xml:332
#, no-c-format
msgid ""
      "Query luceneQuery = mythQB\n"
      "    .phrase()\n"
      "    .onField(\"history\")\n"
      "    .sentence(\"Thou shalt not kill\")\n"
      "    .createQuery();"
msgstr ""

#. Tag: para
#: query.xml:334
#, no-c-format
msgid "You can search approximate sentences by adding a slop factor. The slop factor represents the number of other words permitted in the sentence: this works like a within or near operator"
msgstr ""

#. Tag: programlisting
#: query.xml:338
#, no-c-format
msgid ""
      "Query luceneQuery = mythQB\n"
      "    .phrase()\n"
      "      .withSlop(3)\n"
      "    .onField(\"history\")\n"
      "    .sentence(\"Thou kill\")\n"
      "    .createQuery();"
msgstr ""

#. Tag: title
#: query.xml:342
#, no-c-format
msgid "Range queries"
msgstr ""

#. Tag: para
#: query.xml:344
#, no-c-format
msgid "After looking at all these query examples for searching for to a given word, it is time to introduce range queries (on numbers, dates, strings etc). A range query searches for a value in between given boundaries (included or not) or for a value below or above a given boundary (included or not)."
msgstr ""

#. Tag: programlisting
#: query.xml:350
#, no-c-format
msgid ""
      "//look for 0 &lt;= starred &lt; 3\n"
      "Query luceneQuery = mythQB\n"
      "    .range()\n"
      "    .onField(\"starred\")\n"
      "    .from(0).to(3).excludeLimit()\n"
      "    .createQuery();\n"
      "\n"
      "//look for myths strictly BC\n"
      "Date beforeChrist = ...;\n"
      "Query luceneQuery = mythQB\n"
      "    .range()\n"
      "    .onField(\"creationDate\")\n"
      "    .below(beforeChrist).excludeLimit()\n"
      "    .createQuery();"
msgstr ""

#. Tag: title
#: query.xml:354
#, no-c-format
msgid "Combining queries"
msgstr ""

#. Tag: para
#: query.xml:356
#, no-c-format
msgid "Finally, you can aggregate (combine) queries to create more complex queries. The following aggregation operators are available:"
msgstr ""

#. Tag: para
#: query.xml:362
#, no-c-format
msgid "<literal>SHOULD</literal>: the query query should contain the matching elements of the subquery"
msgstr ""

#. Tag: para
#: query.xml:367
#, no-c-format
msgid "<literal>MUST</literal>: the query must contain the matching elements of the subquery"
msgstr ""

#. Tag: para
#: query.xml:372
#, no-c-format
msgid "<literal>MUST NOT</literal>: the query must not contain the matching elements of the subquery"
msgstr ""

#. Tag: para
#: query.xml:377
#, no-c-format
msgid "The subqueries can be any Lucene query including a boolean query itself. Let's look at a few examples:"
msgstr ""

#. Tag: programlisting
#: query.xml:380
#, no-c-format
msgid ""
      "//look for popular modern myths that are not urban\n"
      "Date twentiethCentury = ...;\n"
      "Query luceneQuery = mythQB\n"
      "    .bool()\n"
      "      .must( mythQB.keyword().onField(\"description\").matching(\"urban\").createQuery() )\n"
      "        .not()\n"
      "      .must( mythQB.range().onField(\"starred\").above(4).createQuery() )\n"
      "      .must( mythQB\n"
      "        .range()\n"
      "        .onField(\"creationDate\")\n"
      "        .above(twentiethCentury)\n"
      "        .createQuery() )\n"
      "    .createQuery();\n"
      "\n"
      "//look for popular myths that are preferably urban\n"
      "Query luceneQuery = mythQB\n"
      "    .bool()\n"
      "      .should( mythQB.keyword().onField(\"description\").matching(\"urban\").createQuery() )\n"
      "      .must( mythQB.range().onField(\"starred\").above(4).createQuery() )\n"
      "    .createQuery();\n"
      "\n"
      "//look for all myths except religious ones\n"
      "Query luceneQuery = mythQB\n"
      "    .all()\n"
      "      .except( monthQb\n"
      "        .keyword()\n"
      "        .onField( \"description_stem\" )\n"
      "        .matching( \"religion\" )\n"
      "        .createQuery() \n"
      "      )\n"
      "    .createQuery();"
msgstr ""

#. Tag: title
#: query.xml:384
#, no-c-format
msgid "Query options"
msgstr ""

#. Tag: para
#: query.xml:386
#, no-c-format
msgid "We already have seen several query options in the previous example, but lets summarize again the options for query types and fields:"
msgstr ""

#. Tag: para
#: query.xml:392
#, no-c-format
msgid "<methodname>boostedTo</methodname> (on query type and on field): boost the whole query or the specific field to a given factor"
msgstr ""

#. Tag: para
#: query.xml:398
#, no-c-format
msgid "<methodname>withConstantScore</methodname> (on query): all results matching the query have a constant score equals to the boost"
msgstr ""

#. Tag: para
#: query.xml:404
#, no-c-format
msgid "<methodname>filteredBy(Filter) </methodname>(on query): filter query results using the <classname>Filter</classname> instance"
msgstr ""

#. Tag: para
#: query.xml:410
#, no-c-format
msgid "<methodname>ignoreAnalyzer</methodname> (on field): ignore the analyzer when processing this field"
msgstr ""

#. Tag: para
#: query.xml:415
#, no-c-format
msgid "<methodname>ignoreFieldBridge</methodname> (on field): ignore field bridge when processing this field"
msgstr ""

#. Tag: para
#: query.xml:420
#, no-c-format
msgid "Let's check out an example using some of these options"
msgstr ""

#. Tag: programlisting
#: query.xml:422
#, no-c-format
msgid ""
      "Query luceneQuery = mythQB\n"
      "    .bool()\n"
      "      .should( mythQB.keyword().onField(\"description\").matching(\"urban\").createQuery() )\n"
      "      .should( mythQB\n"
      "        .keyword()\n"
      "        .onField(\"name\")\n"
      "          .boostedTo(3)\n"
      "          .ignoreAnalyzer()\n"
      "        .matching(\"urban\").createQuery() )\n"
      "      .must( mythQB\n"
      "        .range()\n"
      "          .boostedTo(5).withConstantScore()\n"
      "        .onField(\"starred\").above(4).createQuery() )\n"
      "    .createQuery();"
msgstr ""

#. Tag: para
#: query.xml:424
#, no-c-format
msgid "As you can see, the Hibernate Search query DSL is an easy to use and easy to read query API and by accepting and producing Lucene queries, you can easily incorporate query types not (yet) supported by the DSL. Please give us feedback!"
msgstr ""

#. Tag: title
#: query.xml:432
#, no-c-format
msgid "Building a Hibernate Search query"
msgstr ""

#. Tag: para
#: query.xml:434
#, no-c-format
msgid "So far we only covered the process of how to create your Lucene query (see <xref linkend=\"section-building-lucene-queries\"/>). However, this is only the first step in the chain of actions. Let's now see how to build the Hibernate Search query from the Lucene query."
msgstr ""

#. Tag: title
#: query.xml:440
#, no-c-format
msgid "Generality"
msgstr ""

#. Tag: para
#: query.xml:442
#, no-c-format
msgid "Once the Lucene query is built, it needs to be wrapped into an Hibernate Query. If not specified otherwise, the query will be executed against all indexed entities, potentially returning all types of indexed classes."
msgstr ""

#. Tag: title
#: query.xml:448
#, no-c-format
msgid "Wrapping a Lucene query into a Hibernate Query"
msgstr ""

#. Tag: programlisting
#: query.xml:450
#, no-c-format
msgid ""
      "FullTextSession fullTextSession = Search.getFullTextSession( session );\n"
      "org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery );"
msgstr ""

#. Tag: para
#: query.xml:453
#, no-c-format
msgid "It is advised, from a performance point of view, to restrict the returned types:"
msgstr ""

#. Tag: title
#: query.xml:457
#, no-c-format
msgid "Filtering the search result by entity type"
msgstr ""

#. Tag: programlisting
#: query.xml:459
#, no-c-format
msgid ""
      "fullTextQuery = fullTextSession\n"
      "    .createFullTextQuery( luceneQuery, Customer.class );\n"
      "\n"
      "// or\n"
      "\n"
      "fullTextQuery = fullTextSession\n"
      "    .createFullTextQuery( luceneQuery, Item.class, Actor.class );"
msgstr ""

#. Tag: para
#: query.xml:462
#, no-c-format
msgid "In <xref linkend=\"example-filtering-by-entity-type\"/> the first example returns only matching <classname>Customer</classname>s, the second returns matching <classname>Actor</classname>s and <classname>Item</classname>s. The type restriction is fully polymorphic which means that if there are two indexed subclasses <classname>Salesman</classname> and <classname>Customer</classname> of the baseclass <classname>Person</classname>, it is possible to just specify <classname>Person.class</classname> in order to filter on result types."
msgstr ""

#. Tag: title
#: query.xml:474
#, no-c-format
msgid "Pagination"
msgstr ""

#. Tag: para
#: query.xml:476
#, no-c-format
msgid "Out of performance reasons it is recommended to restrict the number of returned objects per query. In fact is a very common use case anyway that the user navigates from one page to an other. The way to define pagination is exactly the way you would define pagination in a plain HQL or Criteria query."
msgstr ""

#. Tag: title
#: query.xml:483
#, no-c-format
msgid "Defining pagination for a search query"
msgstr ""

#. Tag: programlisting
#: query.xml:485
#, no-c-format
msgid ""
      "org.hibernate.Query fullTextQuery = \n"
      "    fullTextSession.createFullTextQuery( luceneQuery, Customer.class );\n"
      "fullTextQuery.setFirstResult(15); //start from the 15th element\n"
      "fullTextQuery.setMaxResults(10); //return 10 elements"
msgstr ""

#. Tag: para
#: query.xml:489
#, no-c-format
msgid "It is still possible to get the total number of matching elements regardless of the pagination via <methodname>fulltextQuery.</methodname><methodname>getResultSize()</methodname>"
msgstr ""

#. Tag: title
#: query.xml:496
#, no-c-format
msgid "Sorting"
msgstr ""

#. Tag: para
#: query.xml:498
#, no-c-format
msgid "Apache Lucene provides a very flexible and powerful way to sort results. While the default sorting (by relevance) is appropriate most of the time, it can be interesting to sort by one or several other properties. In order to do so set the Lucene Sort object to apply a Lucene sorting strategy."
msgstr ""

#. Tag: title
#: query.xml:505
#, no-c-format
msgid "Specifying a Lucene <classname>Sort</classname> in order to sort the results"
msgstr ""

#. Tag: programlisting
#: query.xml:508
#, no-c-format
msgid ""
      "org.hibernate.search.FullTextQuery query = s.createFullTextQuery( query, Book.class );\n"
      "org.apache.lucene.search.Sort sort = new Sort(\n"
      "    new SortField(\"title\", SortField.STRING));\n"
      "<emphasis role=\"bold\">query.setSort(sort);</emphasis>\n"
      "List results = query.list();"
msgstr ""

#. Tag: para
#: query.xml:512
#, no-c-format
msgid "Be aware that fields used for sorting must not be tokenized (see <xref linkend=\"field-annotation\"/>)."
msgstr ""

#. Tag: title
#: query.xml:518
#, no-c-format
msgid "Fetching strategy"
msgstr ""

#. Tag: para
#: query.xml:520
#, no-c-format
msgid "When you restrict the return types to one class, Hibernate Search loads the objects using a single query. It also respects the static fetching strategy defined in your domain model."
msgstr ""

#. Tag: para
#: query.xml:524
#, no-c-format
msgid "It is often useful, however, to refine the fetching strategy for a specific use case."
msgstr ""

#. Tag: title
#: query.xml:528
#, no-c-format
msgid "Specifying <classname>FetchMode</classname> on a query"
msgstr ""

#. Tag: programlisting
#: query.xml:531
#, no-c-format
msgid ""
      "Criteria criteria = \n"
      "    s.createCriteria( Book.class ).setFetchMode( \"authors\", FetchMode.JOIN );\n"
      "s.createFullTextQuery( luceneQuery ).setCriteriaQuery( criteria );"
msgstr ""

#. Tag: para
#: query.xml:534
#, no-c-format
msgid "In this example, the query will return all Books matching the luceneQuery. The authors collection will be loaded from the same query using an SQL outer join."
msgstr ""

#. Tag: para
#: query.xml:538
#, no-c-format
msgid "When defining a criteria query, it is not necessary to restrict the returned entity types when creating the Hibernate Search query from the full text session: the type is guessed from the criteria query itself."
msgstr ""

#. Tag: para
#: query.xml:544
#, no-c-format
msgid "Only fetch mode can be adjusted, refrain from applying any other restriction. While it is known to work as of Hibernate Search 4, using restriction (ie a where clause) on your <classname>Criteria</classname> query should be avoided when possible. <methodname>getResultSize()</methodname> will return a <classname>SearchException</classname> if used in conjunction with a <classname>Criteria</classname> with restriction."
msgstr ""

#. Tag: para
#: query.xml:554
#, no-c-format
msgid "You cannot use <methodname>setCriteriaQuery</methodname> if more than one entity type is expected to be returned."
msgstr ""

#. Tag: title
#: query.xml:560
#, no-c-format
msgid "Projection"
msgstr ""

#. Tag: para
#: query.xml:562
#, no-c-format
msgid "For some use cases, returning the domain object (including its associations) is overkill. Only a small subset of the properties is necessary. Hibernate Search allows you to return a subset of properties:"
msgstr ""

#. Tag: title
#: query.xml:568
#, no-c-format
msgid "Using projection instead of returning the full domain object"
msgstr ""

#. Tag: programlisting
#: query.xml:571
#, no-c-format
msgid ""
      "org.hibernate.search.FullTextQuery query = \n"
      "    s.createFullTextQuery( luceneQuery, Book.class );\n"
      "query.<emphasis role=\"bold\">setProjection( \"id\", \"summary\", \"body\", \"mainAuthor.name\" )</emphasis>;\n"
      "List results = query.list();\n"
      "Object[] firstResult = (Object[]) results.get(0);\n"
      "Integer id = firstResult[0];\n"
      "String summary = firstResult[1];\n"
      "String body = firstResult[2];\n"
      "String authorName = firstResult[3];"
msgstr ""

#. Tag: para
#: query.xml:574
#, no-c-format
msgid "Hibernate Search extracts the properties from the Lucene index and convert them back to their object representation, returning a list of <classname>Object[]</classname>. Projections avoid a potential database round trip (useful if the query response time is critical). However, it also has several constraints:"
msgstr ""

#. Tag: para
#: query.xml:582
#, no-c-format
msgid "the properties projected must be stored in the index (<literal>@Field(store=Store.YES)</literal>), which increases the index size"
msgstr ""

#. Tag: para
#: query.xml:588
#, no-c-format
msgid "the properties projected must use a <literal>FieldBridge</literal> implementing <classname>org.hibernate.search.bridge.TwoWayFieldBridge</classname> or <literal>org.hibernate.search.bridge.TwoWayStringBridge</literal>, the latter being the simpler version."
msgstr ""

#. Tag: para
#: query.xml:596
#, no-c-format
msgid "All Hibernate Search built-in types are two-way."
msgstr ""

#. Tag: para
#: query.xml:601
#, no-c-format
msgid "you can only project simple properties of the indexed entity or its embedded associations. This means you cannot project a whole embedded entity."
msgstr ""

#. Tag: para
#: query.xml:607
#, no-c-format
msgid "projection does not work on collections or maps which are indexed via <classname>@IndexedEmbedded</classname>"
msgstr ""

#. Tag: para
#: query.xml:612
#, no-c-format
msgid "Projection is also useful for another kind of use case. Lucene can provide metadata information about the results. By using some special projection constants, the projection mechanism can retrieve this metadata:"
msgstr ""

#. Tag: title
#: query.xml:618
#, no-c-format
msgid "Using projection in order to retrieve meta data"
msgstr ""

#. Tag: programlisting
#: query.xml:620
#, no-c-format
msgid ""
      "org.hibernate.search.FullTextQuery query = \n"
      "    s.createFullTextQuery( luceneQuery, Book.class );\n"
      "query.<emphasis role=\"bold\">setProjection( \n"
      "    FullTextQuery.SCORE, \n"
      "    FullTextQuery.THIS, \n"
      "    \"mainAuthor.name\" )</emphasis>;\n"
      "List results = query.list();\n"
      "Object[] firstResult = (Object[]) results.get(0);\n"
      "float score = firstResult[0];\n"
      "Book book = firstResult[1];\n"
      "String authorName = firstResult[2];"
msgstr ""

#. Tag: para
#: query.xml:623
#, no-c-format
msgid "You can mix and match regular fields and projection constants. Here is the list of the available constants:"
msgstr ""

#. Tag: para
#: query.xml:628
#, no-c-format
msgid "<classname>FullTextQuery.THIS</classname>: returns the initialized and managed entity (as a non projected query would have done)."
msgstr ""

#. Tag: para
#: query.xml:634
#, no-c-format
msgid "<classname>FullTextQuery.DOCUMENT</classname>: returns the Lucene Document related to the object projected."
msgstr ""

#. Tag: para
#: query.xml:639
#, no-c-format
msgid "<classname>FullTextQuery.OBJECT_CLASS</classname>: returns the class of the indexed entity."
msgstr ""

#. Tag: para
#: query.xml:644
#, no-c-format
msgid "<classname>FullTextQuery.SCORE</classname>: returns the document score in the query. Scores are handy to compare one result against an other for a given query but are useless when comparing the result of different queries."
msgstr ""

#. Tag: para
#: query.xml:651
#, no-c-format
msgid "<classname>FullTextQuery.ID</classname>: the id property value of the projected object."
msgstr ""

#. Tag: para
#: query.xml:656
#, no-c-format
msgid "<classname>FullTextQuery.DOCUMENT_ID</classname>: the Lucene document id. Careful, Lucene document id can change overtime between two different IndexReader opening (this feature is experimental)."
msgstr ""

#. Tag: para
#: query.xml:663
#, no-c-format
msgid "<classname>FullTextQuery.EXPLANATION</classname>: returns the Lucene Explanation object for the matching object/document in the given query. Do not use if you retrieve a lot of data. Running explanation typically is as costly as running the whole Lucene query per matching element. Make sure you use projection!"
msgstr ""

#. Tag: title
#: query.xml:673
#, no-c-format
msgid "Customizing object initialization strategies"
msgstr ""

#. Tag: para
#: query.xml:675
#, no-c-format
msgid "By default, Hibernate Search uses the most appropriate strategy to initialize entities matching your full text query. It executes one (or several) queries to retrieve the required entities. This is the best approach to minimize database round trips in a scenario where none / few of the retrieved entities are present in the persistence context (ie the session) or the second level cache."
msgstr ""

#. Tag: para
#: query.xml:682
#, no-c-format
msgid "If most of your entities are present in the second level cache, you can force Hibernate Search to look into the cache before retrieving an object from the database."
msgstr ""

#. Tag: title
#: query.xml:687
#, no-c-format
msgid "Check the second-level cache before using a query"
msgstr ""

#. Tag: programlisting
#: query.xml:689
#, no-c-format
msgid ""
      "FullTextQuery query = session.createFullTextQuery(luceneQuery, User.class);\n"
      "query.initializeObjectWith(\n"
      "    ObjectLookupMethod.SECOND_LEVEL_CACHE,\n"
      "    DatabaseRetrievalMethod.QUERY\n"
      ");"
msgstr ""

#. Tag: para
#: query.xml:692
#, no-c-format
msgid "<classname>ObjectLookupMethod</classname> defines the strategy used to check if an object is easily accessible (without database round trip). Other options are:"
msgstr ""

#. Tag: para
#: query.xml:698
#, no-c-format
msgid "<literal>ObjectLookupMethod.PERSISTENCE_CONTEXT</literal>: useful if most of the matching entities are already in the persistence context (ie loaded in the <classname>Session</classname> or <classname>EntityManager</classname>)"
msgstr ""

#. Tag: para
#: query.xml:706
#, no-c-format
msgid "<literal>ObjectLookupMethod.SECOND_LEVEL_CACHE</literal>: check first the persistence context and then the second-level cache."
msgstr ""

#. Tag: para
#: query.xml:713
#, no-c-format
msgid "Note that to search in the second-level cache, several settings must be in place:"
msgstr ""

#. Tag: para
#: query.xml:718
#, no-c-format
msgid "the second level cache must be properly configured and active"
msgstr ""

#. Tag: para
#: query.xml:723
#, no-c-format
msgid "the entity must have enabled second-level cache (eg via <classname>@Cacheable</classname>)"
msgstr ""

#. Tag: para
#: query.xml:728
#, no-c-format
msgid "the <classname>Session</classname>, <classname>EntityManager</classname> or <classname>Query</classname> must allow access to the second-level cache for read access (ie <literal>CacheMode.NORMAL</literal> in Hibernate native APIs or <literal>CacheRetrieveMode.USE</literal> in JPA 2 APIs)."
msgstr ""

#. Tag: para
#: query.xml:739
#, no-c-format
msgid "Avoid using <literal>ObjectLookupMethod.SECOND_LEVEL_CACHE</literal> unless your second level cache implementation is either EHCache or Infinispan; other second level cache providers don't currently implement this operation efficiently."
msgstr ""

#. Tag: para
#: query.xml:746
#, no-c-format
msgid "You can also customize how objects are loaded from the database (if not found before). Use <classname>DatabaseRetrievalMethod</classname> for that:"
msgstr ""

#. Tag: para
#: query.xml:752
#, no-c-format
msgid "<classname>QUERY</classname> (default): use a (set of) queries to load several objects in batch. This is usually the best approach."
msgstr ""

#. Tag: para
#: query.xml:758
#, no-c-format
msgid "<classname>FIND_BY_ID</classname>: load objects one by one using the <classname>Session</classname>.<methodname>get</methodname> or <classname>EntityManager</classname>.<methodname>find</methodname> semantic. This might be useful if batch-size is set on the entity (in which case, entities will be loaded in batch by Hibernate Core). <classname>QUERY</classname> should be preferred almost all the time."
msgstr ""

#. Tag: title
#: query.xml:771
#, no-c-format
msgid "Limiting the time of a query"
msgstr ""

#. Tag: para
#: query.xml:773
#, no-c-format
msgid "You can limit the time a query takes in Hibernate Search in two ways:"
msgstr ""

#. Tag: para
#: query.xml:778
#, no-c-format
msgid "raise an exception when the limit is reached"
msgstr ""

#. Tag: para
#: query.xml:782
#, no-c-format
msgid "limit to the number of results retrieved when the time limit is raised"
msgstr ""

#. Tag: title
#: query.xml:788
#, no-c-format
msgid "Raise an exception on time limit"
msgstr ""

#. Tag: para
#: query.xml:790
#, no-c-format
msgid "You can decide to stop a query if when it takes more than a predefined amount of time. Note that this is a best effort basis but if Hibernate Search still has significant work to do and if we are beyond the time limit, a <classname>QueryTimeoutException</classname> will be raised (<classname>org.hibernate.QueryTimeoutException</classname> or <classname>javax.persistence.QueryTimeoutException</classname> depending on your programmatic API)."
msgstr ""

#. Tag: para
#: query.xml:799
#, no-c-format
msgid "To define the limit when using the native Hibernate APIs, use one of the following approaches"
msgstr ""

#. Tag: title
#: query.xml:803 query.xml:825
#, no-c-format
msgid "Defining a timeout in query execution"
msgstr ""

#. Tag: programlisting
#: query.xml:805
#, no-c-format
msgid ""
      "Query luceneQuery = ...;\n"
      "FullTextQuery query = fullTextSession.createFullTextQuery(luceneQuery, User.class);\n"
      "\n"
      "//define the timeout in seconds\n"
      "query.setTimeout(5);\n"
      "\n"
      "//alternatively, define the timeout in any given time unit\n"
      "query.setTimeout(450, TimeUnit.MILLISECONDS);\n"
      "\n"
      "try {\n"
      "    query.list();\n"
      "}\n"
      "catch (org.hibernate.QueryTimeoutException e) {\n"
      "    //do something, too slow\n"
      "}"
msgstr ""

#. Tag: para
#: query.xml:808
#, no-c-format
msgid "Likewise <literal>getResultSize()</literal>, <methodname>iterate()</methodname> and <methodname>scroll()</methodname> honor the timeout but only until the end of the method call. That simply means that the methods of <classname>Iterable</classname> or the <classname>ScrollableResults</classname> ignore the timeout."
msgstr ""

#. Tag: para
#: query.xml:816
#, no-c-format
msgid "<methodname>explain()</methodname> does not honor the timeout: this method is used for debug purposes and in particular to find out why a query is slow"
msgstr ""

#. Tag: para
#: query.xml:821
#, no-c-format
msgid "When using JPA, simply use the standard way of limiting query execution time."
msgstr ""

#. Tag: programlisting
#: query.xml:827
#, no-c-format
msgid ""
      "Query luceneQuery = ...;\n"
      "FullTextQuery query = fullTextEM.createFullTextQuery(luceneQuery, User.class);\n"
      "\n"
      "//define the timeout in milliseconds\n"
      "query.setHint( \"javax.persistence.query.timeout\", 450 );\n"
      "\n"
      "try {\n"
      "    query.getResultList();\n"
      "}\n"
      "catch (javax.persistence.QueryTimeoutException e) {\n"
      "    //do something, too slow\n"
      "}"
msgstr ""

#. Tag: para
#: query.xml:831
#, no-c-format
msgid "Remember, this is a best effort approach and does not guarantee to stop exactly on the specified timeout."
msgstr ""

#. Tag: title
#: query.xml:837
#, no-c-format
msgid "Limit the number of results when the time limit is reached (EXPERIMENTAL)"
msgstr ""

#. Tag: para
#: query.xml:840
#, no-c-format
msgid "Alternatively, you can return the number of results which have already been fetched by the time the limit is reached. Note that only the Lucene part of the query is influenced by this limit. It is possible that, if you retrieve managed object, it takes longer to fetch these objects."
msgstr ""

#. Tag: para
#: query.xml:847
#, no-c-format
msgid "This approach is not compatible with the <classname>setTimeout</classname> approach."
msgstr ""

#. Tag: para
#: query.xml:851
#, no-c-format
msgid "To define this soft limit, use the following approach"
msgstr ""

#. Tag: title
#: query.xml:854
#, no-c-format
msgid "Defining a time limit in query execution"
msgstr ""

#. Tag: programlisting
#: query.xml:856
#, no-c-format
msgid ""
      "Query luceneQuery = ...;\n"
      "FullTextQuery query = fullTextSession.createFullTextQuery(luceneQuery, User.class);\n"
      "\n"
      "//define the timeout in seconds\n"
      "query.limitExecutionTimeTo(500, TimeUnit.MILLISECONDS);\n"
      "List results = query.list();"
msgstr ""

#. Tag: para
#: query.xml:859
#, no-c-format
msgid "Likewise <literal>getResultSize()</literal>, <methodname>iterate()</methodname> and <methodname>scroll()</methodname> honor the time limit but only until the end of the method call. That simply means that the methods of <classname>Iterable</classname> or the <classname>ScrollableResults</classname> ignore the timeout."
msgstr ""

#. Tag: para
#: query.xml:866
#, no-c-format
msgid "You can determine if the results have been partially loaded by invoking the <methodname>hasPartialResults</methodname> method."
msgstr ""

#. Tag: title
#: query.xml:871
#, no-c-format
msgid "Determines when a query returns partial results"
msgstr ""

#. Tag: programlisting
#: query.xml:873
#, no-c-format
msgid ""
      "Query luceneQuery = ...;\n"
      "FullTextQuery query = fullTextSession.createFullTextQuery(luceneQuery, User.class);\n"
      "\n"
      "//define the timeout in seconds\n"
      "query.limitExecutionTimeTo(500, TimeUnit.MILLISECONDS);\n"
      "List results = query.list();\n"
      "\n"
      "if ( query.hasPartialResults() ) {\n"
      "    displayWarningToUser();\n"
      "}"
msgstr ""

#. Tag: para
#: query.xml:876
#, no-c-format
msgid "If you use the JPA API, <methodname>limitExecutionTimeTo</methodname> and <methodname>hasPartialResults</methodname> are also available to you."
msgstr ""

#. Tag: para
#: query.xml:882
#, no-c-format
msgid "This approach is considered experimental"
msgstr ""

#. Tag: title
#: query.xml:890
#, no-c-format
msgid "Retrieving the results"
msgstr ""

#. Tag: para
#: query.xml:892
#, no-c-format
msgid "Once the Hibernate Search query is built, executing it is in no way different than executing a HQL or Criteria query. The same paradigm and object semantic applies. All the common operations are available: <methodname>list()</methodname>, <methodname>uniqueResult()</methodname>, <methodname>iterate()</methodname>, <methodname>scroll()</methodname>."
msgstr ""

#. Tag: title
#: query.xml:900
#, no-c-format
msgid "Performance considerations"
msgstr ""

#. Tag: para
#: query.xml:902
#, no-c-format
msgid "If you expect a reasonable number of results (for example using pagination) and expect to work on all of them, <methodname>list()</methodname> or <methodname>uniqueResult()</methodname> are recommended. <methodname>list()</methodname> work best if the entity <literal>batch-size</literal> is set up properly. Note that Hibernate Search has to process all Lucene Hits elements (within the pagination) when using <methodname>list()</methodname> , <methodname>uniqueResult()</methodname> and <methodname>iterate()</methodname>."
msgstr ""

#. Tag: para
#: query.xml:913
#, no-c-format
msgid "If you wish to minimize Lucene document loading, <methodname>scroll()</methodname> is more appropriate. Don't forget to close the <classname>ScrollableResults</classname> object when you're done, since it keeps Lucene resources. If you expect to use <methodname>scroll,</methodname> but wish to load objects in batch, you can use <methodname>query.setFetchSize()</methodname>. When an object is accessed, and if not already loaded, Hibernate Search will load the next <literal>fetchSize</literal> objects in one pass."
msgstr ""

#. Tag: para
#: query.xml:923
#, no-c-format
msgid "Pagination is preferred over scrolling."
msgstr ""

#. Tag: title
#: query.xml:928
#, no-c-format
msgid "Result size"
msgstr ""

#. Tag: para
#: query.xml:930
#, no-c-format
msgid "It is sometime useful to know the total number of matching documents:"
msgstr ""

#. Tag: para
#: query.xml:935
#, no-c-format
msgid "for the Google-like feature \"1-10 of about 888,000,000\""
msgstr ""

#. Tag: para
#: query.xml:939
#, no-c-format
msgid "to implement a fast pagination navigation"
msgstr ""

#. Tag: para
#: query.xml:943
#, no-c-format
msgid "to implement a multi step search engine (adding approximation if the restricted query return no or not enough results)"
msgstr ""

#. Tag: para
#: query.xml:948
#, no-c-format
msgid "Of course it would be too costly to retrieve all the matching documents. Hibernate Search allows you to retrieve the total number of matching documents regardless of the pagination parameters. Even more interesting, you can retrieve the number of matching elements without triggering a single object load."
msgstr ""

#. Tag: title
#: query.xml:955
#, no-c-format
msgid "Determining the result size of a query"
msgstr ""

#. Tag: programlisting
#: query.xml:957
#, no-c-format
msgid ""
      "org.hibernate.search.FullTextQuery query = \n"
      "    s.createFullTextQuery( luceneQuery, Book.class );\n"
      "//return the number of matching books without loading a single one\n"
      "assert 3245 == <emphasis role=\"bold\">query.getResultSize()</emphasis>; \n"
      "\n"
      "org.hibernate.search.FullTextQuery query = \n"
      "    s.createFullTextQuery( luceneQuery, Book.class );\n"
      "query.setMaxResult(10);\n"
      "List results = query.list();\n"
      "//return the total number of matching books regardless of pagination\n"
      "assert 3245 == <emphasis role=\"bold\">query.getResultSize()</emphasis>;"
msgstr ""

#. Tag: para
#: query.xml:961
#, no-c-format
msgid "Like Google, the number of results is approximative if the index is not fully up-to-date with the database (asynchronous cluster for example)."
msgstr ""

#. Tag: title
#: query.xml:968
#, no-c-format
msgid "ResultTransformer"
msgstr ""

#. Tag: para
#: query.xml:970
#, no-c-format
msgid "As seen in <xref linkend=\"projections\"/> projection results are returns as <classname>Object</classname> arrays. This data structure is not always matching the application needs. In this cases It is possible to apply a <classname>ResultTransformer</classname> which post query execution can build the needed data structure:"
msgstr ""

#. Tag: title
#: query.xml:977
#, no-c-format
msgid "Using ResultTransformer in conjunction with projections"
msgstr ""

#. Tag: programlisting
#: query.xml:979
#, no-c-format
msgid ""
      "org.hibernate.search.FullTextQuery query = \n"
      "    s.createFullTextQuery( luceneQuery, Book.class );\n"
      "query.setProjection( \"title\", \"mainAuthor.name\" );\n"
      "\n"
      "<emphasis role=\"bold\">query.setResultTransformer( \n"
      "    new StaticAliasToBeanResultTransformer( \n"
      "        BookView.class, \n"
      "        \"title\", \n"
      "        \"author\" ) \n"
      ");</emphasis>\n"
      "List&lt;BookView&gt; results = (List&lt;BookView&gt;) query.list();\n"
      "for(BookView view : results) {\n"
      "    log.info( \"Book: \" + view.getTitle() + \", \" + view.getAuthor() );\n"
      "}"
msgstr ""

#. Tag: para
#: query.xml:982
#, no-c-format
msgid "Examples of <classname>ResultTransformer</classname> implementations can be found in the Hibernate Core codebase."
msgstr ""

#. Tag: title
#: query.xml:987
#, no-c-format
msgid "Understanding results"
msgstr ""

#. Tag: para
#: query.xml:989
#, no-c-format
msgid "You will find yourself sometimes puzzled by a result showing up in a query or a result not showing up in a query. Luke is a great tool to understand those mysteries. However, Hibernate Search also gives you access to the Lucene <classname>Explanation</classname> object for a given result (in a given query). This class is considered fairly advanced to Lucene users but can provide a good understanding of the scoring of an object. You have two ways to access the Explanation object for a given result:"
msgstr ""

#. Tag: para
#: query.xml:1000
#, no-c-format
msgid "Use the <methodname>fullTextQuery.explain(int)</methodname> method"
msgstr ""

#. Tag: para
#: query.xml:1005
#, no-c-format
msgid "Use projection"
msgstr ""

#. Tag: para
#: query.xml:1009
#, no-c-format
msgid "The first approach takes a document id as a parameter and return the Explanation object. The document id can be retrieved using projection and the <literal>FullTextQuery.DOCUMENT_ID</literal> constant."
msgstr ""

#. Tag: para
#: query.xml:1015
#, no-c-format
msgid "The Document id has nothing to do with the entity id. Do not mess up these two notions."
msgstr ""

#. Tag: para
#: query.xml:1019
#, no-c-format
msgid "The second approach let's you project the <classname>Explanation</classname> object using the <literal>FullTextQuery.EXPLANATION</literal> constant."
msgstr ""

#. Tag: title
#: query.xml:1024
#, no-c-format
msgid "Retrieving the Lucene Explanation object using projection"
msgstr ""

#. Tag: programlisting
#: query.xml:1027
#, no-c-format
msgid ""
      "FullTextQuery ftQuery = s.createFullTextQuery( luceneQuery, Dvd.class )\n"
      "        .setProjection( \n"
      "             FullTextQuery.DOCUMENT_ID, \n"
      "             <emphasis role=\"bold\">FullTextQuery.EXPLANATION</emphasis>, \n"
      "             FullTextQuery.THIS );\n"
      "@SuppressWarnings(\"unchecked\") List&lt;Object[]&gt; results = ftQuery.list();\n"
      "for (Object[] result : results) {\n"
      "    Explanation e = (Explanation) result[1];\n"
      "    display( e.toString() );\n"
      "}"
msgstr ""

#. Tag: para
#: query.xml:1030
#, no-c-format
msgid "Be careful, building the explanation object is quite expensive, it is roughly as expensive as running the Lucene query again. Don't do it if you don't need the object"
msgstr ""

#. Tag: title
#: query.xml:1037
#, no-c-format
msgid "Filters"
msgstr ""

#. Tag: para
#: query.xml:1039
#, no-c-format
msgid "Apache Lucene has a powerful feature that allows to filter query results according to a custom filtering process. This is a very powerful way to apply additional data restrictions, especially since filters can be cached and reused. Some interesting use cases are:"
msgstr ""

#. Tag: para
#: query.xml:1046
#, no-c-format
msgid "security"
msgstr ""

#. Tag: para
#: query.xml:1050
#, no-c-format
msgid "temporal data (eg. view only last month's data)"
msgstr ""

#. Tag: para
#: query.xml:1054
#, no-c-format
msgid "population filter (eg. search limited to a given category)"
msgstr ""

#. Tag: para
#: query.xml:1059
#, no-c-format
msgid "and many more"
msgstr ""

#. Tag: para
#: query.xml:1063
#, no-c-format
msgid "Hibernate Search pushes the concept further by introducing the notion of parameterizable named filters which are transparently cached. For people familiar with the notion of Hibernate Core filters, the API is very similar:"
msgstr ""

#. Tag: title
#: query.xml:1069
#, no-c-format
msgid "Enabling fulltext filters for a given query"
msgstr ""

#. Tag: programlisting
#: query.xml:1071
#, no-c-format
msgid ""
      "fullTextQuery = s.createFullTextQuery( query, Driver.class );\n"
      "fullTextQuery.enableFullTextFilter(\"bestDriver\");\n"
      "fullTextQuery.enableFullTextFilter(\"security\").setParameter( \"login\", \"andre\" );\n"
      "fullTextQuery.list(); //returns only best drivers where andre has credentials"
msgstr ""

#. Tag: para
#: query.xml:1074
#, no-c-format
msgid "In this example we enabled two filters on top of the query. You can enable (or disable) as many filters as you like."
msgstr ""

#. Tag: para
#: query.xml:1077
#, no-c-format
msgid "Declaring filters is done through the <classname>@FullTextFilterDef</classname> annotation. This annotation can be on any <literal>@Indexed</literal> entity regardless of the query the filter is later applied to. This implies that filter definitions are global and their names must be unique. A <classname>SearchException</classname> is thrown in case two different <classname>@FullTextFilterDef</classname> annotations with the same name are defined. Each named filter has to specify its actual filter implementation."
msgstr ""

#. Tag: title
#: query.xml:1088
#, no-c-format
msgid "Defining and implementing a Filter"
msgstr ""

#. Tag: programlisting
#: query.xml:1090
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed\n"
      "@FullTextFilterDefs( {\n"
      "    <emphasis role=\"bold\">@FullTextFilterDef(name = \"bestDriver\", impl = BestDriversFilter.class)</emphasis>, \n"
      "    <emphasis role=\"bold\">@FullTextFilterDef(name = \"security\", impl = SecurityFilterFactory.class)</emphasis> \n"
      "})\n"
      "public class Driver { ... }"
msgstr ""

#. Tag: programlisting
#: query.xml:1092
#, no-c-format
msgid ""
      "public class BestDriversFilter extends <emphasis\n"
      "          role=\"bold\">org.apache.lucene.search.Filter</emphasis> {\n"
      "\n"
      "    public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n"
      "        OpenBitSet bitSet = new OpenBitSet( reader.maxDoc() );\n"
      "        TermDocs termDocs = reader.termDocs( new Term( \"score\", \"5\" ) );\n"
      "        while ( termDocs.next() ) {\n"
      "            bitSet.set( termDocs.doc() );\n"
      "        }\n"
      "        return bitSet;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: query.xml:1095
#, no-c-format
msgid "<classname>BestDriversFilter</classname> is an example of a simple Lucene filter which reduces the result set to drivers whose score is 5. In this example the specified filter implements the <literal>org.apache.lucene.search.Filter</literal> directly and contains a no-arg constructor."
msgstr ""

#. Tag: para
#: query.xml:1101
#, no-c-format
msgid "If your Filter creation requires additional steps or if the filter you want to use does not have a no-arg constructor, you can use the factory pattern:"
msgstr ""

#. Tag: title
#: query.xml:1106
#, no-c-format
msgid "Creating a filter using the factory pattern"
msgstr ""

#. Tag: programlisting
#: query.xml:1108
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed\n"
      "@FullTextFilterDef(name = \"bestDriver\", impl = BestDriversFilterFactory.class)\n"
      "public class Driver { ... }\n"
      "\n"
      "public class BestDriversFilterFactory {\n"
      "\n"
      "    <emphasis role=\"bold\">@Factory</emphasis>\n"
      "    public Filter getFilter() {\n"
      "        //some additional steps to cache the filter results per IndexReader\n"
      "        Filter bestDriversFilter = new BestDriversFilter();\n"
      "        return new CachingWrapperFilter(bestDriversFilter);\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: query.xml:1111
#, no-c-format
msgid "Hibernate Search will look for a <literal>@Factory</literal> annotated method and use it to build the filter instance. The factory must have a no-arg constructor."
msgstr ""

#. Tag: para
#: query.xml:1115
#, no-c-format
msgid "Named filters come in handy where parameters have to be passed to the filter. For example a security filter might want to know which security level you want to apply:"
msgstr ""

#. Tag: title
#: query.xml:1120
#, no-c-format
msgid "Passing parameters to a defined filter"
msgstr ""

#. Tag: programlisting
#: query.xml:1122
#, no-c-format
msgid ""
      "fullTextQuery = s.createFullTextQuery( query, Driver.class );\n"
      "fullTextQuery.enableFullTextFilter(\"security\")<emphasis role=\"bold\">.setParameter( \"level\", 5 )</emphasis>;"
msgstr ""

#. Tag: para
#: query.xml:1125
#, no-c-format
msgid "Each parameter name should have an associated setter on either the filter or filter factory of the targeted named filter definition."
msgstr ""

#. Tag: title
#: query.xml:1129
#, no-c-format
msgid "Using parameters in the actual filter implementation"
msgstr ""

#. Tag: programlisting
#: query.xml:1131
#, no-c-format
msgid ""
      "public class SecurityFilterFactory {\n"
      "    private Integer level;\n"
      "\n"
      "    /**\n"
      "     * injected parameter\n"
      "     */\n"
      "    <emphasis role=\"bold\">public void setLevel(Integer level)</emphasis> {\n"
      "        this.level = level;\n"
      "    }\n"
      "\n"
      "    <emphasis role=\"bold\">@Key\n"
      "    public FilterKey getKey()</emphasis> {\n"
      "        StandardFilterKey key = new StandardFilterKey();\n"
      "        key.addParameter( level );\n"
      "        return key;\n"
      "    }\n"
      "\n"
      "    @Factory\n"
      "    public Filter getFilter() {\n"
      "        Query query = new TermQuery( new Term(\"level\", level.toString() ) );\n"
      "        return new CachingWrapperFilter( new QueryWrapperFilter(query) );\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: query.xml:1134
#, no-c-format
msgid "Note the method annotated <classname>@Key</classname> returning a <classname>FilterKey</classname> object. The returned object has a special contract: the key object must implement <methodname>equals()</methodname> / <methodname>hashCode()</methodname> so that 2 keys are equal if and only if the given <classname>Filter</classname> types are the same and the set of parameters are the same. In other words, 2 filter keys are equal if and only if the filters from which the keys are generated can be interchanged. The key object is used as a key in the cache mechanism."
msgstr ""

#. Tag: para
#: query.xml:1143
#, no-c-format
msgid "<classname>@Key</classname> methods are needed only if:"
msgstr ""

#. Tag: para
#: query.xml:1147
#, no-c-format
msgid "you enabled the filter caching system (enabled by default)"
msgstr ""

#. Tag: para
#: query.xml:1152
#, no-c-format
msgid "your filter has parameters"
msgstr ""

#. Tag: para
#: query.xml:1156
#, no-c-format
msgid "In most cases, using the <literal>StandardFilterKey</literal> implementation will be good enough. It delegates the <methodname>equals()</methodname> / <methodname>hashCode()</methodname> implementation to each of the parameters equals and hashcode methods."
msgstr ""

#. Tag: para
#: query.xml:1162
#, no-c-format
msgid "As mentioned before the defined filters are per default cached and the cache uses a combination of hard and soft references to allow disposal of memory when needed. The hard reference cache keeps track of the most recently used filters and transforms the ones least used to <classname>SoftReferences</classname> when needed. Once the limit of the hard reference cache is reached additional filters are cached as <classname>SoftReferences</classname>. To adjust the size of the hard reference cache, use <literal>hibernate.search.filter.cache_strategy.size</literal> (defaults to 128). For advanced use of filter caching, you can implement your own <classname>FilterCachingStrategy</classname>. The classname is defined by <literal>hibernate.search.filter.cache_strategy</literal>."
msgstr ""

#. Tag: para
#: query.xml:1175
#, no-c-format
msgid "This filter caching mechanism should not be confused with caching the actual filter results. In Lucene it is common practice to wrap filters using the <classname>IndexReader</classname> around a <classname>CachingWrapperFilter.</classname> The wrapper will cache the <classname>DocIdSet</classname> returned from the <methodname>getDocIdSet(IndexReader reader)</methodname> method to avoid expensive recomputation. It is important to mention that the computed <classname>DocIdSet</classname> is only cachable for the same <classname>IndexReader</classname> instance, because the reader effectively represents the state of the index at the moment it was opened. The document list cannot change within an opened <classname>IndexReader</classname>. A different/new<classname> IndexReader</classname> instance, however, works potentially on a different set of <classname>Document</classname>s (either from a different index or simply because the index has changed), hence the cached <classname>DocIdSet</classname> has to be recomputed."
msgstr ""

#. Tag: para
#: query.xml:1192
#, no-c-format
msgid "Hibernate Search also helps with this aspect of caching. Per default the <literal>cache</literal> flag of <classname>@FullTextFilterDef </classname>is set to <literal>FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS</literal> which will automatically cache the filter instance as well as wrap the specified filter around a Hibernate specific implementation of <classname>CachingWrapperFilter</classname>. In contrast to Lucene's version of this class <classname>SoftReference</classname>s are used together with a hard reference count (see discussion about filter cache). The hard reference count can be adjusted using <literal>hibernate.search.filter.cache_docidresults.size</literal> (defaults to 5). The wrapping behaviour can be controlled using the <literal>@FullTextFilterDef.cache</literal> parameter. There are three different values for this parameter:"
msgstr ""

#. Tag: entry
#: query.xml:1211
#, no-c-format
msgid "Value"
msgstr ""

#. Tag: entry
#: query.xml:1213
#, no-c-format
msgid "Definition"
msgstr ""

#. Tag: entry
#: query.xml:1219
#, no-c-format
msgid "FilterCacheModeType.NONE"
msgstr ""

#. Tag: entry
#: query.xml:1221
#, no-c-format
msgid "No filter instance and no result is cached by Hibernate Search. For every filter call, a new filter instance is created. This setting might be useful for rapidly changing data sets or heavily memory constrained environments."
msgstr ""

#. Tag: entry
#: query.xml:1228
#, no-c-format
msgid "FilterCacheModeType.INSTANCE_ONLY"
msgstr ""

#. Tag: entry
#: query.xml:1230
#, no-c-format
msgid "The filter instance is cached and reused across concurrent <methodname>Filter.getDocIdSet()</methodname> calls. <classname>DocIdSet</classname> results are not cached. This setting is useful when a filter uses its own specific caching mechanism or the filter results change dynamically due to application specific events making <classname>DocIdSet</classname> caching in both cases unnecessary."
msgstr ""

#. Tag: entry
#: query.xml:1242
#, no-c-format
msgid "FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS"
msgstr ""

#. Tag: entry
#: query.xml:1244
#, no-c-format
msgid "Both the filter instance and the <classname>DocIdSet</classname> results are cached. This is the default value."
msgstr ""

#. Tag: para
#: query.xml:1249
#, no-c-format
msgid "Last but not least - why should filters be cached? There are two areas where filter caching shines:"
msgstr ""

#. Tag: para
#: query.xml:1255
#, no-c-format
msgid "the system does not update the targeted entity index often (in other words, the IndexReader is reused a lot)"
msgstr ""

#. Tag: para
#: query.xml:1260
#, no-c-format
msgid "the Filter's DocIdSet is expensive to compute (compared to the time spent to execute the query)"
msgstr ""

#. Tag: title
#: query.xml:1266
#, no-c-format
msgid "Using filters in a sharded environment"
msgstr ""

#. Tag: para
#: query.xml:1268
#, no-c-format
msgid "It is possible, in a sharded environment to execute queries on a subset of the available shards. This can be done in two steps:"
msgstr ""

#. Tag: para
#: query.xml:1273
#, no-c-format
msgid "create a sharding strategy that does select a subset of <classname>IndexManager</classname>s depending on some filter configuration"
msgstr ""

#. Tag: para
#: query.xml:1279
#, no-c-format
msgid "activate the proper filter at query time"
msgstr ""

#. Tag: para
#: query.xml:1283
#, no-c-format
msgid "Let's first look at an example of sharding strategy that query on a specific customer shard if the customer filter is activated."
msgstr ""

#. Tag: programlisting
#: query.xml:1286
#, no-c-format
msgid ""
      "public class CustomerShardingStrategy implements IndexShardingStrategy {\n"
      "\n"
      " // stored IndexManagers in a array indexed by customerID\n"
      " private IndexManager[] indexManagers;\n"
      " \n"
      " public void initialize(Properties properties, IndexManager[] indexManagers) {\n"
      "   this.indexManagers = indexManagers;\n"
      " }\n"
      "\n"
      " public IndexManager[] getIndexManagersForAllShards() {\n"
      "   return indexManagers;\n"
      " }\n"
      "\n"
      " public IndexManager getIndexManagerForAddition(\n"
      "     Class&lt;?&gt; entity, Serializable id, String idInString, Document document) {\n"
      "   Integer customerID = Integer.parseInt(document.getFieldable(\"customerID\").stringValue());\n"
      "   return indexManagers[customerID];\n"
      " }\n"
      "\n"
      " public IndexManager[] getIndexManagersForDeletion(\n"
      "     Class&lt;?&gt; entity, Serializable id, String idInString) {\n"
      "   return getIndexManagersForAllShards();\n"
      " }\n"
      "\n"
      "  /**\n"
      "  * Optimization; don't search ALL shards and union the results; in this case, we \n"
      "  * can be certain that all the data for a particular customer Filter is in a single\n"
      "  * shard; simply return that shard by customerID.\n"
      "  */\n"
      " public IndexManager[] getIndexManagersForQuery(\n"
      "     FullTextFilterImplementor[] filters) {\n"
      "   FFullTextFilter filter = getCustomerFilter(filters, \"customer\");\n"
      "   if (filter == null) {\n"
      "     return getIndexManagersForAllShards();\n"
      "   }\n"
      "   else {\n"
      "     return new IndexManager[] { indexManagers[Integer.parseInt(\n"
      "       filter.getParameter(\"customerID\").toString())] };\n"
      "   }\n"
      " }\n"
      "\n"
      " private FullTextFilter getCustomerFilter(FullTextFilterImplementor[] filters, String name) {\n"
      "   for (FullTextFilterImplementor filter: filters) {\n"
      "     if (filter.getName().equals(name)) return filter;\n"
      "   }\n"
      "   return null;\n"
      " }\n"
      "}"
msgstr ""

#. Tag: para
#: query.xml:1288
#, no-c-format
msgid "In this example, if the filter named <literal>customer</literal> is present, we make sure to only use the shard dedicated to this customer. Otherwise, we return all shards. A given Sharding strategy can react to one or more filters and depends on their parameters."
msgstr ""

#. Tag: para
#: query.xml:1293
#, no-c-format
msgid "The second step is simply to activate the filter at query time. While the filter can be a regular filter (as defined in <xref linkend=\"query-filter\"/>) which also filters Lucene results after the query, you can make use of a special filter that will only be passed to the sharding strategy and otherwise ignored for the rest of the query. Simply use the <classname>ShardSensitiveOnlyFilter</classname> class when declaring your filter."
msgstr ""

#. Tag: programlisting
#: query.xml:1301
#, no-c-format
msgid ""
      "@Entity @Indexed\n"
      "<emphasis role=\"bold\">@FullTextFilterDef(name=\"customer\", impl=ShardSensitiveOnlyFilter.class)</emphasis>\n"
      "public class Customer {\n"
      "   ...\n"
      "}\n"
      "\n"
      "FullTextQuery query = ftEm.createFullTextQuery(luceneQuery, Customer.class);\n"
      "<emphasis role=\"bold\">query.enableFulltextFilter(\"customer\").setParameter(\"CustomerID\", 5);</emphasis>\n"
      "@SuppressWarnings(\"unchecked\")\n"
      "List&lt;Customer&gt; results = query.getResultList();"
msgstr ""

#. Tag: para
#: query.xml:1303
#, no-c-format
msgid "Note that by using the <classname>ShardSensitiveOnlyFilter</classname>, you do not have to implement any Lucene filter. Using filters and sharding strategy reacting to these filters is recommended to speed up queries in a sharded environment."
msgstr ""

#. Tag: title
#: query.xml:1312
#, no-c-format
msgid "Faceting"
msgstr ""

#. Tag: para
#: query.xml:1314
#, no-c-format
msgid "<ulink url=\"http://en.wikipedia.org/wiki/Faceted_search\">Faceted search</ulink> is a technique which allows to divide the results of a query into multiple categories. This categorisation includes the calculation of hit counts for each category and the ability to further restrict search results based on these facets (categories). <xref lang=\"\" linkend=\"example-amazon-facets\"/> shows a faceting example. The search results in fifteen hits which are displayed on the main part of the page. The navigation bar on the left, however, shows the category<emphasis> Computers &amp; Internet</emphasis> with its subcategories <emphasis>Programming</emphasis>, <emphasis>Computer Science</emphasis>, <emphasis>Databases</emphasis>, <emphasis>Software</emphasis>, <emphasis>Web Development,</emphasis> <emphasis>Networking</emphasis> and <emphasis>Home Computing</emphasis>. For each of these subcategories the number of books is shown matching the main search criteria and belonging to the respective subcategory. This division of the category <emphasis>Computers &amp; Internet</emphasis> is one concrete search facet. Another one is for example the average customer review."
msgstr ""

#. Tag: title
#: query.xml:1333
#, no-c-format
msgid "Search for <emphasis>'Hibernate Search'</emphasis> on Amazon"
msgstr ""

#. Tag: para
#: query.xml:1347
#, no-c-format
msgid "In Hibernate Search the classes <classname>QueryBuilder</classname> and <classname>FullTextQuery</classname> are the entry point into the faceting API. The former allows to create faceting requests whereas the latter gives access to the so called <classname>FacetManager</classname>. With the help of the <classname>FacetManager</classname> faceting requests can be applied on a query and selected facets can be added to an existing query in order to refine search results. The following sections will describe the faceting process in more detail. The examples will use the entity <classname>Cd</classname> as shown in <xref linkend=\"example-faceting-entity\"/>:"
msgstr ""

#. Tag: title
#: query.xml:1359
#, no-c-format
msgid "Entity Cd"
msgstr ""

#. Tag: programlisting
#: query.xml:1361
#, no-c-format
msgid ""
      "@Entity\n"
      "@Indexed\n"
      "public class Cd {\n"
      "\n"
      "    @Id\n"
      "    @GeneratedValue\n"
      "    private int id;\n"
      "\n"
      "    @Fields( {\n"
      "        @Field,\n"
      "        @Field(name = \"name_un_analyzed\", analyze = Analyze.NO)\n"
      "    })\n"
      "    private String name;\n"
      "\n"
      "    @Field(analyze = Analyze.NO)\n"
      "    @NumericField\n"
      "    private int price;\n"
      "\n"
      "    Field(analyze = Analyze.NO)\n"
      "    @DateBridge(resolution = Resolution.YEAR)\n"
      "    private Date releaseYear;\n"
      "\n"
      "    @Field(analyze = Analyze.NO)\n"
      "    private String label;\n"
      "\n"
      "\n"
      "// setter/getter\n"
      "..."
msgstr ""

#. Tag: title
#: query.xml:1365
#, no-c-format
msgid "Creating a faceting request"
msgstr ""

#. Tag: para
#: query.xml:1367
#, no-c-format
msgid "The first step towards a faceted search is to create the <classname>FacetingRequest</classname>. Currently two types of faceting requests are supported. The first type is called <emphasis>discrete faceting</emphasis> and the second type <emphasis>range faceting</emphasis> request. In the case of a discrete faceting request you specify on which index field you want to facet (categorize) and which faceting options to apply. An example for a discrete faceting request can be seen in <xref linkend=\"example-discrete-faceting\"/>:"
msgstr ""

#. Tag: title
#: query.xml:1378
#, no-c-format
msgid "Creating a discrete faceting request"
msgstr ""

#. Tag: programlisting
#: query.xml:1380
#, no-c-format
msgid ""
      "QueryBuilder builder = fullTextSession.getSearchFactory()\n"
      "    .buildQueryBuilder()\n"
      "        .forEntity( Cd.class )\n"
      "            .get();\n"
      "FacetingRequest labelFacetingRequest = builder.facet()\n"
      "    .name( \"labelFaceting\" )\n"
      "    .onField( \"label\")\n"
      "    .discrete()\n"
      "    .orderedBy( FacetSortOrder.COUNT_DESC )\n"
      "    .includeZeroCounts( false )\n"
      "    .maxFacetCount( 1 )\n"
      "    .createFacetingRequest();"
msgstr ""

#. Tag: para
#: query.xml:1383
#, no-c-format
msgid "When executing this faceting request a <classname>Facet</classname> instace will be created for each discrete value for the indexed field <constant>label</constant>. The <classname>Facet</classname> instance will record the actual field value including how often this particular field value occurs within the orginial query results. <methodname>orderedBy</methodname>, <methodname>includeZeroCounts</methodname> and <methodname>maxFacetCount</methodname> are optional parameters which can be applied on any faceting request. orderedBy allows to specify in which order the created facets will be returned. The default is <constant>FacetSortOrder.COUNT_DESC</constant>, but you can also sort on the field value or the order in which ranges were specified. <constant>includeZeroCount</constant> determines whether facets with a count of 0 will be included in the result (per default they are) and <constant>maxFacetCount</constant> allows to limit the maximum amount of facets returned."
msgstr ""

#. Tag: para
#: query.xml:1401
#, no-c-format
msgid "At the moment there are several preconditions an indexed field has to meet in order to apply faceting on it. The indexed property must be of type <classname>String</classname>, <classname>Date</classname> or a subtype of <classname>Number</classname> and <constant>null</constant> values should be avoided. Furthermore the property has to be indexed with <constant>Analyze.NO</constant> and in case of a numeric property <classname>@NumericField</classname> needs to be specified."
msgstr ""

#. Tag: para
#: query.xml:1411
#, no-c-format
msgid "The creation of a range faceting request is quite similar except that we have to specify ranges for the field values we are faceting on. A range faceting request can be seen in <xref linkend=\"example-range-faceting\"/> where three different price ranges are specified. <methodname>below</methodname> and <methodname>above</methodname> can only be specified once, but you can specify as many <methodname>from</methodname> - <methodname>to</methodname> ranges as you want. For each range boundary you can also specify via <methodname>excludeLimit</methodname> whether it is included into the range or not."
msgstr ""

#. Tag: title
#: query.xml:1423
#, no-c-format
msgid "Creating a range faceting request"
msgstr ""

#. Tag: programlisting
#: query.xml:1425
#, no-c-format
msgid ""
      "QueryBuilder builder = fullTextSession.getSearchFactory()\n"
      "    .buildQueryBuilder()\n"
      "        .forEntity( Cd.class )\n"
      "            .get();\n"
      "FacetingRequest priceacetingRequest = queryBuilder( Cd.class ).facet()\n"
      "    .name( \"priceFaceting\" )\n"
      "    .onField( \"price\" )\n"
      "    .range()\n"
      "    .below( 1000 )\n"
      "    .from( 1001 ).to( 1500 )\n"
      "    .above( 1500 ).excludeLimit()\n"
      "    .createFacetingRequest();"
msgstr ""

#. Tag: title
#: query.xml:1430 query.xml:1439
#, no-c-format
msgid "Applying a faceting request"
msgstr ""

#. Tag: para
#: query.xml:1432
#, no-c-format
msgid "In <xref linkend=\"section-creating-faceting-request\"/> we have seen how to create a faceting request. Now it is time to apply it on a query. The key is the <classname>FacetManager</classname> which can be retrieved via the <classname>FullTextQuery</classname> (see <xref linkend=\"example-applying-faceting\"/>)."
msgstr ""

#. Tag: programlisting
#: query.xml:1441
#, no-c-format
msgid ""
      "// create a fulltext query\n"
      "QueryBuilder builder = queryBuilder( Cd.class );\n"
      "Query luceneQuery = builder.all().createQuery(); // match all query\n"
      "FullTextQuery fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery, Cd.class );\n"
      "\n"
      "// retrieve facet manager and apply faceting request\n"
      "FacetManager facetManager = query.getFacetManager();\n"
      "facetManager.enableFaceting( priceFacetingRequest );\n"
      "\n"
      "// get the list of Cds \n"
      "List&lt;Cd&gt; cds = fullTextQuery.list();\n"
      "...\n"
      "\n"
      "// retrieve the faceting results\n"
      "List&lt;Facet&gt; facets = facetManager.getFacets( \"priceFaceting\" );\n"
      "..."
msgstr ""

#. Tag: para
#: query.xml:1444
#, no-c-format
msgid "You can enable as many faceting requests as you like and retrieve them afterwards via <methodname>getFacets()</methodname> specifiying the faceting request name. There is also a <methodname>disableFaceting()</methodname> method which allows you to disable a faceting request by specifying its name."
msgstr ""

#. Tag: title
#: query.xml:1452
#, no-c-format
msgid "Restricting query results"
msgstr ""

#. Tag: para
#: query.xml:1454
#, no-c-format
msgid "Last but not least, you can apply any of the returned <classname>Facet</classname>s as additional criteria on your original query in order to implement a \"drill-down\" functionality. For this purpose <classname>FacetSelection</classname> can be utilized. <classname>FacetSelections</classname> are available via the <classname>FacetManager</classname> and allow you to select a facet as query criteria (<methodname>selectFacets</methodname>), remove a facet restriction (<methodname>deselectFacets</methodname>), remove all facet restrictions (<methodname>clearSelectedFacets</methodname>) and retrieve all currently selected facets (<methodname>getSelectedFacets</methodname>). <xref linkend=\"example-restricting-query-results\"/> shows an example."
msgstr ""

#. Tag: title
#: query.xml:1468
#, no-c-format
msgid "Restricting query results via the application of a <classname>FacetSelection</classname>"
msgstr ""

#. Tag: programlisting
#: query.xml:1471
#, no-c-format
msgid ""
      "// create a fulltext query\n"
      "QueryBuilder builder = queryBuilder( Cd.class );\n"
      "Query luceneQuery = builder.all().createQuery(); // match all query\n"
      "FullTextQuery fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery, clazz );\n"
      "\n"
      "// retrieve facet manager and apply faceting request\n"
      "FacetManager facetManager = query.getFacetManager();\n"
      "facetManager.enableFaceting( priceFacetingRequest );\n"
      "\n"
      "// get the list of Cd \n"
      "List&lt;Cd&gt; cds = fullTextQuery.list();\n"
      "assertTrue(cds.size() == 10);\n"
      "\n"
      "// retrieve the faceting results\n"
      "List&lt;Facet&gt; facets = facetManager.getFacets( \"priceFaceting\" );\n"
      "assertTrue(facets.get(0).getCount() == 2)\n"
      "\n"
      "// apply first facet as additional search criteria\n"
      "facetManager.getFacetGroup( \"priceFaceting\" ).selectFacets( facets.get( 0 ) );\n"
      "\n"
      "// re-execute the query\n"
      "cds = fullTextQuery.list();\n"
      "assertTrue(cds.size() == 2);"
msgstr ""

#. Tag: title
#: query.xml:1477
#, no-c-format
msgid "Optimizing the query process"
msgstr ""

#. Tag: para
#: query.xml:1479
#, no-c-format
msgid "Query performance depends on several criteria:"
msgstr ""

#. Tag: para
#: query.xml:1483
#, no-c-format
msgid "the Lucene query itself: read the literature on this subject"
msgstr ""

#. Tag: para
#: query.xml:1488
#, no-c-format
msgid "the number of object loaded: use pagination (always ;-) ) or index projection (if needed)"
msgstr ""

#. Tag: para
#: query.xml:1493
#, no-c-format
msgid "the way Hibernate Search interacts with the Lucene readers: defines the appropriate <xref linkend=\"search-architecture-readerstrategy\"/>."
msgstr ""

#. Tag: para
#: query.xml:1499
#, no-c-format
msgid "caching frequently extracted values from the index: see <xref linkend=\"query-fieldcaches\"/>."
msgstr ""

#. Tag: title
#: query.xml:1505
#, no-c-format
msgid "Caching index values: FieldCache"
msgstr ""

#. Tag: para
#: query.xml:1507
#, no-c-format
msgid "The primary function of a Lucene index is to identify matches to your queries, still after the query is performed the results must be analyzed to extract useful information: typically Hibernate Search might need to extract the Class type and the primary key."
msgstr ""

#. Tag: para
#: query.xml:1512
#, no-c-format
msgid "Extracting the needed values from the index has a performance cost, which in some cases might be very low and not noticeable, but in some other cases might be a good candidate for caching."
msgstr ""

#. Tag: para
#: query.xml:1516
#, no-c-format
msgid "What is exactly needed depends on the kind of Projections being used (see <xref linkend=\"projections\"/>), and in some cases the Class type is not needed as it can be inferred from the query context or other means."
msgstr ""

#. Tag: para
#: query.xml:1521
#, no-c-format
msgid "Using the @<classname>CacheFromIndex</classname> annotation you can experiment different kinds of caching of the main metadata fields required by Hibernate Search:"
msgstr ""

#. Tag: programlisting
#: query.xml:1525
#, no-c-format
msgid ""
      "import static org.hibernate.search.annotations.FieldCacheType.CLASS;\n"
      "import static org.hibernate.search.annotations.FieldCacheType.ID;\n"
      "\n"
      "@Indexed\n"
      "@CacheFromIndex( { CLASS, ID } )\n"
      "public class Essay {\n"
      "    ..."
msgstr ""

#. Tag: para
#: query.xml:1527
#, no-c-format
msgid "It is currently possible to cache Class types and IDs using this annotation:"
msgstr ""

#. Tag: para
#: query.xml:1532
#, no-c-format
msgid "<constant>CLASS</constant>: Hibernate Search will use a Lucene FieldCache to improve peformance of the Class type extraction from the index."
msgstr ""

#. Tag: para
#: query.xml:1536
#, no-c-format
msgid "This value is enabled by default, and is what Hibernate Search will apply if you don't specify the @<classname>CacheFromIndex</classname> annotation."
msgstr ""

#. Tag: para
#: query.xml:1542
#, no-c-format
msgid "<constant>ID</constant>: Extracting the primary identifier will use a cache. This is likely providing the best performing queries, but will consume much more memory which in turn might reduce performance."
msgstr ""

#. Tag: para
#: query.xml:1550
#, no-c-format
msgid "Measure the performance and memory consumption impact after warmup (executing some queries): enabling Field Caches is likely to improve performance but this is not always the case."
msgstr ""

#. Tag: para
#: query.xml:1555
#, no-c-format
msgid "Using a FieldCache has two downsides to consider:"
msgstr ""

#. Tag: para
#: query.xml:1559
#, no-c-format
msgid "Memory usage: these caches can be quite memory hungry. Typically the CLASS cache has lower requirements than the ID cache."
msgstr ""

#. Tag: para
#: query.xml:1565
#, no-c-format
msgid "Index warmup: when using field caches, the first query on a new index or segment will be slower than when you don't have caching enabled."
msgstr ""

#. Tag: para
#: query.xml:1571
#, no-c-format
msgid "With some queries the classtype won't be needed at all, in that case even if you enabled the <constant>CLASS</constant> field cache, this might not be used; for example if you are targeting a single class, obviously all returned values will be of that type (this is evaluated at each Query execution)."
msgstr ""

#. Tag: para
#: query.xml:1577
#, no-c-format
msgid "For the ID FieldCache to be used, the ids of targeted entities must be using a <classname>TwoWayFieldBridge</classname> (as all builting bridges), and all types being loaded in a specific query must use the fieldname for the id, and have ids of the same type (this is evaluated at each Query execution)."
msgstr ""

