<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Hibernate, Relational Persistence for Idiomatic Java
  ~
  ~  Copyright (c) 2010, Red Hat, Inc. and/or its affiliates or third-party contributors as
  ~  indicated by the @author tags or express copyright attribution
  ~  statements applied by the authors.  All third-party contributions are
  ~  distributed under license by Red Hat, Inc.
  ~
  ~  This copyrighted material is made available to anyone wishing to use, modify,
  ~  copy, or redistribute it subject to the terms and conditions of the GNU
  ~  Lesser General Public License, as published by the Free Software Foundation.
  ~
  ~  This program is distributed in the hope that it will be useful,
  ~  but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~  for more details.
  ~
  ~  You should have received a copy of the GNU Lesser General Public License
  ~  along with this distribution; if not, write to:
  ~  Free Software Foundation, Inc.
  ~  51 Franklin Street, Fifth Floor
  ~  Boston, MA  02110-1301  USA
  -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="search-query" xreflabel="Querying">
  <title>Querying</title>

  <para>The second most important capability of Hibernate Search is the
  ability to execute a Lucene query and retrieve entities managed by an
  Hibernate session, providing the power of Lucene without leaving the
  Hibernate paradigm, and giving another dimension to the Hibernate classic
  search mechanisms (HQL, Criteria query, native SQL query). Preparing and
  executing a query consists of four simple steps:</para>

  <itemizedlist>
    <listitem>
      <para>Creating a <classname>FullTextSession</classname></para>
    </listitem>

    <listitem>
      <para>Creating a Lucene query either via the Hibernate Search query DSL
      (recommended) or from scratch</para>
    </listitem>

    <listitem>
      <para>Wrapping the Lucene query using a
      <classname>org.hibernate.Query</classname></para>
    </listitem>

    <listitem>
      <para>Executing the search by calling for example
      <methodname>list()</methodname> or
      <methodname>scroll()</methodname></para>
    </listitem>
  </itemizedlist>

  <para>To access the querying facilities, you have to use an
  <classname>FullTextSession</classname>. This Search specific session wraps a
  regular <classname>org.hibernate.Session</classname> to provide query and
  indexing capabilities.</para>

  <example>
    <title>Creating a FullTextSession</title>

    <programlisting language="JAVA" role="JAVA">Session session = sessionFactory.openSession();
...
FullTextSession fullTextSession = Search.getFullTextSession(session);    </programlisting>
  </example>

  <para>You then have two options to build the full-text query: the Hibernate
  Search query DSL or the native Lucene query.</para>

  <para>If you use the Hibernate Search query DSL, it will look like
  this:</para>

  <programlisting language="JAVA" role="JAVA"><emphasis role="bold">final QueryBuilder b = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity( Myth.class ).get();

org.apache.lucene.search.Query luceneQuery =
    b.keyword()
        .onField("history").boostedTo(3)
        .matching("storm")
        .createQuery();</emphasis>

org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery );
List result = fullTextQuery.list(); //return a list of managed objects    </programlisting>

  <para>You can alternatively write your Lucene query by hand either using the
  query parser or the programmatic API. If you are considering the
  programmatic API, we highly encourage you to use the Hibernate Search query
  DSL (or a mix of both).</para>

  <example>
    <title>Creating a Lucene query from scratch via the query parser</title>

    <programlisting language="JAVA" role="JAVA"><emphasis role="bold">SearchFactory searchFactory = fullTextSession.getSearchFactory();
org.apache.lucene.queryParser.QueryParser parser = 
    new QueryParser("title", searchFactory.getAnalyzer(Myth.class) );
try {
    org.apache.lucene.search.Query luceneQuery = parser.parse( "history:storm^3" );
}
catch (ParseException e) {
    //handle parsing failure
}</emphasis>

org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery(luceneQuery);
List result = fullTextQuery.list(); //return a list of managed objects    </programlisting>
  </example>

  <para>The Hibernate query built on top of the Lucene query is a regular
  <literal>org.hibernate.Query</literal>, which means you are in the same
  paradigm as the other Hibernate query facilities (HQL, Native or Criteria).
  The regular <literal>list()</literal> , <literal>uniqueResult()</literal>,
  <literal>iterate()</literal> and <literal>scroll()</literal> methods can be
  used.</para>

  <para>In case you are using the Java Persistence APIs of Hibernate, the same
  extensions exist:</para>

  <example>
    <title>Creating a Search query using the JPA API</title>

    <programlisting language="JAVA" role="JAVA">EntityManager em = entityManagerFactory.createEntityManager();

FullTextEntityManager fullTextEntityManager = 
    org.hibernate.search.jpa.Search.getFullTextEntityManager(em);

...
final QueryBuilder b = fullTextEntityManager.getSearchFactory()
    .buildQueryBuilder().forEntity( Myth.class ).get();

org.apache.lucene.search.Query luceneQuery =
    b.keyword()
        .onField("history").boostedTo(3)
        .matching("storm")
        .createQuery();
<emphasis role="bold">javax.persistence.Query fullTextQuery = 
    fullTextEntityManager.createFullTextQuery( luceneQuery );</emphasis>

List result = fullTextQuery.getResultList(); //return a list of managed objects  </programlisting>
  </example>

  <para>The following examples we will use the Hibernate APIs but the same
  example can be easily rewritten with the Java Persistence API by just
  adjusting the way the <classname>FullTextQuery</classname> is
  retrieved.</para>

  <section>
    <title>Building queries</title>

    <para>Hibernate Search queries are built on top of Lucene queries which
    gives you total freedom on the type of Lucene query you want to execute.
    However, once built, Hibernate Search wraps further query processing using
    <classname>org.hibernate.Query</classname> as your primary query
    manipulation API.</para>

    <section>
      <title>Building a Lucene query from scratch</title>

      <para>You have several options: use the query parser (fine for simple
      queries) or the Lucene programmatic API (for more complex use cases).
      Particularly if you plan on using the programmatic API, we highly
      recommend you have a look at the Hibernate Search query DSL.</para>

      <para>It is out of the scope of this documentation on how to exactly
      build a Lucene query. Please refer to the online Lucene documentation or
      get hold of a copy of either Lucene In Action or Hibernate Search in
      Action.</para>
    </section>

    <section id="search-query-querydsl">
      <title>Building a Lucene query with Hibernate Search query DSL</title>

      <para>Writing full-text queries with the Lucene programmatic API is
      quite complex. It's even more complex to understand the code once
      written. Besides the inherent API complexity, you have to remember to
      convert your parameters to their string equivalent as well as make sure
      to apply the correct analyzer to the right field (a ngram analyzer will
      for example use several ngrams as the tokens for a given word and should
      be searched as such).</para>

      <para>Hibernate Search query DSL make use of a style of API called a
      fluent API. This is a fancy name for an API that has a few key
      characteristics:</para>

      <itemizedlist>
        <listitem>
          <para>it has meaningful method names making a succession of
          operations reads almost like English</para>
        </listitem>

        <listitem>
          <para>it limits the options offered to what makes sense in a given
          context (thanks to strong typing and IDE autocompletion).</para>
        </listitem>

        <listitem>
          <para>It often uses the chaining method pattern</para>
        </listitem>

        <listitem>
          <para>it's easy to use</para>
        </listitem>

        <listitem>
          <para>it's even easier to read</para>
        </listitem>
      </itemizedlist>

      <para>Let's see how to use the API. You first need to create a query
      builder that is attached to a given indexed entity type. This
      <classname>QueryBuilder</classname> will know what analyzer to use and
      what field bridge to apply. You can create several
      <classname>QueryBuilder</classname>s (one for each entity type involved
      in the root of your query. You get the
      <classname>QueryBuilder</classname> from the
      <classname>SearchFactory</classname>.</para>

      <programlisting language="JAVA" role="JAVA">QueryBuilder mythQB = searchFactory
    .buildQueryBuilder().forEntity( Myth.class ).get();</programlisting>

      <para>You can also override the analyzer used for a given field or
      fields. This is rarely needed and should be avoided unless you know what
      you are doing (like many things :)).</para>

      <programlisting language="JAVA" role="JAVA">QueryBuilder mythQB = searchFactory.buildQueryBuilder()
    .forEntity( Myth.class )
        .overridesForField("history","stem_analyzer_definition")
    .get();</programlisting>

      <para>From the query builder, you are then ready to... build queries.
      What's interesting is that we build Lucene queries: you can easily mix
      and match Lucene's query parser generated <classname>Query</classname>
      objects or a <classname>Query</classname> object you have assembled with
      the Lucene programmatic API and use them with the Hibernate Search DSL
      should the DSL be missing some queries.</para>

      <para>Here is how you search for a specific word:</para>

      <programlisting language="JAVA" role="JAVA">Query luceneQuery = 
    mythQB.keyword().onField("history").matching("storm").createQuery();</programlisting>

      <para><methodname>keyword()</methodname> means that you are trying to
      find a specific word. <methodname>onField()</methodname> tells in which
      Lucene field to look. <methodname>matching()</methodname> tells what to
      look for. And finally <methodname>createQuery()</methodname> does create
      the Lucene query object. A lot is going on with this line of
      code.</para>

      <itemizedlist>
        <listitem>
          <para>The value storm is passed through the
          <literal>history</literal> <classname>FieldBridge</classname>: it
          does not matter here but you will see that it's quite handy when
          dealing with numbers or dates.</para>
        </listitem>

        <listitem>
          <para>The field bridge value is then passed to the analyzer used to
          index <literal>history</literal>. This ensures that the query uses
          the same term transformation than the indexing (lower case, n-gram,
          stemming and so on). If the analyzing process generates several
          terms for a given word, a boolean query is used with the
          <literal>SHOULD</literal> logic (roughly an <literal>OR</literal>
          logic).</para>
        </listitem>
      </itemizedlist>

      <para>Let's see how you can search a property that is not of type
      string.</para>

      <programlisting language="JAVA" role="JAVA">@Entity @Indexed 
public class Myth {
  @Field(index = Index.UN_TOKENIZED) @DateBridge(resolution = Resolution.YEAR)
  public Date getCreationDate() { return creationDate; }
  public Date setCreationDate(Date creationDate) { this.creationDate = creationDate; }
  private Date creationDate;
  
  [...]
}

Date birthdate = ...;
Query luceneQuery = 
    mythQb.keywork().onField("creationDate").matching(birthdate).createQuery();
</programlisting>

      <note>
        <para>In plain Lucene, you would have had to convert the
        <classname>Date</classname> object to its string representation (in
        this case the year).</para>
      </note>

      <para>This works for any object, not just <classname>Date</classname>,
      provided that the <classname>FieldBridge</classname> has an
      <methodname>objectToString</methodname> method (all built-in
      <classname>FieldBridge</classname> implementations do).</para>

      <para>Let's now have a look at how to search a field that uses ngram
      analyzers. ngram analyzers do index the succession of ngrams of your
      words which helps to recover from user typos. For example the 3-grams of
      the word hibernate are hib, ibe, ber, rna, nat, ate.</para>

      <programlisting language="JAVA" role="JAVA">@AnalyzerDef(name = "ngram",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class ),
  filters = {
    @TokenFilterDef(factory = StandardFilterFactory.class),
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = StopFilterFactory.class),
    @TokenFilterDef(factory = NGramFilterFactory.class,
      params = { 
        @Parameter(name = "minGramSize", value = "3"),
        @Parameter(name = "maxGramSize", value = "3") } )
  }
)
@Entity @Indexed 
public class Myth {
  @Field(analyzer=@Analyzer(definition="ngram") 
  @DateBridge(resolution = Resolution.YEAR)
  public String getName() { return name; }
  public String setName(Date name) { this.name = name; }
  private String name;
  
  [...]
}

Date birthdate = ...;
Query luceneQuery = mythQb.keyword().onField("name").matching("Sisiphus").createQuery();
</programlisting>

      <para>The matching word "Sisiphus" will be lower-cased and then split
      into 3-grams: sis, isi, sip, phu, hus. Each of these n-gram will be part
      of the query. We will then be able to find the Sysiphus myth (with a
      <literal>y</literal>). All that is transparently done for you.</para>

      <note>
        <para>If for some reason you do not want a specific field to use the
        field bridge or the analyzer you can call the
        <methodname>ignoreAnalyzer()</methodname> or
        <methodname>ignoreFieldBridge()</methodname> functions</para>
      </note>

      <para>To search for multiple possible words in the same field, simply
      add them all in the matching clause.</para>

      <programlisting language="JAVA" role="JAVA">//search document with storm or lightning in their history
Query luceneQuery = 
    mythQB.keyword().onField("history").matching("storm lightning").createQuery();</programlisting>

      <para>To search the same word on multiple fields, use the
      <methodname>onFields</methodname> method.</para>

      <programlisting language="JAVA" role="JAVA">Query luceneQuery = mythQB
    .keyword()
    .onFields("history","description","name")
    .matching("storm")
    .createQuery();</programlisting>

      <para>Sometimes, one field should be treated differently from another
      field even if searching the same term, you can use the
      <methodname>andField()</methodname> method for that.</para>

      <programlisting language="JAVA" role="JAVA">Query luceneQuery = mythQB.keyword()
    .onField("history")
    .andField("name")
      .boostedTo(5)
    .andField("description")
    .matching("storm")
    .createQuery();</programlisting>

      <para>In the previous example, only field name is boosted to 5.</para>

      <para>To do a fuzzy query (using the Levenshtein distance), start as a
      <literal>keyword</literal> query and add the fuzzy flag.</para>

      <programlisting language="JAVA" role="JAVA">Query luceneQuery = mythQB
    .keyword()
      .fuzzy()
        .withThreshold( .8f )
        .withPrefixLength( 1 )
    .onField("history")
    .matching("starm")
    .createQuery();</programlisting>

      <para><literal>threshold</literal> is the limit above which two terms
      are considering matching. It's a decimal between 0 and 1 and defaults to
      0.5. <literal>prefixLength</literal> is the length of the prefix ignored
      by the "fuzzyness": while it defaults to 0, a non zero value is
      recommended for indexes containing a huge amount of distinct
      terms.</para>

      <para>You can also do wildcard queries (queries where some of parts of
      the word are unknown. <literal>?</literal> represents a single character
      and <literal>*</literal> represents any character sequence. Note that
      for performance purposes, it is recommended that the query does not
      start with either <literal>?</literal> or <literal>*</literal>.</para>

      <programlisting language="JAVA" role="JAVA">Query luceneQuery = mythQB
    .keyword()
      .wildcard()
    .onField("history")
    .matching("sto*")
    .createQuery();</programlisting>

      <note>
        <para>Wildcard queries do not apply the analyzer on the matching
        terms. Otherwise the risk of <literal>*</literal> or
        <literal>?</literal> being mangled is too high.</para>
      </note>

      <para>So far we have been looking for words or sets of words, you can
      also search exact or approximate sentences. Use the
      <methodname>phrase()</methodname> query.</para>

      <programlisting language="JAVA" role="JAVA">Query luceneQuery = mythQB
    .phrase()
    .onField("history")
    .matching("Thou shalt not kill")
    .createQuery();</programlisting>

      <para>You can search approximate sentences by adding a slop factor. The
      slop factor represents the number of other words permitted in the
      sentence: this works like a within or near operator</para>

      <programlisting language="JAVA" role="JAVA">Query luceneQuery = mythQB
    .phrase()
      .withSlop(3)
    .onField("history")
    .matching("Thou kill")
    .createQuery();</programlisting>

      <para>We are done with queries related to a given word. You can also do
      range queries (on numbers, dates, strings etc). You can look for a value
      in between boundaries (included or not) and for a value below or above a
      given boundary (included or not).</para>

      <programlisting language="JAVA" role="JAVA">//look for 0 &lt;= starred &lt; 3
Query luceneQuery = mythQB
    .range()
    .onField("starred")
    .from(0).to(3).excludeLimit()
    .createQuery();

//look for myths strictly BC
Date beforeChrist = ...;
Query luceneQuery = mythQB
    .range()
    .onField("creationDate")
    .below(beforeChrist).excludeLimit()
    .createQuery();</programlisting>

      <para>Finally, you can aggregate queries together to create more complex
      queries. These aggregation operators are known as boolean queries where
      the operators are:</para>

      <itemizedlist>
        <listitem>
          <para><literal>SHOULD</literal>: the query query should contain the
          matching elements of the subquery</para>
        </listitem>

        <listitem>
          <para><literal>MUST</literal>: the query must contain the matching
          elements of the subquery</para>
        </listitem>

        <listitem>
          <para><literal>MUST NOT</literal>: the query must not contain the
          matching elements of the subquery</para>
        </listitem>
      </itemizedlist>

      <para>The subqueries can be any Lucene query including a boolean query
      itself. Let's look at a few examples:<programlisting><!--TODO role JAVA fails here. needs to investigate-->//look for popular modern myths that are not urban
Date twentiethCentury = ...;
Query luceneQuery = mythQB
    .bool()
      .must( mythQB.keyword().onField("description").matching("urban").createQuery() )
        .not()
      .must( mythQB.range().onField("starred").above(4).createQuery() )
      .must( mythQB
        .range()
        .onField("creationDate")
        .above(twentiethCentury)
        .createQuery() )
    .createQuery();

//look for popular myths that are preferably urban
Query luceneQuery = mythQB
    .bool()
      .should( mythQB.keyword().onField("description").matching("urban").createQuery() )
      .must( mythQB.range().onField("starred").above(4).createQuery() )
    .createQuery();

//look for all myths except religious ones
Query luceneQuery = mythQB
    .all()
      .except( monthQb
        .keyword()
        .onField( "description_stem" 
        .matching( "religion" )
        .createQuery() 
      )
    .createQuery();</programlisting></para>

      <para>You can apply some options to query types and fields:</para>

      <itemizedlist>
        <listitem>
          <para><methodname>boostedTo</methodname> (on query type and on
          field): boost the whole query or the specific field to a given
          factor</para>
        </listitem>

        <listitem>
          <para><methodname>withConstantScore</methodname> (on query): all
          results matching the query have a constant score equals to the
          boost</para>
        </listitem>

        <listitem>
          <para><methodname>filteredBy(Filter) </methodname>(on query): filter
          query results using the <classname>Filter</classname>
          instance</para>
        </listitem>

        <listitem>
          <para><methodname>ignoreAnalyzer</methodname> (on field): ignore the
          analyzer when processing this field</para>
        </listitem>

        <listitem>
          <para><methodname>ignoreFieldBridge</methodname> (on field): ignore
          field bridge when processing this field</para>
        </listitem>
      </itemizedlist>

      <para>Let's check out an example using some of these options</para>

      <programlisting language="JAVA" role="JAVA">Query luceneQuery = mythQB
    .bool()
      .should( mythQB.keyword().onField("description").matching("urban").createQuery() )
      .should( mythQB
        .keyword()
        .onField("name")
          .boostedTo(3)
          .ignoreAnalyzer()
        .matching("urban").createQuery() )
      .must( mythQB
        .range()
          .boostedTo(5).withConstantScore()
        .onField("starred").above(4).createQuery() )
    .createQuery();
</programlisting>

      <para>As you can see, Hibernate Search query DSL is a fairly high and
      easy to read query API. By accepting and producing Lucene queries, you
      can easily incorporate query types not (yet) supported by the DSL.
      Please give us feedback!</para>
    </section>

    <section>
      <title>Building a Hibernate Search query</title>

      <para>Let's now see how to build the Hibernate Search query from the
      Lucene one.</para>

      <section>
        <title>Generality</title>

        <para>Once the Lucene query is built, it needs to be wrapped into an
        Hibernate Query.</para>

        <example>
          <title>Wrapping a Lucene query into a Hibernate Query</title>

          <programlisting language="JAVA" role="JAVA">FullTextSession fullTextSession = Search.getFullTextSession( session );
org.hibernate.Query fullTextQuery = 
    fullTextSession.createFullTextQuery( luceneQuery );</programlisting>
        </example>

        <para>If not specified otherwise, the query will be executed against
        all indexed entities, potentially returning all types of indexed
        classes. It is advised, from a performance point of view, to restrict
        the returned types:</para>

        <example>
          <title>Filtering the search result by entity type</title>

          <programlisting language="JAVA" role="JAVA">org.hibernate.Query fullTextQuery = 
    fullTextSession.createFullTextQuery( luceneQuery, Customer.class );

// or

fullTextQuery = 
    fullTextSession.createFullTextQuery( luceneQuery, Item.class, Actor.class );</programlisting>
        </example>

        <para>The first example returns only matching
        <classname>Customer</classname>s, the second returns matching
        <classname>Actor</classname>s and <classname>Item</classname>s. The
        type restriction is fully polymorphic which means that if there are
        two indexed subclasses <classname>Salesman</classname> and
        <classname>Customer</classname> of the baseclass
        <classname>Person</classname>, it is possible to just specify
        <classname>Person.class</classname> in order to filter on result
        types.</para>
      </section>

      <section>
        <title>Pagination</title>

        <para>Out of performance reasons it is recommended to restrict the
        number of returned objects per query. In fact is a very common use
        case anyway that the user navigates from one page to an other. The way
        to define pagination is exactly the way you would define pagination in
        a plain HQL or Criteria query.</para>

        <example>
          <title>Defining pagination for a search query</title>

          <programlisting language="JAVA" role="JAVA">org.hibernate.Query fullTextQuery = 
    fullTextSession.createFullTextQuery( luceneQuery, Customer.class );
fullTextQuery.setFirstResult(15); //start from the 15th element
fullTextQuery.setMaxResults(10); //return 10 elements</programlisting>
        </example>

        <note>
          <para>It is still possible to get the total number of matching
          elements regardless of the pagination via
          <methodname>fulltextQuery.</methodname><methodname>getResultSize()</methodname></para>
        </note>
      </section>

      <section>
        <title>Sorting</title>

        <para>Apache Lucene provides a very flexible and powerful way to sort
        results. While the default sorting (by relevance) is appropriate most
        of the time, it can be interesting to sort by one or several other
        properties. In order to do so set the Lucene Sort object to apply a
        Lucene sorting strategy.</para>

        <example>
          <title>Specifying a Lucene <classname>Sort</classname> in order to
          sort the results</title>

          <programlisting language="JAVA" role="JAVA">
org.hibernate.search.FullTextQuery query = s.createFullTextQuery( query, Book.class );
org.apache.lucene.search.Sort sort = new Sort(new SortField("title"));
<emphasis role="bold">query.setSort(sort);</emphasis>
List results = query.list();
</programlisting>
        </example>

        <para>One can notice the <classname>FullTextQuery</classname>
        interface which is a sub interface of
        <classname>org.hibernate.Query</classname>. Be aware that fields used
        for sorting must not be tokenized.</para>
      </section>

      <section>
        <title>Fetching strategy</title>

        <para>When you restrict the return types to one class, Hibernate
        Search loads the objects using a single query. It also respects the
        static fetching strategy defined in your domain model.</para>

        <para>It is often useful, however, to refine the fetching strategy for
        a specific use case.</para>

        <example>
          <title>Specifying <classname>FetchMode</classname> on a
          query</title>

          <programlisting language="JAVA" role="JAVA">Criteria criteria = 
    s.createCriteria( Book.class ).setFetchMode( "authors", FetchMode.JOIN );
s.createFullTextQuery( luceneQuery ).setCriteriaQuery( criteria );</programlisting>
        </example>

        <para>In this example, the query will return all Books matching the
        luceneQuery. The authors collection will be loaded from the same query
        using an SQL outer join.</para>

        <para>When defining a criteria query, it is not needed to restrict the
        entity types returned while creating the Hibernate Search query from
        the full text session: the type is guessed from the criteria query
        itself. Only fetch mode can be adjusted, refrain from applying any
        other restriction.</para>

        <para>One cannot use <methodname>setCriteriaQuery</methodname> if more
        than one entity type is expected to be returned.</para>
      </section>

      <section id="projections">
        <title>Projection</title>

        <para>For some use cases, returning the domain object (graph) is
        overkill. Only a small subset of the properties is necessary.
        Hibernate Search allows you to return a subset of properties:</para>

        <example>
          <title>Using projection instead of returning the full domain
          object</title>

          <programlisting>org.hibernate.search.FullTextQuery query = 
    s.createFullTextQuery( luceneQuery, Book.class );
query.<emphasis role="bold">setProjection( "id", "summary", "body", "mainAuthor.name" )</emphasis>;
List results = query.list();
Object[] firstResult = (Object[]) results.get(0);
Integer id = firstResult[0];
String summary = firstResult[1];
String body = firstResult[2];
String authorName = firstResult[3];</programlisting>
        </example>

        <para>Hibernate Search extracts the properties from the Lucene index
        and convert them back to their object representation, returning a list
        of <classname>Object[]</classname>. Projections avoid a potential
        database round trip (useful if the query response time is critical),
        but has some constraints:</para>

        <itemizedlist>
          <listitem>
            <para>the properties projected must be stored in the index
            (<literal>@Field(store=Store.YES)</literal>), which increase the
            index size</para>
          </listitem>

          <listitem>
            <para>the properties projected must use a
            <literal>FieldBridge</literal> implementing
            <classname>org.hibernate.search.bridge.TwoWayFieldBridge</classname>
            or
            <literal>org.hibernate.search.bridge.TwoWayStringBridge</literal>,
            the latter being the simpler version. All Hibernate Search
            built-in types are two-way.</para>
          </listitem>

          <listitem>
            <para>you can only project simple properties of the indexed entity
            or its embedded associations. This means you cannot project a
            whole embedded entity.</para>
          </listitem>

          <listitem>
            <para>projection does not work on collections or maps which are
            indexed via <classname>@IndexedEmbedded</classname></para>
          </listitem>
        </itemizedlist>

        <para>Projection is useful for another kind of use cases. Lucene
        provides some metadata information to the user about the results. By
        using some special placeholders, the projection mechanism can retrieve
        them:</para>

        <example>
          <title>Using projection in order to retrieve meta data</title>

          <programlisting>org.hibernate.search.FullTextQuery query = 
    s.createFullTextQuery( luceneQuery, Book.class );
query.<emphasis role="bold">setProjection( 
    FullTextQuery.SCORE, 
    FullTextQuery.THIS, 
    "mainAuthor.name" )</emphasis>;
List results = query.list();
Object[] firstResult = (Object[]) results.get(0);
float score = firstResult[0];
Book book = firstResult[1];
String authorName = firstResult[2];</programlisting>
        </example>

        <para>You can mix and match regular fields and special placeholders.
        Here is the list of available placeholders:</para>

        <itemizedlist>
          <listitem>
            <para><classname>FullTextQuery.THIS</classname>: returns the
            initialized and managed entity (as a non projected query would
            have done).</para>
          </listitem>

          <listitem>
            <para><classname>FullTextQuery.DOCUMENT</classname>: returns the
            Lucene Document related to the object projected.</para>
          </listitem>

          <listitem>
            <para><classname>FullTextQuery.OBJECT_CLASS</classname>: returns
            the class of the indexed entity.</para>
          </listitem>

          <listitem>
            <para><classname>FullTextQuery.SCORE</classname>: returns the
            document score in the query. Scores are handy to compare one
            result against an other for a given query but are useless when
            comparing the result of different queries.</para>
          </listitem>

          <listitem>
            <para><classname>FullTextQuery.ID</classname>: the id property
            value of the projected object.</para>
          </listitem>

          <listitem>
            <para><classname>FullTextQuery.DOCUMENT_ID</classname>: the Lucene
            document id. Careful, Lucene document id can change overtime
            between two different IndexReader opening (this feature is
            experimental).</para>
          </listitem>

          <listitem>
            <para><classname>FullTextQuery.EXPLANATION</classname>: returns
            the Lucene Explanation object for the matching object/document in
            the given query. Do not use if you retrieve a lot of data. Running
            explanation typically is as costly as running the whole Lucene
            query per matching element. Make sure you use projection!</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Limiting the time of a query</title>

        <para>You can decide to stop a query if when it takes more than a
        predefined amount of time. Note that this is a best effort basis but
        if Hibernate Search still has significant work to do and if we are
        beyond the time limit, a <classname>QueryTimeoutException</classname>
        will be raised
        (<classname>org.hibernate.QueryTimeoutException</classname> or
        <classname>javax.persistence.QueryTimeoutException</classname>
        depending on your programmatic API).</para>

        <para>To define the limit when using the native Hibernate APIs, use
        one of the following approaches</para>

        <example>
          <title>Defining a timeout in query execution</title>

          <programlisting>Query luceneQuery = ...;
FullTextQuery query = fullTextSession.createFullTextQuery(luceneQuery, User.class);

//define the timeout in seconds
query.setTimeout(5);

//alternatively, define the timeout in any given time unit
query.setTimeout(450, TimeUnit.MILLISECONDS);

try {
    query.list();
}
catch (org.hibernate.QueryTimeoutException e) {
    //do something, too slow
}</programlisting>
        </example>

        <para>Likewise <literal>getResultSize()</literal>,
        <methodname>iterate()</methodname> and
        <methodname>scroll()</methodname> honor the timeout but only until the
        end of the method call. That simply means that the methods of
        <classname>Iterable</classname> or the
        <classname>ScrollableResults</classname> ignore the timeout.</para>

        <note>
          <para><methodname>explain()</methodname> does not honor the timeout:
          this method is used for debug purposes and in particular to find out
          why a query is slow ;)</para>
        </note>

        <para>When using JPA, simply use the standard way of limiting query
        execution time.</para>

        <example>
          <title>Defining a timeout in query execution</title>

          <programlisting>Query luceneQuery = ...;
FullTextQuery query = fullTextEM.createFullTextQuery(luceneQuery, User.class);

//define the timeout in milliseconds
query.setHint( "javax.persistence.query.timeout", 450 );

try {
    query.getResultList();
}
catch (javax.persistence.QueryTimeoutException e) {
    //do something, too slow
}</programlisting>
        </example>

        <para>Remember, this is a best effort basis and not a guarantee to
        stop passed a certain time.</para>
      </section>
    </section>
  </section>

  <section>
    <title>Retrieving the results</title>

    <para>Once the Hibernate Search query is built, executing it is in no way
    different than executing a HQL or Criteria query. The same paradigm and
    object semantic applies. All the common operations are available:
    <methodname>list()</methodname>, <methodname>uniqueResult()</methodname>,
    <methodname>iterate()</methodname>,
    <methodname>scroll()</methodname>.</para>

    <section>
      <title>Performance considerations</title>

      <para>If you expect a reasonable number of results (for example using
      pagination) and expect to work on all of them,
      <methodname>list()</methodname> or
      <methodname>uniqueResult()</methodname> are recommended.
      <methodname>list()</methodname> work best if the entity
      <literal>batch-size</literal> is set up properly. Note that Hibernate
      Search has to process all Lucene Hits elements (within the pagination)
      when using <methodname>list()</methodname> ,
      <methodname>uniqueResult()</methodname> and
      <methodname>iterate()</methodname>.</para>

      <para>If you wish to minimize Lucene document loading,
      <methodname>scroll()</methodname> is more appropriate. Don't forget to
      close the <classname>ScrollableResults</classname> object when you're
      done, since it keeps Lucene resources. If you expect to use
      <methodname>scroll,</methodname> but wish to load objects in batch, you
      can use <methodname>query.setFetchSize()</methodname>. When an object is
      accessed, and if not already loaded, Hibernate Search will load the next
      <literal>fetchSize</literal> objects in one pass.</para>

      <para>Pagination is a preferred method over scrolling though.</para>
    </section>

    <section>
      <title>Result size</title>

      <para>It is sometime useful to know the total number of matching
      documents:</para>

      <itemizedlist>
        <listitem>
          <para>for the Google-like feature 1-10 of about 888,000,000</para>
        </listitem>

        <listitem>
          <para>to implement a fast pagination navigation</para>
        </listitem>

        <listitem>
          <para>to implement a multi step search engine (adding approximation
          if the restricted query return no or not enough results)</para>
        </listitem>
      </itemizedlist>

      <para>Of course it would be too costly to retrieve all the matching
      documents. Hibernate Search allows you to retrieve the total number of
      matching documents regardless of the pagination parameters. Even more
      interesting, you can retrieve the number of matching elements without
      triggering a single object load.</para>

      <example>
        <title>Determining the result size of a query</title>

        <programlisting>org.hibernate.search.FullTextQuery query = 
    s.createFullTextQuery( luceneQuery, Book.class );
//return the number of matching books without loading a single one
assert 3245 == <emphasis role="bold">query.getResultSize()</emphasis>; 

org.hibernate.search.FullTextQuery query = 
    s.createFullTextQuery( luceneQuery, Book.class );
query.setMaxResult(10);
List results = query.list();
//return the total number of matching books regardless of pagination
assert 3245 == <emphasis role="bold">query.getResultSize()</emphasis>; </programlisting>
      </example>

      <note>
        <para>Like Google, the number of results is approximative if the index
        is not fully up-to-date with the database (asynchronous cluster for
        example).</para>
      </note>
    </section>

    <section>
      <title>ResultTransformer</title>

      <para>Especially when using projection, the data structure returned by a
      query (an object array in this case), is not always matching the
      application needs. It is possible to apply a
      <classname>ResultTransformer</classname> operation post query to match
      the targeted data structure:</para>

      <example>
        <title>Using ResultTransformer in conjunction with projections</title>

        <programlisting>org.hibernate.search.FullTextQuery query = 
    s.createFullTextQuery( luceneQuery, Book.class );
query.setProjection( "title", "mainAuthor.name" );

<emphasis role="bold">query.setResultTransformer( 
    new StaticAliasToBeanResultTransformer( 
        BookView.class, 
        "title", 
        "author" ) 
);</emphasis>
List&lt;BookView&gt; results = (List&lt;BookView&gt;) query.list();
for(BookView view : results) {
    log.info( "Book: " + view.getTitle() + ", " + view.getAuthor() );
}</programlisting>
      </example>

      <para>Examples of <classname>ResultTransformer</classname>
      implementations can be found in the Hibernate Core codebase.</para>
    </section>

    <section>
      <title>Understanding results</title>

      <para>You will find yourself sometimes puzzled by a result showing up in
      a query or a result not showing up in a query. Luke is a great tool to
      understand those mysteries. However, Hibernate Search also gives you
      access to the Lucene <classname>Explanation</classname> object for a
      given result (in a given query). This class is considered fairly
      advanced to Lucene users but can provide a good understanding of the
      scoring of an object. You have two ways to access the Explanation object
      for a given result:</para>

      <itemizedlist>
        <listitem>
          <para>Use the <methodname>fullTextQuery.explain(int)</methodname>
          method</para>
        </listitem>

        <listitem>
          <para>Use projection</para>
        </listitem>
      </itemizedlist>

      <para>The first approach takes a document id as a parameter and return
      the Explanation object. The document id can be retrieved using
      projection and the <literal>FullTextQuery.DOCUMENT_ID</literal>
      constant.</para>

      <warning>
        <para>The Document id has nothing to do with the entity id. Do not
        mess up these two notions.</para>
      </warning>

      <para>The second approach let's you project the
      <classname>Explanation</classname> object using the
      <literal>FullTextQuery.EXPLANATION</literal> constant.</para>

      <example>
        <title>Retrieving the Lucene Explanation object using
        projection</title>

        <programlisting>FullTextQuery ftQuery = s.createFullTextQuery( luceneQuery, Dvd.class )
        .setProjection( 
             FullTextQuery.DOCUMENT_ID, 
             <emphasis role="bold">FullTextQuery.EXPLANATION</emphasis>, 
             FullTextQuery.THIS );
@SuppressWarnings("unchecked") List&lt;Object[]&gt; results = ftQuery.list();
for (Object[] result : results) {
    Explanation e = (Explanation) result[1];
    display( e.toString() );
}</programlisting>
      </example>

      <para>Be careful, building the explanation object is quite expensive, it
      is roughly as expensive as running the Lucene query again. Don't do it
      if you don't need the object</para>
    </section>
  </section>

  <section id="query-filter">
    <title>Filters</title>

    <para>Apache Lucene has a powerful feature that allows to filter query
    results according to a custom filtering process. This is a very powerful
    way to apply additional data restrictions, especially since filters can be
    cached and reused. Some interesting use cases are:</para>

    <itemizedlist>
      <listitem>
        <para>security</para>
      </listitem>

      <listitem>
        <para>temporal data (eg. view only last month's data)</para>
      </listitem>

      <listitem>
        <para>population filter (eg. search limited to a given
        category)</para>
      </listitem>

      <listitem>
        <para>and many more</para>
      </listitem>
    </itemizedlist>

    <para>Hibernate Search pushes the concept further by introducing the
    notion of parameterizable named filters which are transparently cached.
    For people familiar with the notion of Hibernate Core filters, the API is
    very similar:</para>

    <example>
      <title>Enabling fulltext filters for a given query</title>

      <programlisting>fullTextQuery = s.createFullTextQuery( query, Driver.class );
fullTextQuery.enableFullTextFilter("bestDriver");
fullTextQuery.enableFullTextFilter("security").setParameter( "login", "andre" );
fullTextQuery.list(); //returns only best drivers where andre has credentials</programlisting>
    </example>

    <para>In this example we enabled two filters on top of the query. You can
    enable (or disable) as many filters as you like.</para>

    <para>Declaring filters is done through the
    <classname>@FullTextFilterDef</classname> annotation. This annotation can
    be on any <literal>@Indexed</literal> entity regardless of the query the
    filter is later applied to. This implies that filter definitions are
    global and their names must be unique. A
    <classname>SearchException</classname> is thrown in case two different
    <classname>@FullTextFilterDef</classname> annotations with the same name
    are defined. Each named filter has to specify its actual filter
    implementation.</para>

    <example>
      <title>Defining and implementing a Filter</title>

      <programlisting>@Entity
@Indexed
@FullTextFilterDefs( {
    <emphasis role="bold">@FullTextFilterDef(name = "bestDriver", impl = BestDriversFilter.class)</emphasis>, 
    <emphasis role="bold">@FullTextFilterDef(name = "security", impl = SecurityFilterFactory.class)</emphasis> 
})
public class Driver { ... }</programlisting>

      <programlisting>public class BestDriversFilter extends <emphasis
          role="bold">org.apache.lucene.search.Filter</emphasis> {

    public DocIdSet getDocIdSet(IndexReader reader) throws IOException {
        OpenBitSet bitSet = new OpenBitSet( reader.maxDoc() );
        TermDocs termDocs = reader.termDocs( new Term( "score", "5" ) );
        while ( termDocs.next() ) {
            bitSet.set( termDocs.doc() );
        }
        return bitSet;
    }
}</programlisting>
    </example>

    <para><classname>BestDriversFilter</classname> is an example of a simple
    Lucene filter which reduces the result set to drivers whose score is 5. In
    this example the specified filter implements the
    <literal>org.apache.lucene.search.Filter</literal> directly and contains a
    no-arg constructor.</para>

    <para>If your Filter creation requires additional steps or if the filter
    you want to use does not have a no-arg constructor, you can use the
    factory pattern:</para>

    <example>
      <title>Creating a filter using the factory pattern</title>

      <programlisting>@Entity
@Indexed
@FullTextFilterDef(name = "bestDriver", impl = BestDriversFilterFactory.class)
public class Driver { ... }

public class BestDriversFilterFactory {

    <emphasis role="bold">@Factory</emphasis>
    public Filter getFilter() {
        //some additional steps to cache the filter results per IndexReader
        Filter bestDriversFilter = new BestDriversFilter();
        return new CachingWrapperFilter(bestDriversFilter);
    }
}</programlisting>
    </example>

    <para>Hibernate Search will look for a <literal>@Factory</literal>
    annotated method and use it to build the filter instance. The factory must
    have a no-arg constructor. For people familiar with JBoss Seam, this is
    similar to the component factory pattern, but the annotation is
    different!</para>

    <para>Named filters come in handy where parameters have to be passed to
    the filter. For example a security filter might want to know which
    security level you want to apply:</para>

    <example>
      <title>Passing parameters to a defined filter</title>

      <programlisting>fullTextQuery = s.createFullTextQuery( query, Driver.class );
fullTextQuery.enableFullTextFilter("security")<emphasis role="bold">.setParameter( "level", 5 )</emphasis>;</programlisting>
    </example>

    <para>Each parameter name should have an associated setter on either the
    filter or filter factory of the targeted named filter definition.</para>

    <example>
      <title>Using parameters in the actual filter implementation</title>

      <programlisting>public class SecurityFilterFactory {
    private Integer level;

    /**
     * injected parameter
     */
    <emphasis role="bold">public void setLevel(Integer level)</emphasis> {
        this.level = level;
    }

    <emphasis role="bold">@Key
    public FilterKey getKey()</emphasis> {
        StandardFilterKey key = new StandardFilterKey();
        key.addParameter( level );
        return key;
    }

    @Factory
    public Filter getFilter() {
        Query query = new TermQuery( new Term("level", level.toString() ) );
        return new CachingWrapperFilter( new QueryWrapperFilter(query) );
    }
}</programlisting>
    </example>

    <para>Note the method annotated <classname>@Key</classname> returning a
    <classname>FilterKey</classname> object. The returned object has a special
    contract: the key object must implement <methodname>equals()</methodname>
    / <methodname>hashCode()</methodname> so that 2 keys are equal if and only
    if the given <classname>Filter</classname> types are the same and the set
    of parameters are the same. In other words, 2 filter keys are equal if and
    only if the filters from which the keys are generated can be interchanged.
    The key object is used as a key in the cache mechanism.</para>

    <para><classname>@Key</classname> methods are needed only if:</para>

    <itemizedlist>
      <listitem>
        <para>you enabled the filter caching system (enabled by
        default)</para>
      </listitem>

      <listitem>
        <para>your filter has parameters</para>
      </listitem>
    </itemizedlist>

    <para>In most cases, using the <literal>StandardFilterKey</literal>
    implementation will be good enough. It delegates the
    <methodname>equals()</methodname> / <methodname>hashCode()</methodname>
    implementation to each of the parameters equals and hashcode
    methods.</para>

    <para>As mentioned before the defined filters are per default cached and
    the cache uses a combination of hard and soft references to allow disposal
    of memory when needed. The hard reference cache keeps track of the most
    recently used filters and transforms the ones least used to
    <classname>SoftReferences</classname> when needed. Once the limit of the
    hard reference cache is reached additional filters are cached as
    <classname>SoftReferences</classname>. To adjust the size of the hard
    reference cache, use
    <literal>hibernate.search.filter.cache_strategy.size</literal> (defaults
    to 128). For advanced use of filter caching, you can implement your own
    <classname>FilterCachingStrategy</classname>. The classname is defined by
    <literal>hibernate.search.filter.cache_strategy</literal>.</para>

    <para>This filter caching mechanism should not be confused with caching
    the actual filter results. In Lucene it is common practice to wrap filters
    using the <classname>IndexReader</classname> around a
    <classname>CachingWrapperFilter.</classname> The wrapper will cache the
    <classname>DocIdSet</classname> returned from the
    <methodname>getDocIdSet(IndexReader reader)</methodname> method to avoid
    expensive recomputation. It is important to mention that the computed
    <classname>DocIdSet</classname> is only cachable for the same
    <classname>IndexReader</classname> instance, because the reader
    effectively represents the state of the index at the moment it was opened.
    The document list cannot change within an opened
    <classname>IndexReader</classname>. A different/new<classname>
    IndexReader</classname> instance, however, works potentially on a
    different set of <classname>Document</classname>s (either from a different
    index or simply because the index has changed), hence the cached
    <classname>DocIdSet</classname> has to be recomputed.</para>

    <para>Hibernate Search also helps with this aspect of caching. Per default
    the <literal>cache</literal> flag of <classname>@FullTextFilterDef
    </classname>is set to
    <literal>FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS</literal> which
    will automatically cache the filter instance as well as wrap the specified
    filter around a Hibernate specific implementation of
    <classname>CachingWrapperFilter</classname>
    (<classname>org.hibernate.search.filter.CachingWrapperFilter</classname>).
    In contrast to Lucene's version of this class
    <classname>SoftReference</classname>s are used together with a hard
    reference count (see discussion about filter cache). The hard reference
    count can be adjusted using
    <literal>hibernate.search.filter.cache_docidresults.size</literal>
    (defaults to 5). The wrapping behaviour can be controlled using the
    <literal>@FullTextFilterDef.cache</literal> parameter. There are three
    different values for this parameter:</para>

    <para><informaltable align="left" width="">
        <tgroup cols="2">
          <thead>
            <row>
              <entry align="center">Value</entry>

              <entry align="center">Definition</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry align="left">FilterCacheModeType.NONE</entry>

              <entry>No filter instance and no result is cached by Hibernate
              Search. For every filter call, a new filter instance is created.
              This setting might be useful for rapidly changing data sets or
              heavily memory constrained environments.</entry>
            </row>

            <row>
              <entry align="left">FilterCacheModeType.INSTANCE_ONLY</entry>

              <entry>The filter instance is cached and reused across
              concurrent <methodname>Filter.getDocIdSet()</methodname> calls.
              <classname>DocIdSet</classname> results are not cached. This
              setting is useful when a filter uses its own specific caching
              mechanism or the filter results change dynamically due to
              application specific events making
              <classname>DocIdSet</classname> caching in both cases
              unnecessary.</entry>
            </row>

            <row>
              <entry
              align="left">FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS</entry>

              <entry>Both the filter instance and the
              <classname>DocIdSet</classname> results are cached. This is the
              default value.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>Last but not least - why should filters be cached? There
    are two areas where filter caching shines:</para>

    <itemizedlist>
      <listitem>
        <para>the system does not update the targeted entity index often (in
        other words, the IndexReader is reused a lot)</para>
      </listitem>

      <listitem>
        <para>the Filter's DocIdSet is expensive to compute (compared to the
        time spent to execute the query)</para>
      </listitem>
    </itemizedlist>

    <section id="query-filter-shard">
      <title>Using filters in a sharded environment</title>

      <para>It is possible, in a sharded environment to execute queries on a
      subset of the available shards. This can be done in two steps:</para>

      <itemizedlist>
        <listitem>
          <para>create a sharding strategy that does select a subset of
          <classname>DirectoryProvider</classname>s depending on sone filter
          configuration</para>
        </listitem>

        <listitem>
          <para>activate the proper filter at query time</para>
        </listitem>
      </itemizedlist>

      <para>Let's first look at an example of sharding strategy that query on
      a specific customer shard if the customer filter is activated.</para>

      <programlisting>public class CustomerShardingStrategy implements IndexShardingStrategy {

	// stored DirectoryProviders in a array indexed by customerID
	private DirectoryProvider&lt;?&gt;[] providers;
	
	public void initialize(Properties properties, DirectoryProvider&lt;?&gt;[] providers) {
		this.providers = providers;
	}

	public DirectoryProvider&lt;?&gt;[] getDirectoryProvidersForAllShards() {
		return providers;
	}

	public DirectoryProvider&lt;?&gt; getDirectoryProviderForAddition(Class&lt;?&gt; entity, Serializable id, String idInString, Document document) {
		Integer customerID = Integer.parseInt(document.getField("customerID").stringValue());
		return providers[customerID];
	}

	public DirectoryProvider&lt;?&gt;[] getDirectoryProvidersForDeletion(Class&lt;?&gt; entity, Serializable id, String idInString) {
		return getDirectoryProvidersForAllShards();
	}

<emphasis role="bold">	/**
	 * Optimization; don't search ALL shards and union the results; in this case, we 
	 * can be certain that all the data for a particular customer Filter is in a single
	 * shard; simply return that shard by customerID.
	 */
	public DirectoryProvider&lt;?&gt;[] getDirectoryProvidersForQuery(FullTextFilterImplementor[] filters) {
		FFullTextFilter filter = getCustomerFilter(filters, "customer");
		if (filter == null) {
			return getDirectoryProvidersForAllShards();
		}
		else {
			return new DirectoryProvider[] { providers[Integer.parseInt(filter.getParameter("customerID").toString())] };
		}
	}

	private FullTextFilter getFilter(FullTextFilterImplementor[] filters, String name) {
		for (FullTextFilterImplementor filter: filters) {
			if (filter.getName().equals(name)) return filter;
		}
		return null;
	}</emphasis>

}</programlisting>

      <para>In this example, if the filter named <literal>customer</literal>
      is present, we make sure to only use the shard dedicated to this
      customer. Otherwise, we return all shards. A given Sharding strategy can
      react to one or more filters and depends on their parameters.</para>

      <para>The second step is simply to activate the filter at query time.
      While the filter can be a regular filter (as defined in <xref
      linkend="query-filter" />) which also filters Lucene results after the
      query, you can make use of a special filter that will only be passed to
      the sharding strategy and otherwise ignored for the rest of the query.
      Simply use the <classname>ShardSensitiveOnlyFilter</classname> class
      when declaring your filter.</para>

      <programlisting>@Entity @Indexed
<emphasis role="bold">@FullTextFilterDef(name="customer", impl=ShardSensitiveOnlyFilter.class)</emphasis>
public class Customer {
   ...
}


FullTextQuery query = ftEm.createFullTextQuery(luceneQuery, Customer.class);
<emphasis role="bold">query.enableFulltextFilter("customer").setParameter("CustomerID", 5);</emphasis>
@SuppressWarnings("unchecked")
List&lt;Customer&gt; results = query.getResultList();</programlisting>

      <para>Note that by using the
      <classname>ShardSensitiveOnlyFilter</classname>, you do not have to
      implement any Lucene filter. Using filters and sharding strategy
      reacting to these filters is recommended to speed up queries in a
      sharded environment.</para>
    </section>
  </section>

  <section>
    <title>Optimizing the query process</title>

    <para>Query performance depends on several criteria:</para>

    <itemizedlist>
      <listitem>
        <para>the Lucene query itself: read the literature on this
        subject</para>
      </listitem>

      <listitem>
        <para>the number of object loaded: use pagination (always ;-) ) or
        index projection (if needed)</para>
      </listitem>

      <listitem>
        <para>the way Hibernate Search interacts with the Lucene readers:
        defines the appropriate <xref
        linkend="search-architecture-readerstrategy" />.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Native Lucene Queries</title>

    <para>If you wish to use some specific features of Lucene, you can always
    run Lucene specific queries. Check <xref linkend="search-lucene-native" />
    for more information.</para>
  </section>
</chapter>
